// swift-interface-format-version: 1.0
// swift-compiler-version: Apple Swift version 5.7 (swiftlang-5.7.0.127.4 clang-1400.0.29.50)
// swift-module-flags: -target x86_64-apple-ios12.0-simulator -enable-objc-interop -enable-library-evolution -swift-version 5 -enforce-exclusivity=checked -O -module-name DGis
// swift-module-flags-ignorable: -enable-bare-slash-regex
import AVFoundation
import CallKit
import CarPlay/*.CPTemplateApplicationDashboardScene*/
import CarPlay/*.CPTemplateApplicationScene*/
import CoreGraphics
import CoreGraphics/*.CGAffineTransform*/
import CoreGraphics/*.CGFloat*/
import CoreLocation
import CoreTelephony
import Dispatch
import Dispatch/*.DispatchQueue*/
import Foundation
import Foundation/*.Data*/
import Foundation/*.Date*/
import Foundation/*.ProcessInfo*/
import Foundation/*.TimeInterval*/
import GLKit
import Metal/*.MTLDevice*/
import MetalKit
import Foundation.NSProcessInfo/*.ProcessInfo*/
import Network
import QuartzCore/*.CADisplayLink*/
import Swift
import SystemConfiguration
import UIKit
import UIKit/*.CACurrentMediaTime*/
import UIKit/*.UIApplication*/
import UIKit/*.UIColor*/
import UIKit/*.UICoordinateSpace*/
import UIKit/*.UIDevice*/
import UIKit/*.UIImage*/
import UIKit/*.UIScreen*/
import UIKit/*.UITableViewCell*/
import UIKit/*.UITraitCollection*/
import UIKit/*.UIUserInterfaceStyle*/
import UIKit/*.UIView*/
import _Concurrency
import _StringProcessing
import os
public struct BuildingId : Swift.Hashable {
  public var value: Swift.UInt64
  public init(value: Swift.UInt64 = 0)
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (a: DGis.BuildingId, b: DGis.BuildingId) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
}
public struct DayTime : Swift.Hashable {
  public var hours: Swift.UInt8
  public var minutes: Swift.UInt8
  public init(hours: Swift.UInt8, minutes: Swift.UInt8)
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (a: DGis.DayTime, b: DGis.DayTime) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
}
public struct DgisObjectId : Swift.Hashable {
  public var objectId: Swift.UInt64
  public var entranceId: Swift.UInt64
  public init(objectId: Swift.UInt64 = 0, entranceId: Swift.UInt64 = 0)
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (a: DGis.DgisObjectId, b: DGis.DgisObjectId) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
}
@_hasMissingDesignatedInitializers final public class Context : Swift.Hashable {
  @objc deinit
  public static func == (lhs: DGis.Context, rhs: DGis.Context) -> Swift.Bool
  final public func hash(into hasher: inout Swift.Hasher)
  final public var hashValue: Swift.Int {
    get
  }
}
@_hasMissingDesignatedInitializers final public class SystemMemoryManager : Swift.Hashable {
  @objc deinit
  public static func == (lhs: DGis.SystemMemoryManager, rhs: DGis.SystemMemoryManager) -> Swift.Bool
  final public func hash(into hasher: inout Swift.Hasher)
  final public func reduceMemoryUsage()
  final public var hashValue: Swift.Int {
    get
  }
}
public struct LevelId : Swift.Hashable {
  public var value: Swift.UInt64
  public init(value: Swift.UInt64 = 0)
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (a: DGis.LevelId, b: DGis.LevelId) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
}
public struct LevelInfo : Swift.Hashable {
  public var id: DGis.LevelId
  public var name: Swift.String
  public init(id: DGis.LevelId, name: Swift.String)
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (a: DGis.LevelInfo, b: DGis.LevelInfo) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
}
public enum PersonalDataCollectionConsent : Swift.UInt32 {
  case granted
  case denied
  public init?(rawValue: Swift.UInt32)
  public typealias RawValue = Swift.UInt32
  public var rawValue: Swift.UInt32 {
    get
  }
}
public struct ScreenSize : Swift.Hashable {
  public var width: Swift.UInt32
  public var height: Swift.UInt32
  public init(width: Swift.UInt32 = 0, height: Swift.UInt32 = 0)
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (a: DGis.ScreenSize, b: DGis.ScreenSize) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
}
public enum WeekDay : Swift.UInt32 {
  case sunday
  case monday
  case tuesday
  case wednesday
  case thursday
  case friday
  case saturday
  public init?(rawValue: Swift.UInt32)
  public typealias RawValue = Swift.UInt32
  public var rawValue: Swift.UInt32 {
    get
  }
}
public struct WeekTime : Swift.Hashable {
  public var weekDay: DGis.WeekDay
  public var time: DGis.DayTime
  public init(weekDay: DGis.WeekDay, time: DGis.DayTime)
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (a: DGis.WeekTime, b: DGis.WeekTime) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
}
public struct WeekTimeInterval : Swift.Hashable {
  public var startTime: DGis.WeekTime
  public var finishTime: DGis.WeekTime
  public init(startTime: DGis.WeekTime, finishTime: DGis.WeekTime)
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (a: DGis.WeekTimeInterval, b: DGis.WeekTimeInterval) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
}
public func getSystemMemoryManager(context: DGis.Context) -> DGis.SystemMemoryManager
@_hasMissingDesignatedInitializers final public class File : Swift.Hashable {
  @objc deinit
  public static func == (lhs: DGis.File, rhs: DGis.File) -> Swift.Bool
  final public func hash(into hasher: inout Swift.Hasher)
  convenience public init(path: Swift.String)
  public static func fromString(contents: Swift.String) -> DGis.File
  final public var hashValue: Swift.Int {
    get
  }
}
public struct Latitude : Swift.Hashable {
  public var value: Swift.Double
  public init(value: Swift.Double = 0)
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (a: DGis.Latitude, b: DGis.Latitude) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
}
public struct Longitude : Swift.Hashable {
  public var value: Swift.Double
  public init(value: Swift.Double = 0)
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (a: DGis.Longitude, b: DGis.Longitude) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
}
public struct GeoPoint : Swift.Hashable {
  public var latitude: DGis.Latitude
  public var longitude: DGis.Longitude
  public init(latitude: DGis.Latitude, longitude: DGis.Longitude)
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (a: DGis.GeoPoint, b: DGis.GeoPoint) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
}
public struct GeoRect : Swift.Hashable {
  public var southWestPoint: DGis.GeoPoint
  public var northEastPoint: DGis.GeoPoint
  public init(southWestPoint: DGis.GeoPoint, northEastPoint: DGis.GeoPoint)
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (a: DGis.GeoRect, b: DGis.GeoRect) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
}
public struct Bearing : Swift.Hashable {
  public var value: Swift.Double
  public init(value: Swift.Double = 0)
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (a: DGis.Bearing, b: DGis.Bearing) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
}
extension DGis.GeoRect {
  public var isValid: Swift.Bool {
    get
  }
}
extension DGis.GeoPoint {
  public var isValid: Swift.Bool {
    get
  }
}
extension DGis.GeoRect {
  public func contains(rect2: DGis.GeoRect) -> Swift.Bool
}
extension DGis.GeoRect {
  public func contains(point: DGis.GeoPoint) -> Swift.Bool
}
extension DGis.GeoRect {
  public func expand(rect2: DGis.GeoRect) -> DGis.GeoRect
}
extension DGis.GeoRect {
  public func expand(point: DGis.GeoPoint) -> DGis.GeoRect
}
extension DGis.GeoRect {
  public var isDegenerate: Swift.Bool {
    get
  }
}
extension DGis.GeoRect {
  public func intersects(rect2: DGis.GeoRect) -> Swift.Bool
}
public struct ApartmentRange : Swift.Hashable {
  public var start: Swift.String
  public var end: Swift.String?
  public init(start: Swift.String, end: Swift.String? = nil)
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (a: DGis.ApartmentRange, b: DGis.ApartmentRange) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
}
public struct Attribute : Swift.Hashable {
  public var tag: Swift.String
  public var value: Swift.String
  public init(tag: Swift.String, value: Swift.String)
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (a: DGis.Attribute, b: DGis.Attribute) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
}
public struct PurposeCode : Swift.Hashable {
  public var value: Swift.UInt64
  public init(value: Swift.UInt64 = 0)
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (a: DGis.PurposeCode, b: DGis.PurposeCode) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
}
public struct BuildingLevels : Swift.Hashable {
  public var defaultLevelId: DGis.LevelId
  public var levels: [DGis.LevelInfo]
  public init(defaultLevelId: DGis.LevelId, levels: [DGis.LevelInfo])
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (a: DGis.BuildingLevels, b: DGis.BuildingLevels) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
}
public struct BuildingInfo : Swift.Hashable {
  public var buildingName: Swift.String?
  public var purposeName: Swift.String?
  public var purposeCode: DGis.PurposeCode?
  public var buildingLevels: DGis.BuildingLevels?
  public init(buildingName: Swift.String? = nil, purposeName: Swift.String? = nil, purposeCode: DGis.PurposeCode? = nil, buildingLevels: DGis.BuildingLevels? = nil)
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (a: DGis.BuildingInfo, b: DGis.BuildingInfo) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
}
public struct ContactInfo : Swift.Hashable {
  public var type: Swift.String
  public var displayText: Swift.String
  public var value: Swift.String
  public var comment: Swift.String?
  public init(type: Swift.String, displayText: Swift.String, value: Swift.String, comment: Swift.String?)
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (a: DGis.ContactInfo, b: DGis.ContactInfo) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
}
public struct IsOpenNow : Swift.Hashable {
  public init()
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (a: DGis.IsOpenNow, b: DGis.IsOpenNow) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
}
public enum WorkTimeFilter : Swift.Hashable {
  case workTime(DGis.WeekTime)
  case isOpenNow(DGis.IsOpenNow)
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (a: DGis.WorkTimeFilter, b: DGis.WorkTimeFilter) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
}
public struct FlagFilter : Swift.Hashable {
  public var tagName: Swift.String
  public var displayName: Swift.String
  public var flagValue: Swift.Bool?
  public init(tagName: Swift.String, displayName: Swift.String, flagValue: Swift.Bool?)
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (a: DGis.FlagFilter, b: DGis.FlagFilter) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
}
public struct RangeFilter : Swift.Hashable {
  public var tagName: Swift.String
  public var displayName: Swift.String
  public var minValue: Swift.Double
  public var maxValue: Swift.Double
  public init(tagName: Swift.String, displayName: Swift.String, minValue: Swift.Double, maxValue: Swift.Double)
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (a: DGis.RangeFilter, b: DGis.RangeFilter) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
}
public struct SortingFilter : Swift.Hashable {
  public var tagName: Swift.String
  public var displayName: Swift.String
  public init(tagName: Swift.String, displayName: Swift.String)
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (a: DGis.SortingFilter, b: DGis.SortingFilter) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
}
public enum DynamicFilter : Swift.Hashable {
  case flagFilter(DGis.FlagFilter)
  case rangeFilter(DGis.RangeFilter)
  case sortingFilter(DGis.SortingFilter)
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (a: DGis.DynamicFilter, b: DGis.DynamicFilter) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
}
public struct DirectoryFilter : Swift.Hashable {
  public var workTime: DGis.WorkTimeFilter?
  public var dynamic: [DGis.DynamicFilter]
  public init(workTime: DGis.WorkTimeFilter?, dynamic: [DGis.DynamicFilter])
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (a: DGis.DirectoryFilter, b: DGis.DirectoryFilter) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
}
public struct EntranceGeometry : Swift.Hashable {
  public var entrancePoints: [DGis.GeoPoint]
  public var entrancePolylines: [[DGis.GeoPoint]]
  public init(entrancePoints: [DGis.GeoPoint], entrancePolylines: [[DGis.GeoPoint]])
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (a: DGis.EntranceGeometry, b: DGis.EntranceGeometry) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
}
public struct EntranceInfo : Swift.Hashable {
  public var id: DGis.DgisObjectId
  public var buildingNumber: Swift.String?
  public var porchName: Swift.String?
  public var porchNumber: Swift.String?
  public var apartmentRanges: [DGis.ApartmentRange]
  public var geometry: DGis.EntranceGeometry?
  public init(id: DGis.DgisObjectId, buildingNumber: Swift.String?, porchName: Swift.String?, porchNumber: Swift.String?, apartmentRanges: [DGis.ApartmentRange], geometry: DGis.EntranceGeometry?)
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (a: DGis.EntranceInfo, b: DGis.EntranceInfo) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
}
public enum FilterType : Swift.UInt32 {
  case sORT
  case fILTER
  public init?(rawValue: Swift.UInt32)
  public typealias RawValue = Swift.UInt32
  public var rawValue: Swift.UInt32 {
    get
  }
}
public struct FloorInfo : Swift.Hashable {
  public var levelId: DGis.LevelId
  public var buildingId: DGis.BuildingId
  public init(levelId: DGis.LevelId, buildingId: DGis.BuildingId)
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (a: DGis.FloorInfo, b: DGis.FloorInfo) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
}
public struct FormattedAddress : Swift.Hashable {
  public var drilldownAddress: Swift.String?
  public var streetAddress: Swift.String?
  public var addressComment: Swift.String?
  public var postCode: Swift.String?
  public init(drilldownAddress: Swift.String?, streetAddress: Swift.String?, addressComment: Swift.String?, postCode: Swift.String?)
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (a: DGis.FormattedAddress, b: DGis.FormattedAddress) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
}
public enum FormattingType : Swift.UInt32 {
  case short
  case full
  public init?(rawValue: Swift.UInt32)
  public typealias RawValue = Swift.UInt32
  public var rawValue: Swift.UInt32 {
    get
  }
}
@_hasMissingDesignatedInitializers final public class ItemMarkerInfo : Swift.Hashable {
  final public var objectId: DGis.DgisObjectId? {
    get
  }
  final public var geoPoint: DGis.GeoPointWithElevation {
    get
  }
  final public var floorInfo: DGis.FloorInfo? {
    get
  }
  @objc deinit
  public static func == (lhs: DGis.ItemMarkerInfo, rhs: DGis.ItemMarkerInfo) -> Swift.Bool
  final public func hash(into hasher: inout Swift.Hasher)
  final public var hashValue: Swift.Int {
    get
  }
}
public struct Elevation : Swift.Hashable {
  public var value: Swift.Float
  public init(value: Swift.Float = 0)
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (a: DGis.Elevation, b: DGis.Elevation) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
}
public struct GeoPointWithElevation : Swift.Hashable {
  public var latitude: DGis.Latitude
  public var longitude: DGis.Longitude
  public var elevation: DGis.Elevation
  public init(latitude: DGis.Latitude, longitude: DGis.Longitude, elevation: DGis.Elevation = Elevation(value: 0))
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (a: DGis.GeoPointWithElevation, b: DGis.GeoPointWithElevation) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
}
public enum ObjectType : Swift.UInt32 {
  case admDiv
  case attraction
  case branch
  case building
  case coordinates
  case crossroad
  case parking
  case road
  case route
  case station
  case stationEntrance
  case street
  case unknown
  public init?(rawValue: Swift.UInt32)
  public typealias RawValue = Swift.UInt32
  public var rawValue: Swift.UInt32 {
    get
  }
}
public struct OpeningHours : Swift.Hashable {
  public var weekOpeningHours: [[DGis.WeekTimeInterval]]
  public var isOpen24x7: Swift.Bool
  public init(weekOpeningHours: [[DGis.WeekTimeInterval]], isOpen24x7: Swift.Bool)
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (a: DGis.OpeningHours, b: DGis.OpeningHours) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
}
public enum ParkingAccess : Swift.UInt32 {
  case `public`
  case handicappedOnly
  case customersOnly
  case residentsOnly
  case taxiOnly
  public init?(rawValue: Swift.UInt32)
  public typealias RawValue = Swift.UInt32
  public var rawValue: Swift.UInt32 {
    get
  }
}
public enum SpecialSpaceType : Swift.UInt32 {
  case bicycle
  case motorbike
  case family
  case handicapped
  case babyCarriage
  case truck
  case scooter
  public init?(rawValue: Swift.UInt32)
  public typealias RawValue = Swift.UInt32
  public var rawValue: Swift.UInt32 {
    get
  }
}
public struct SpecialSpace : Swift.Hashable {
  public var type: DGis.SpecialSpaceType
  public var name: Swift.String
  public var count: Swift.String?
  public init(type: DGis.SpecialSpaceType, name: Swift.String, count: Swift.String?)
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (a: DGis.SpecialSpace, b: DGis.SpecialSpace) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
}
public struct ParkingCapacity : Swift.Hashable {
  public var total: Swift.String?
  public var specialSpaces: [DGis.SpecialSpace]
  public init(total: Swift.String?, specialSpaces: [DGis.SpecialSpace])
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (a: DGis.ParkingCapacity, b: DGis.ParkingCapacity) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
}
public enum ParkingType : Swift.UInt32 {
  case ground
  case underground
  case multilevel
  public init?(rawValue: Swift.UInt32)
  public typealias RawValue = Swift.UInt32
  public var rawValue: Swift.UInt32 {
    get
  }
}
public enum ParkingPurpose : Swift.UInt32 {
  case car
  case bike
  case motorbike
  case babyCarriage
  case scooter
  public init?(rawValue: Swift.UInt32)
  public typealias RawValue = Swift.UInt32
  public var rawValue: Swift.UInt32 {
    get
  }
}
public enum ParkingPavingType : Swift.UInt32 {
  case asphalt
  case concrete
  case gravel
  case unpaved
  public init?(rawValue: Swift.UInt32)
  public typealias RawValue = Swift.UInt32
  public var rawValue: Swift.UInt32 {
    get
  }
}
public struct ParkingInfo : Swift.Hashable {
  public var type: DGis.ParkingType?
  public var purpose: DGis.ParkingPurpose
  public var access: DGis.ParkingAccess
  public var pavingType: DGis.ParkingPavingType?
  public var isPaid: Swift.Bool
  public var isIncentive: Swift.Bool
  public var forTrucks: Swift.Bool
  public var levelCount: Swift.UInt16?
  public var capacity: DGis.ParkingCapacity?
  public init(type: DGis.ParkingType?, purpose: DGis.ParkingPurpose, access: DGis.ParkingAccess, pavingType: DGis.ParkingPavingType?, isPaid: Swift.Bool, isIncentive: Swift.Bool, forTrucks: Swift.Bool, levelCount: Swift.UInt16?, capacity: DGis.ParkingCapacity?)
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (a: DGis.ParkingInfo, b: DGis.ParkingInfo) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
}
public struct Reviews : Swift.Hashable {
  public var rating: Swift.Float
  public var count: Swift.UInt32
  public init(rating: Swift.Float, count: Swift.UInt32)
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (a: DGis.Reviews, b: DGis.Reviews) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
}
public struct RubricId : Swift.Hashable {
  public var value: Swift.UInt64
  public init(value: Swift.UInt64 = 0)
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (a: DGis.RubricId, b: DGis.RubricId) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
}
public enum SearchResultType : Swift.UInt32 {
  case recovery
  case discovery
  public init?(rawValue: Swift.UInt32)
  public typealias RawValue = Swift.UInt32
  public var rawValue: Swift.UInt32 {
    get
  }
}
public enum SortingType : Swift.UInt32 {
  case byRelevance
  case byDistance
  case byRating
  public init?(rawValue: Swift.UInt32)
  public typealias RawValue = Swift.UInt32
  public var rawValue: Swift.UInt32 {
    get
  }
}
public struct TradeLicense : Swift.Hashable {
  public var type: Swift.String
  public var license: Swift.String
  public var legalForm: Swift.String
  public var endDate: Swift.String
  public init(type: Swift.String, license: Swift.String, legalForm: Swift.String, endDate: Swift.String)
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (a: DGis.TradeLicense, b: DGis.TradeLicense) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
}
public struct UIMarkerInfo : Swift.Hashable {
  public var objectId: DGis.DgisObjectId
  public var label: Swift.String?
  public init(objectId: DGis.DgisObjectId, label: Swift.String?)
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (a: DGis.UIMarkerInfo, b: DGis.UIMarkerInfo) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
}
public struct WorkStatus : Swift.Hashable {
  public var isOpen: Swift.Bool
  public var description: Swift.String
  public init(isOpen: Swift.Bool, description: Swift.String)
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (a: DGis.WorkStatus, b: DGis.WorkStatus) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
}
public struct AddressAdmDiv : Swift.Hashable {
  public var type: Swift.String
  public var name: Swift.String
  public init(type: Swift.String, name: Swift.String)
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (a: DGis.AddressAdmDiv, b: DGis.AddressAdmDiv) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
}
public struct AddressStreet : Swift.Hashable {
  public var street: Swift.String
  public var number: Swift.String
  public var fiasCode: Swift.String?
  public init(street: Swift.String, number: Swift.String, fiasCode: Swift.String?)
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (a: DGis.AddressStreet, b: DGis.AddressStreet) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
}
public struct AddressNumber : Swift.Hashable {
  public var number: Swift.String
  public var fiasCode: Swift.String?
  public init(number: Swift.String, fiasCode: Swift.String?)
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (a: DGis.AddressNumber, b: DGis.AddressNumber) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
}
public struct AddressLocation : Swift.Hashable {
  public var comment: Swift.String
  public init(comment: Swift.String)
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (a: DGis.AddressLocation, b: DGis.AddressLocation) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
}
public enum AddressComponent : Swift.Hashable {
  case streetAddress(DGis.AddressStreet)
  case number(DGis.AddressNumber)
  case location(DGis.AddressLocation)
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (a: DGis.AddressComponent, b: DGis.AddressComponent) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
}
public struct Address : Swift.Hashable {
  public var drillDown: [DGis.AddressAdmDiv]
  public var components: [DGis.AddressComponent]
  public var buildingName: Swift.String?
  public var postCode: Swift.String?
  public var buildingCode: Swift.String?
  public var fiasCode: Swift.String?
  public var addressComment: Swift.String?
  public init(drillDown: [DGis.AddressAdmDiv], components: [DGis.AddressComponent], buildingName: Swift.String?, postCode: Swift.String?, buildingCode: Swift.String?, fiasCode: Swift.String?, addressComment: Swift.String?)
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (a: DGis.Address, b: DGis.Address) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
}
@_hasMissingDesignatedInitializers final public class DirectoryObject : Swift.Hashable {
  final public var types: [DGis.ObjectType] {
    get
  }
  final public var title: Swift.String {
    get
  }
  final public var titleAddition: Swift.String {
    get
  }
  final public var subtitle: Swift.String {
    get
  }
  final public var description: Swift.String {
    get
  }
  final public var id: DGis.DgisObjectId? {
    get
  }
  final public var markerPosition: DGis.GeoPointWithElevation? {
    get
  }
  final public var address: DGis.Address? {
    get
  }
  final public var attributes: [DGis.Attribute] {
    get
  }
  final public var contextAttributes: [DGis.Attribute] {
    get
  }
  final public var timeZoneOffset: Foundation.TimeInterval? {
    get
  }
  final public var openingHours: DGis.OpeningHours? {
    get
  }
  final public var contactInfos: [DGis.ContactInfo] {
    get
  }
  final public var reviews: DGis.Reviews? {
    get
  }
  final public var parkingInfo: DGis.ParkingInfo? {
    get
  }
  final public var workStatus: DGis.WorkStatus? {
    get
  }
  final public var levelId: DGis.LevelId? {
    get
  }
  final public var buildingLevels: DGis.BuildingLevels? {
    get
  }
  final public var entrances: [DGis.EntranceInfo] {
    get
  }
  final public var tradeLicense: DGis.TradeLicense? {
    get
  }
  final public var buildingInfo: DGis.BuildingInfo {
    get
  }
  @objc deinit
  public static func == (lhs: DGis.DirectoryObject, rhs: DGis.DirectoryObject) -> Swift.Bool
  final public func hash(into hasher: inout Swift.Hasher)
  final public func formattedAddress(type: DGis.FormattingType) -> DGis.FormattedAddress?
  final public var hashValue: Swift.Int {
    get
  }
}
@_hasMissingDesignatedInitializers final public class Page : Swift.Hashable {
  final public var items: [DGis.DirectoryObject] {
    get
  }
  @objc deinit
  public static func == (lhs: DGis.Page, rhs: DGis.Page) -> Swift.Bool
  final public func hash(into hasher: inout Swift.Hasher)
  final public func fetchPrevPage() -> DGis.Future<DGis.Page?>
  final public func fetchNextPage() -> DGis.Future<DGis.Page?>
  final public var hashValue: Swift.Int {
    get
  }
}
public enum WidgetType : Swift.UInt32 {
  case cHECKBOX
  case cHECKABLE_ITEM_GROUP
  case rANGE
  public init?(rawValue: Swift.UInt32)
  public typealias RawValue = Swift.UInt32
  public var rawValue: Swift.UInt32 {
    get
  }
}
@_hasMissingDesignatedInitializers public class Widget : Swift.Hashable {
  public var type: DGis.WidgetType {
    get
  }
  public var caption: Swift.String? {
    get
  }
  public var filters: [DGis.DynamicFilter] {
    get
  }
  @objc deinit
  public static func == (lhs: DGis.Widget, rhs: DGis.Widget) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
@_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers final public class Checkbox : DGis.Widget {
  final public var filterType: DGis.FilterType {
    get
  }
  final public var checkedText: Swift.String? {
    get
  }
  final public var uncheckedText: Swift.String? {
    get
  }
  final public var values: [Swift.String] {
    get
  }
  final public var isChecked: Swift.Bool {
    get
    set(checked)
  }
  @objc deinit
}
public enum CheckableItemType : Swift.UInt32 {
  case sIMPLE
  case gROUP
  public init?(rawValue: Swift.UInt32)
  public typealias RawValue = Swift.UInt32
  public var rawValue: Swift.UInt32 {
    get
  }
}
@_hasMissingDesignatedInitializers public class CheckableItem : Swift.Hashable {
  public var type: DGis.CheckableItemType {
    get
  }
  public var filterType: DGis.FilterType {
    get
  }
  @objc deinit
  public static func == (lhs: DGis.CheckableItem, rhs: DGis.CheckableItem) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
@_hasMissingDesignatedInitializers final public class CheckableGroupedItem : Swift.Hashable {
  final public var text: Swift.String {
    get
  }
  final public var values: [Swift.String] {
    get
  }
  final public var isChecked: Swift.Bool {
    get
    set(checked)
  }
  @objc deinit
  public static func == (lhs: DGis.CheckableGroupedItem, rhs: DGis.CheckableGroupedItem) -> Swift.Bool
  final public func hash(into hasher: inout Swift.Hasher)
  final public var hashValue: Swift.Int {
    get
  }
}
@_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers final public class CheckableItemsGroup : DGis.Widget {
  final public var items: [DGis.CheckableItem] {
    get
  }
  @objc deinit
}
@_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers final public class SimpleCheckableItem : DGis.CheckableItem {
  final public var text: Swift.String {
    get
  }
  final public var values: [Swift.String] {
    get
  }
  final public var isChecked: Swift.Bool {
    get
    set(checked)
  }
  @objc deinit
}
@_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers final public class GroupCheckableItem : DGis.CheckableItem {
  final public var items: [DGis.CheckableGroupedItem] {
    get
  }
  @objc deinit
}
public struct Borders : Swift.Hashable {
  public var snapping: Swift.Double?
  public var isLg: Swift.Bool
  public var value: Swift.String
  public var min: Swift.Double
  public var max: Swift.Double
  public var currentMin: Swift.Double?
  public var currentMax: Swift.Double?
  public init(snapping: Swift.Double?, isLg: Swift.Bool, value: Swift.String, min: Swift.Double, max: Swift.Double, currentMin: Swift.Double? = nil, currentMax: Swift.Double? = nil)
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (a: DGis.Borders, b: DGis.Borders) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
}
public struct OrderedValue : Swift.Hashable {
  public var value: Swift.String
  public var text: Swift.String?
  public init(value: Swift.String, text: Swift.String?)
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (a: DGis.OrderedValue, b: DGis.OrderedValue) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
}
public struct OrderedValues : Swift.Hashable {
  public var values: [DGis.OrderedValue]
  public var currentMinIndex: Swift.UInt64?
  public var currentMaxIndex: Swift.UInt64?
  public init(values: [DGis.OrderedValue], currentMinIndex: Swift.UInt64? = nil, currentMaxIndex: Swift.UInt64? = nil)
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (a: DGis.OrderedValues, b: DGis.OrderedValues) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
}
public enum Range : Swift.Hashable {
  case borders(DGis.Borders)
  case orderedValues(DGis.OrderedValues)
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (a: DGis.Range, b: DGis.Range) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
}
@_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers final public class RangeWidget : DGis.Widget {
  final public var range: DGis.Range {
    get
  }
  final public func setValues(min: Swift.Double, max: Swift.Double)
  @objc deinit
}
@_hasMissingDesignatedInitializers final public class SearchResult : Swift.Hashable {
  final public var firstPage: DGis.Page? {
    get
  }
  final public var representativeArea: DGis.Geometry? {
    get
  }
  final public var itemMarkerInfos: DGis.Future<[DGis.ItemMarkerInfo]?> {
    get
  }
  final public var searchResultType: DGis.SearchResultType {
    get
  }
  final public var dynamicFilters: [DGis.DynamicFilter] {
    get
  }
  final public var actionWidgets: [DGis.Widget] {
    get
  }
  final public var mainWidgets: [DGis.Widget] {
    get
  }
  final public var autoUseFirstResult: Swift.Bool {
    get
  }
  @objc deinit
  public static func == (lhs: DGis.SearchResult, rhs: DGis.SearchResult) -> Swift.Bool
  final public func hash(into hasher: inout Swift.Hasher)
  final public func markerTitles(objectIds: [DGis.DgisObjectId]) -> [DGis.Future<[DGis.UIMarkerInfo]>]
  final public var hashValue: Swift.Int {
    get
  }
}
public enum GeometryKind : Swift.UInt32 {
  case point
  case polyline
  case polygon
  case complex
  public init?(rawValue: Swift.UInt32)
  public typealias RawValue = Swift.UInt32
  public var rawValue: Swift.UInt32 {
    get
  }
}
@_hasMissingDesignatedInitializers public class Geometry : Swift.Hashable {
  public var kind: DGis.GeometryKind {
    get
  }
  public var bounds: DGis.GeoRect {
    get
  }
  public var minPoint: DGis.GeoPoint {
    get
  }
  public var maxPoint: DGis.GeoPoint {
    get
  }
  @objc deinit
  public static func == (lhs: DGis.Geometry, rhs: DGis.Geometry) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public func intersects(geometry: DGis.Geometry) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
}
@_hasMissingDesignatedInitializers final public class SearchQuery : Swift.Hashable {
  @objc deinit
  public static func == (lhs: DGis.SearchQuery, rhs: DGis.SearchQuery) -> Swift.Bool
  final public func hash(into hasher: inout Swift.Hasher)
  final public var hashValue: Swift.Int {
    get
  }
}
@_hasMissingDesignatedInitializers final public class SuggestObjectHandler : Swift.Hashable {
  final public var item: DGis.DirectoryObject {
    get
  }
  @objc deinit
  public static func == (lhs: DGis.SuggestObjectHandler, rhs: DGis.SuggestObjectHandler) -> Swift.Bool
  final public func hash(into hasher: inout Swift.Hasher)
  final public var hashValue: Swift.Int {
    get
  }
}
@_hasMissingDesignatedInitializers final public class PerformSearchHandler : Swift.Hashable {
  final public var searchQuery: DGis.SearchQuery {
    get
  }
  @objc deinit
  public static func == (lhs: DGis.PerformSearchHandler, rhs: DGis.PerformSearchHandler) -> Swift.Bool
  final public func hash(into hasher: inout Swift.Hasher)
  final public var hashValue: Swift.Int {
    get
  }
}
@_hasMissingDesignatedInitializers final public class IncompleteTextHandler : Swift.Hashable {
  final public var queryText: Swift.String {
    get
  }
  @objc deinit
  public static func == (lhs: DGis.IncompleteTextHandler, rhs: DGis.IncompleteTextHandler) -> Swift.Bool
  final public func hash(into hasher: inout Swift.Hasher)
  final public var hashValue: Swift.Int {
    get
  }
}
public enum SuggestHandler : Swift.Hashable {
  case objectHandler(DGis.SuggestObjectHandler?)
  case performSearchHandler(DGis.PerformSearchHandler?)
  case incompleteTextHandler(DGis.IncompleteTextHandler?)
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (a: DGis.SuggestHandler, b: DGis.SuggestHandler) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
}
public struct MarkedUpTextSpan : Swift.Hashable {
  public var offset: Swift.UInt64
  public var length: Swift.UInt64
  public init(offset: Swift.UInt64, length: Swift.UInt64)
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (a: DGis.MarkedUpTextSpan, b: DGis.MarkedUpTextSpan) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
}
public struct MarkedUpText : Swift.Hashable {
  public var text: Swift.String
  public var matchedParts: [DGis.MarkedUpTextSpan]
  public init(text: Swift.String, matchedParts: [DGis.MarkedUpTextSpan])
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (a: DGis.MarkedUpText, b: DGis.MarkedUpText) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
}
public enum SuggestedType : Swift.UInt32 {
  case admDiv
  case attraction
  case attribute
  case branch
  case building
  case coordinates
  case crossroad
  case districtArea
  case org
  case orgCategory
  case parking
  case region
  case road
  case route
  case station
  case stationEntrance
  case street
  case text
  case unknown
  public init?(rawValue: Swift.UInt32)
  public typealias RawValue = Swift.UInt32
  public var rawValue: Swift.UInt32 {
    get
  }
}
public enum SuggestorType : Swift.UInt32 {
  case general
  case routeEndpoint
  public init?(rawValue: Swift.UInt32)
  public typealias RawValue = Swift.UInt32
  public var rawValue: Swift.UInt32 {
    get
  }
}
@_hasMissingDesignatedInitializers final public class Suggest : Swift.Hashable {
  final public var handler: DGis.SuggestHandler {
    get
  }
  final public var suggestedType: DGis.SuggestedType {
    get
  }
  final public var title: DGis.MarkedUpText {
    get
  }
  final public var subtitle: DGis.MarkedUpText {
    get
  }
  @objc deinit
  public static func == (lhs: DGis.Suggest, rhs: DGis.Suggest) -> Swift.Bool
  final public func hash(into hasher: inout Swift.Hasher)
  final public var hashValue: Swift.Int {
    get
  }
}
@_hasMissingDesignatedInitializers final public class SuggestResult : Swift.Hashable {
  final public var suggests: [DGis.Suggest] {
    get
  }
  @objc deinit
  public static func == (lhs: DGis.SuggestResult, rhs: DGis.SuggestResult) -> Swift.Bool
  final public func hash(into hasher: inout Swift.Hasher)
  final public var hashValue: Swift.Int {
    get
  }
}
@_hasMissingDesignatedInitializers final public class SuggestQuery : Swift.Hashable {
  @objc deinit
  public static func == (lhs: DGis.SuggestQuery, rhs: DGis.SuggestQuery) -> Swift.Bool
  final public func hash(into hasher: inout Swift.Hasher)
  final public var hashValue: Swift.Int {
    get
  }
}
@_hasMissingDesignatedInitializers final public class SearchManager : Swift.Hashable {
  @objc deinit
  public static func == (lhs: DGis.SearchManager, rhs: DGis.SearchManager) -> Swift.Bool
  final public func hash(into hasher: inout Swift.Hasher)
  public static func createOnlineManager(context: DGis.Context) throws -> DGis.SearchManager
  public static func createOfflineManager(context: DGis.Context) throws -> DGis.SearchManager
  public static func createSmartManager(context: DGis.Context) throws -> DGis.SearchManager
  final public func suggest(query: DGis.SuggestQuery) -> DGis.Future<DGis.SuggestResult>
  final public func search(query: DGis.SearchQuery) -> DGis.Future<DGis.SearchResult>
  final public func searchById(id: Swift.String) -> DGis.Future<DGis.DirectoryObject?>
  final public func searchByDirectoryObjectId(objectId: DGis.DgisObjectId) -> DGis.Future<DGis.DirectoryObject?>
  final public var hashValue: Swift.Int {
    get
  }
}
@_hasMissingDesignatedInitializers final public class SearchQueryBuilder : Swift.Hashable {
  @objc deinit
  public static func == (lhs: DGis.SearchQueryBuilder, rhs: DGis.SearchQueryBuilder) -> Swift.Bool
  final public func hash(into hasher: inout Swift.Hasher)
  public static func fromQueryText(queryText: Swift.String) -> DGis.SearchQueryBuilder
  public static func fromRubricIds(rubricIds: [DGis.RubricId]) -> DGis.SearchQueryBuilder
  public static func fromQueryTextAndRubricIds(queryText: Swift.String, rubricIds: [DGis.RubricId]) -> DGis.SearchQueryBuilder
  public static func fromQuery(query: DGis.SearchQuery) -> DGis.SearchQueryBuilder
  final public func setSpatialRestriction(spatialRestriction: [DGis.GeoPoint]?) -> DGis.SearchQueryBuilder
  final public func setAreaOfInterest(rect: DGis.GeoRect?) -> DGis.SearchQueryBuilder
  final public func setAllowedResultTypes(allowedResultTypes: [DGis.ObjectType]) -> DGis.SearchQueryBuilder
  final public func setPageSize(pageSize: Swift.Int32) -> DGis.SearchQueryBuilder
  final public func setDirectoryFilter(filter: DGis.DirectoryFilter) -> DGis.SearchQueryBuilder
  final public func setSortingType(sortingType: DGis.SortingType) -> DGis.SearchQueryBuilder
  final public func build() -> DGis.SearchQuery
  final public var hashValue: Swift.Int {
    get
  }
}
@_hasMissingDesignatedInitializers final public class SuggestQueryBuilder : Swift.Hashable {
  @objc deinit
  public static func == (lhs: DGis.SuggestQueryBuilder, rhs: DGis.SuggestQueryBuilder) -> Swift.Bool
  final public func hash(into hasher: inout Swift.Hasher)
  public static func fromQueryText(queryText: Swift.String) -> DGis.SuggestQueryBuilder
  public static func fromQuery(query: DGis.SuggestQuery) -> DGis.SuggestQueryBuilder
  final public func setSpatialRestriction(spatialRestriction: [DGis.GeoPoint]?) -> DGis.SuggestQueryBuilder
  final public func setAreaOfInterest(rect: DGis.GeoRect?) -> DGis.SuggestQueryBuilder
  final public func setAllowedResultTypes(allowedResultTypes: [DGis.SuggestedType]) -> DGis.SuggestQueryBuilder
  final public func setSuggestorType(suggestorType: DGis.SuggestorType) -> DGis.SuggestQueryBuilder
  final public func setLimit(limit: Swift.Int32) -> DGis.SuggestQueryBuilder
  final public func build() -> DGis.SuggestQuery
  final public var hashValue: Swift.Int {
    get
  }
}
@_hasMissingDesignatedInitializers final public class PackedSearchQuery : Swift.Hashable {
  final public var queryText: Swift.String {
    get
  }
  final public var spatialRestriction: [DGis.GeoPoint]? {
    get
  }
  final public var areaOfInterest: DGis.GeoRect? {
    get
  }
  final public var allowedResultTypes: [DGis.ObjectType] {
    get
  }
  final public var pageSize: Swift.Int32 {
    get
  }
  final public var directoryFilter: DGis.DirectoryFilter {
    get
  }
  final public var sortingType: DGis.SortingType {
    get
  }
  @objc deinit
  public static func == (lhs: DGis.PackedSearchQuery, rhs: DGis.PackedSearchQuery) -> Swift.Bool
  final public func hash(into hasher: inout Swift.Hasher)
  public static func fromBytes(data: Foundation.Data) throws -> DGis.PackedSearchQuery
  public static func fromSearchQuery(searchQuery: DGis.SearchQuery) -> DGis.PackedSearchQuery
  final public func toBytes() -> Foundation.Data
  final public func toSearchQuery() -> DGis.SearchQuery
  final public var hashValue: Swift.Int {
    get
  }
}
public enum PointGeometryData : Swift.Hashable {
  case geoPoint(DGis.GeoPoint)
  case geoPointWithElevation(DGis.GeoPointWithElevation)
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (a: DGis.PointGeometryData, b: DGis.PointGeometryData) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
}
@_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers final public class PointGeometry : DGis.Geometry {
  final public var point: DGis.PointGeometryData {
    get
  }
  convenience public init(point: DGis.GeoPoint)
  convenience public init(point: DGis.GeoPointWithElevation)
  @objc deinit
}
@_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers final public class PolygonGeometry : DGis.Geometry {
  final public var contours: [[DGis.GeoPoint]] {
    get
  }
  convenience public init(contours: [[DGis.GeoPoint]])
  @objc deinit
}
@_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers final public class PolylineGeometry : DGis.Geometry {
  final public var points: [DGis.GeoPoint] {
    get
  }
  convenience public init(points: [DGis.GeoPoint])
  @objc deinit
}
@_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers final public class ComplexGeometry : DGis.Geometry {
  final public var elements: [DGis.Geometry] {
    get
  }
  convenience public init(geometries: [DGis.Geometry])
  @objc deinit
}
public enum LogLevel : Swift.UInt32 {
  case verbose
  case info
  case warning
  case error
  case fault
  case disabled
  public init?(rawValue: Swift.UInt32)
  public typealias RawValue = Swift.UInt32
  public var rawValue: Swift.UInt32 {
    get
  }
}
public struct LogMessage : Swift.Hashable {
  public var level: DGis.LogLevel
  public var text: Swift.String
  public var file: Swift.String
  public var line: Swift.UInt32
  public init(level: DGis.LogLevel, text: Swift.String, file: Swift.String, line: Swift.UInt32)
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (a: DGis.LogMessage, b: DGis.LogMessage) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
}
public protocol LogSink {
  func write(message: DGis.LogMessage)
}
public struct LogOptions {
  public var osLogLevel: DGis.LogLevel
  public var customLogLevel: DGis.LogLevel
  public var customSink: DGis.LogSink?
  public init(osLogLevel: DGis.LogLevel, customLogLevel: DGis.LogLevel, customSink: DGis.LogSink?)
}
public struct Anchor : Swift.Hashable {
  public var x: Swift.Float
  public var y: Swift.Float
  public init(x: Swift.Float = 0.5, y: Swift.Float = 0.5)
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (a: DGis.Anchor, b: DGis.Anchor) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
}
public enum AttributeValue : Swift.Hashable {
  case empty
  case boolean(Swift.Bool)
  case number(Swift.Double)
  case integer(Swift.Int64)
  case string(Swift.String)
  case data(Foundation.Data)
  case array([DGis.AttributeValue])
  case object([Swift.String : DGis.AttributeValue])
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (a: DGis.AttributeValue, b: DGis.AttributeValue) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
}
public enum BearingSource : Swift.UInt32 {
  case auto
  case satellite
  case magnetic
  public init?(rawValue: Swift.UInt32)
  public typealias RawValue = Swift.UInt32
  public var rawValue: Swift.UInt32 {
    get
  }
}
public enum CameraAnimatedMoveReason : Swift.UInt32 {
  case application
  case event
  case `internal`
  public init?(rawValue: Swift.UInt32)
  public typealias RawValue = Swift.UInt32
  public var rawValue: Swift.UInt32 {
    get
  }
}
public enum CameraAnimatedMoveResult : Swift.UInt32 {
  case finished
  case cancelledByEvent
  case cancelledByApplication
  public init?(rawValue: Swift.UInt32)
  public typealias RawValue = Swift.UInt32
  public var rawValue: Swift.UInt32 {
    get
  }
}
public enum CameraAnimationType : Swift.UInt32 {
  case `default`
  case linear
  case showBothPositions
  public init?(rawValue: Swift.UInt32)
  public typealias RawValue = Swift.UInt32
  public var rawValue: Swift.UInt32 {
    get
  }
}
public enum CameraBehaviourChangeReason : Swift.UInt32 {
  case application
  case event
  public init?(rawValue: Swift.UInt32)
  public typealias RawValue = Swift.UInt32
  public var rawValue: Swift.UInt32 {
    get
  }
}
public struct CameraPositionPoint : Swift.Hashable {
  public var x: Swift.Float
  public var y: Swift.Float
  public init(x: Swift.Float = 0.5, y: Swift.Float = 0.5)
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (a: DGis.CameraPositionPoint, b: DGis.CameraPositionPoint) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
}
public enum CameraState : Swift.UInt32 {
  case busy
  case fly
  case followPosition
  case free
  public init?(rawValue: Swift.UInt32)
  public typealias RawValue = Swift.UInt32
  public var rawValue: Swift.UInt32 {
    get
  }
}
public struct Color : Swift.Hashable {
  public var argb: Swift.UInt32
  public init(argb: Swift.UInt32 = 4278190080)
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (a: DGis.Color, b: DGis.Color) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
}
public struct DeviceDensity : Swift.Hashable {
  public var value: Swift.Float
  public init(value: Swift.Float = 0)
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (a: DGis.DeviceDensity, b: DGis.DeviceDensity) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
}
public struct DevicePpi : Swift.Hashable {
  public var value: Swift.Float
  public init(value: Swift.Float = 0)
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (a: DGis.DevicePpi, b: DGis.DevicePpi) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
}
public struct ZIndex : Swift.Hashable {
  public var value: Swift.UInt32
  public init(value: Swift.UInt32 = 0)
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (a: DGis.ZIndex, b: DGis.ZIndex) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
}
public struct Zoom : Swift.Hashable {
  public var value: Swift.Float
  public init(value: Swift.Float = 0)
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (a: DGis.Zoom, b: DGis.Zoom) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
}
public struct Tilt : Swift.Hashable {
  public var value: Swift.Float
  public init(value: Swift.Float = 0)
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (a: DGis.Tilt, b: DGis.Tilt) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
}
public struct CameraPosition : Swift.Hashable {
  public var point: DGis.GeoPoint
  public var zoom: DGis.Zoom
  public var tilt: DGis.Tilt
  public var bearing: DGis.Bearing
  public init(point: DGis.GeoPoint, zoom: DGis.Zoom, tilt: DGis.Tilt = Tilt(value: 0), bearing: DGis.Bearing = Bearing(value: 0))
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (a: DGis.CameraPosition, b: DGis.CameraPosition) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
}
public protocol CameraMoveController {
  func position(time: Foundation.TimeInterval) -> DGis.CameraPosition
  func animationTime() -> Foundation.TimeInterval
}
@_hasMissingDesignatedInitializers final public class NewValuesNotifier : Swift.Hashable {
  @objc deinit
  public static func == (lhs: DGis.NewValuesNotifier, rhs: DGis.NewValuesNotifier) -> Swift.Bool
  final public func hash(into hasher: inout Swift.Hasher)
  final public func sendNotification()
  final public var hashValue: Swift.Int {
    get
  }
}
public enum FollowValue : Swift.UInt32 {
  case coordinates
  case bearing
  case tilt
  case styleZoom
  public init?(rawValue: Swift.UInt32)
  public typealias RawValue = Swift.UInt32
  public var rawValue: Swift.UInt32 {
    get
  }
}
public struct StyleZoom : Swift.Hashable {
  public var value: Swift.Float
  public init(value: Swift.Float = 0)
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (a: DGis.StyleZoom, b: DGis.StyleZoom) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
}
public struct FollowValueOptionSet : Swift.OptionSet, Swift.Hashable {
  public var rawValue: Swift.UInt32
  public static let coordinates: DGis.FollowValueOptionSet
  public static let bearing: DGis.FollowValueOptionSet
  public static let tilt: DGis.FollowValueOptionSet
  public static let styleZoom: DGis.FollowValueOptionSet
  public init(rawValue: Swift.UInt32)
  public typealias ArrayLiteralElement = DGis.FollowValueOptionSet
  public typealias Element = DGis.FollowValueOptionSet
  public typealias RawValue = Swift.UInt32
}
public protocol CustomFollowController {
  func availableValues() -> DGis.FollowValueOptionSet
  func requestValues(values: DGis.FollowValueOptionSet)
  func setNewValuesNotifier(notifier: DGis.NewValuesNotifier?)
  func coordinates() -> DGis.GeoPoint?
  func bearing() -> DGis.Bearing?
  func tilt() -> DGis.Tilt?
  func styleZoom() -> DGis.StyleZoom?
}
@_hasMissingDesignatedInitializers public class Event : Swift.Hashable {
  @objc deinit
  public static func == (lhs: DGis.Event, rhs: DGis.Event) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
@_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers public class InputEvent : DGis.Event {
  public var timestamp: Foundation.TimeInterval {
    get
  }
  @objc deinit
}
@_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers final public class CancelEvent : DGis.Event {
  convenience public init()
  @objc deinit
}
public enum DgisSourceWorkingMode : Swift.UInt32 {
  case online
  case offline
  case hybridOnlineFirst
  case hybridOfflineFirst
  public init?(rawValue: Swift.UInt32)
  public typealias RawValue = Swift.UInt32
  public var rawValue: Swift.UInt32 {
    get
  }
}
@_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers final public class DirectMapControlBeginEvent : DGis.Event {
  convenience public init()
  @objc deinit
}
@_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers final public class DirectMapControlEndEvent : DGis.InputEvent {
  convenience public init(timestamp: Foundation.TimeInterval)
  @objc deinit
}
public struct ScreenPoint : Swift.Hashable {
  public var x: Swift.Float
  public var y: Swift.Float
  public init(x: Swift.Float = 0, y: Swift.Float = 0)
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (a: DGis.ScreenPoint, b: DGis.ScreenPoint) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
}
@_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers final public class DirectMapRotationEvent : DGis.InputEvent {
  final public var bearingDelta: DGis.Bearing {
    get
  }
  final public var rotationCenter: DGis.ScreenPoint? {
    get
  }
  convenience public init(bearingDelta: DGis.Bearing, timestamp: Foundation.TimeInterval, rotationCenter: DGis.ScreenPoint? = nil)
  @objc deinit
}
@_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers final public class DirectMapScalingEvent : DGis.InputEvent {
  final public var zoomDelta: Swift.Float {
    get
  }
  final public var scalingCenter: DGis.ScreenPoint? {
    get
  }
  convenience public init(zoomDelta: Swift.Float, timestamp: Foundation.TimeInterval, scalingCenter: DGis.ScreenPoint? = nil)
  @objc deinit
}
public struct ScreenShift : Swift.Hashable {
  public var dx: Swift.Float
  public var dy: Swift.Float
  public init(dx: Swift.Float = 0, dy: Swift.Float = 0)
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (a: DGis.ScreenShift, b: DGis.ScreenShift) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
}
@_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers final public class DirectMapShiftEvent : DGis.InputEvent {
  final public var screenShift: DGis.ScreenShift {
    get
  }
  final public var shiftedPoint: DGis.ScreenPoint {
    get
  }
  convenience public init(screenShift: DGis.ScreenShift, shiftedPoint: DGis.ScreenPoint, timestamp: Foundation.TimeInterval)
  @objc deinit
}
@_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers final public class DirectMapTiltEvent : DGis.InputEvent {
  final public var delta: Swift.Float {
    get
  }
  convenience public init(delta: Swift.Float, timestamp: Foundation.TimeInterval)
  @objc deinit
}
public enum MapRotationDirection : Swift.UInt32 {
  case clockwise
  case counterclockwise
  public init?(rawValue: Swift.UInt32)
  public typealias RawValue = Swift.UInt32
  public var rawValue: Swift.UInt32 {
    get
  }
}
@_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers final public class MapRotationBeginEvent : DGis.Event {
  final public var direction: DGis.MapRotationDirection {
    get
  }
  convenience public init(inDirection: DGis.MapRotationDirection)
  @objc deinit
}
@_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers final public class MapRotationEndEvent : DGis.Event {
  convenience public init()
  @objc deinit
}
public enum MapScalingDirection : Swift.UInt32 {
  case zoomIn
  case zoomOut
  public init?(rawValue: Swift.UInt32)
  public typealias RawValue = Swift.UInt32
  public var rawValue: Swift.UInt32 {
    get
  }
}
@_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers final public class MapScalingBeginEvent : DGis.Event {
  final public var direction: DGis.MapScalingDirection {
    get
  }
  convenience public init(inDirection: DGis.MapScalingDirection)
  @objc deinit
}
@_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers final public class MapScalingEndEvent : DGis.Event {
  convenience public init()
  @objc deinit
}
public enum MapShiftDirection : Swift.UInt32 {
  case left
  case right
  case up
  case down
  case leftUp
  case leftDown
  case rightUp
  case rightDown
  public init?(rawValue: Swift.UInt32)
  public typealias RawValue = Swift.UInt32
  public var rawValue: Swift.UInt32 {
    get
  }
}
@_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers final public class MapShiftBeginEvent : DGis.Event {
  final public var direction: DGis.MapShiftDirection {
    get
  }
  convenience public init(inDirection: DGis.MapShiftDirection)
  @objc deinit
}
@_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers final public class MapShiftEndEvent : DGis.Event {
  convenience public init()
  @objc deinit
}
@_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers final public class RotateMapToNorthEvent : DGis.Event {
  convenience public init()
  @objc deinit
}
@_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers final public class ScaleMapEvent : DGis.Event {
  final public var zoomDelta: Swift.Float {
    get
  }
  final public var scalingCenter: DGis.ScreenPoint? {
    get
  }
  convenience public init(zoomDelta: Swift.Float, scalingCenter: DGis.ScreenPoint? = nil)
  @objc deinit
}
public struct ClusterOptions {
  public var attributes: [Swift.String : DGis.AttributeValue]
  public var userData: Any
  public init(attributes: [Swift.String : DGis.AttributeValue], userData: Any = ())
}
public enum FollowBearing : Swift.UInt32 {
  case off
  case on
  public init?(rawValue: Swift.UInt32)
  public typealias RawValue = Swift.UInt32
  public var rawValue: Swift.UInt32 {
    get
  }
}
public enum FollowStyleZoom : Swift.UInt32 {
  case off
  case on
  public init?(rawValue: Swift.UInt32)
  public typealias RawValue = Swift.UInt32
  public var rawValue: Swift.UInt32 {
    get
  }
}
public struct FollowPosition : Swift.Hashable {
  public var bearing: DGis.FollowBearing
  public var styleZoom: DGis.FollowStyleZoom
  public init(bearing: DGis.FollowBearing = FollowBearing.off, styleZoom: DGis.FollowStyleZoom = FollowStyleZoom.off)
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (a: DGis.FollowPosition, b: DGis.FollowPosition) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
}
public enum FollowTilt : Swift.UInt32 {
  case off
  case on
  public init?(rawValue: Swift.UInt32)
  public typealias RawValue = Swift.UInt32
  public var rawValue: Swift.UInt32 {
    get
  }
}
@_hasMissingDesignatedInitializers final public class Attributes : Swift.Hashable {
  final public var attributeNames: [Swift.String] {
    get
  }
  final public var changed: DGis.Channel<[Swift.String]> {
    get
  }
  @objc deinit
  public static func == (lhs: DGis.Attributes, rhs: DGis.Attributes) -> Swift.Bool
  final public func hash(into hasher: inout Swift.Hasher)
  final public func setAttributeValue(name: Swift.String, value: DGis.AttributeValue)
  final public func setAttributeValues(values: [Swift.String : DGis.AttributeValue], attributesToRemove: [Swift.String] = [])
  final public func removeAttribute(name: Swift.String)
  final public func getAttributeValue(name: Swift.String) -> DGis.AttributeValue
  final public var hashValue: Swift.Int {
    get
  }
}
@_hasMissingDesignatedInitializers public class MapObject : Swift.Hashable {
  public var userData: Any {
    get
    set(userData)
  }
  @objc deinit
  public static func == (lhs: DGis.MapObject, rhs: DGis.MapObject) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
@_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers final public class GeometryMapObject : DGis.MapObject {
  final public var geometryChannel: DGis.StatefulChannel<DGis.Geometry> {
    get
  }
  final public var geometry: DGis.Geometry {
    get
    set(geometry)
  }
  final public var objectAttributes: DGis.Attributes {
    get
  }
  final public var isVisibleChannel: DGis.StatefulChannel<Swift.Bool> {
    get
  }
  final public var isVisible: Swift.Bool {
    get
    set(visible)
  }
  final public var isDraggableChannel: DGis.StatefulChannel<Swift.Bool> {
    get
  }
  final public var isDraggable: Swift.Bool {
    get
    set(draggable)
  }
  final public var bounds: DGis.GeoRect {
    get
  }
  @objc deinit
}
@_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers final public class ClusterObject : DGis.MapObject {
  final public var position: DGis.GeoPointWithElevation {
    get
  }
  final public var objectCount: Swift.UInt32 {
    get
  }
  final public var objects: [DGis.GeometryMapObject] {
    get
  }
  final public var geometryObject: DGis.GeometryMapObject? {
    get
  }
  @objc deinit
}
@_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers final public class DgisMapObject : DGis.MapObject {
  final public var id: DGis.DgisObjectId {
    get
  }
  @objc deinit
}
@_hasMissingDesignatedInitializers public class Source : Swift.Hashable {
  @objc deinit
  public static func == (lhs: DGis.Source, rhs: DGis.Source) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
@_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers final public class DgisSource : DGis.Source {
  final public var highlightedObjectsChannel: DGis.StatefulChannel<[DGis.DgisObjectId]> {
    get
  }
  final public var highlightedObjects: [DGis.DgisObjectId] {
    get
  }
  public static func createDgisSource(context: DGis.Context, workingMode: DGis.DgisSourceWorkingMode = DgisSourceWorkingMode.online) -> DGis.Source
  final public func setHighlighted(directoryObjectIds: [DGis.DgisObjectId], highlighted: Swift.Bool)
  @objc deinit
}
@_hasMissingDesignatedInitializers public class FollowController : Swift.Hashable {
  @objc deinit
  public static func == (lhs: DGis.FollowController, rhs: DGis.FollowController) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
@_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers final public class GeometryMapObjectSource : DGis.Source {
  final public var objects: [DGis.GeometryMapObject] {
    get
  }
  final public var sourceAttributes: DGis.Attributes {
    get
  }
  final public func clusteringObjects(position: DGis.CameraPosition) -> [DGis.MapObject]
  final public func addObject(item: DGis.GeometryMapObject)
  final public func addObjects(objects: [DGis.GeometryMapObject])
  final public func removeObject(item: DGis.GeometryMapObject)
  final public func removeObjects(objects: [DGis.GeometryMapObject])
  final public func removeAndAddObjects(objectsToRemove: [DGis.GeometryMapObject], objectsToAdd: [DGis.GeometryMapObject])
  final public func clear()
  @objc deinit
}
@_hasMissingDesignatedInitializers final public class Image : Swift.Hashable {
  @objc deinit
  public static func == (lhs: DGis.Image, rhs: DGis.Image) -> Swift.Bool
  final public func hash(into hasher: inout Swift.Hasher)
  final public var hashValue: Swift.Int {
    get
  }
}
public enum ImageFormat : Swift.UInt32 {
  case pNG
  case sVG
  case rGBA_8888
  case lOTTIE_JSON
  public init?(rawValue: Swift.UInt32)
  public typealias RawValue = Swift.UInt32
  public var rawValue: Swift.UInt32 {
    get
  }
}
public struct ImageData : Swift.Hashable {
  public var size: DGis.ScreenSize
  public var format: DGis.ImageFormat
  public var data: Foundation.Data
  public init(size: DGis.ScreenSize, format: DGis.ImageFormat, data: Foundation.Data)
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (a: DGis.ImageData, b: DGis.ImageData) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
}
@_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers final public class BearingFollowController : DGis.FollowController {
  convenience public init(bearingSource: DGis.BearingSource, animationDuration: Foundation.TimeInterval = 1, valueThreshold: DGis.Bearing = Bearing(value: 1))
  @objc deinit
}
@_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers final public class CoordinatesFollowController : DGis.FollowController {
  convenience public init(animationDuration: Foundation.TimeInterval = 1, valueThreshold: DGis.Meter = Meter(value: 0.10000000149011612))
  @objc deinit
}
public struct Meter : Swift.Hashable {
  public var value: Swift.Float
  public init(value: Swift.Float = 0)
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (a: DGis.Meter, b: DGis.Meter) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
}
@_hasMissingDesignatedInitializers final public class MyLocationController : Swift.Hashable {
  @objc deinit
  public static func == (lhs: DGis.MyLocationController, rhs: DGis.MyLocationController) -> Swift.Bool
  final public func hash(into hasher: inout Swift.Hasher)
  convenience public init(bearingSource: DGis.BearingSource?, animationDuration: Foundation.TimeInterval = 1, coordinatesThreshold: DGis.Meter = Meter(value: 0.10000000149011612), bearingThreshold: DGis.Bearing = Bearing(value: 1))
  final public var hashValue: Swift.Int {
    get
  }
}
@_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers final public class MyLocationMapObject : DGis.MapObject {
  @objc deinit
}
public enum MyLocationMapObjectMarkerType : Swift.UInt32 {
  case mODEL
  case sVG_ICON
  public init?(rawValue: Swift.UInt32)
  public typealias RawValue = Swift.UInt32
  public var rawValue: Swift.UInt32 {
    get
  }
}
@_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers final public class MyLocationMapObjectSource : DGis.Source {
  final public var item: DGis.MyLocationMapObject {
    get
  }
  convenience public init(context: DGis.Context, controller: DGis.MyLocationController, markerType: DGis.MyLocationMapObjectMarkerType = MyLocationMapObjectMarkerType.mODEL)
  final public func setController(controller: DGis.MyLocationController)
  @objc deinit
}
@_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers final public class RoadEventMapObject : DGis.MapObject {
  final public var id: DGis.DgisObjectId {
    get
  }
  final public var event: DGis.RoadEvent {
    get
  }
  @objc deinit
}
public enum RoadEventType : Swift.UInt32 {
  case accident
  case roadWorks
  case camera
  case comment
  case roadRestriction
  case other
  public init?(rawValue: Swift.UInt32)
  public typealias RawValue = Swift.UInt32
  public var rawValue: Swift.UInt32 {
    get
  }
}
@_hasMissingDesignatedInitializers final public class RoadEvent : Swift.Hashable {
  final public var type: DGis.RoadEventType {
    get
  }
  final public var name: Swift.String {
    get
  }
  final public var author: DGis.AuthorInfo {
    get
  }
  final public var timestamp: Foundation.Date? {
    get
  }
  final public var location: DGis.GeoPoint {
    get
  }
  final public var description: Swift.String {
    get
  }
  final public var cameraInfo: DGis.RoadCameraInfo? {
    get
  }
  final public var schedule: DGis.Schedule? {
    get
  }
  final public var lanes: DGis.LaneOptionSet {
    get
  }
  final public var availableActions: [DGis.RoadEventAction] {
    get
  }
  final public var remover: DGis.Remover? {
    get
  }
  @objc deinit
  public static func == (lhs: DGis.RoadEvent, rhs: DGis.RoadEvent) -> Swift.Bool
  final public func hash(into hasher: inout Swift.Hasher)
  final public func photos() -> DGis.Future<[DGis.RoadEventPhoto]>
  final public var hashValue: Swift.Int {
    get
  }
}
public enum AuthorType : Swift.UInt32 {
  case anonymous
  case doubleGis
  case user
  case me
  public init?(rawValue: Swift.UInt32)
  public typealias RawValue = Swift.UInt32
  public var rawValue: Swift.UInt32 {
    get
  }
}
public struct AuthorInfo : Swift.Hashable {
  public var type: DGis.AuthorType
  public var name: Swift.String
  public init(type: DGis.AuthorType, name: Swift.String)
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (a: DGis.AuthorInfo, b: DGis.AuthorInfo) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
}
public enum CameraPurpose : Swift.UInt32 {
  case speedControl
  case averageSpeedControl
  case publicTransportLaneMovementControl
  case roadMarkingsCrossingControl
  case trafficLightsViolationControl
  case stopLineCrossingControl
  case oncomingTrafficLaneMovementControl
  case pedestrianAdvantageViolationControl
  case laneDisciplineControl
  case noStoppingViolationControl
  case dummy
  case truck
  public init?(rawValue: Swift.UInt32)
  public typealias RawValue = Swift.UInt32
  public var rawValue: Swift.UInt32 {
    get
  }
}
public struct CameraPurposeOptionSet : Swift.OptionSet, Swift.Hashable {
  public var rawValue: Swift.UInt32
  public static let speedControl: DGis.CameraPurposeOptionSet
  public static let averageSpeedControl: DGis.CameraPurposeOptionSet
  public static let publicTransportLaneMovementControl: DGis.CameraPurposeOptionSet
  public static let roadMarkingsCrossingControl: DGis.CameraPurposeOptionSet
  public static let trafficLightsViolationControl: DGis.CameraPurposeOptionSet
  public static let stopLineCrossingControl: DGis.CameraPurposeOptionSet
  public static let oncomingTrafficLaneMovementControl: DGis.CameraPurposeOptionSet
  public static let pedestrianAdvantageViolationControl: DGis.CameraPurposeOptionSet
  public static let laneDisciplineControl: DGis.CameraPurposeOptionSet
  public static let noStoppingViolationControl: DGis.CameraPurposeOptionSet
  public static let dummy: DGis.CameraPurposeOptionSet
  public static let truck: DGis.CameraPurposeOptionSet
  public init(rawValue: Swift.UInt32)
  public typealias ArrayLiteralElement = DGis.CameraPurposeOptionSet
  public typealias Element = DGis.CameraPurposeOptionSet
  public typealias RawValue = Swift.UInt32
}
public struct RoadCameraInfo : Swift.Hashable {
  public var purposes: DGis.CameraPurposeOptionSet
  public var speedLimit: Swift.UInt16?
  public init(purposes: DGis.CameraPurposeOptionSet, speedLimit: Swift.UInt16?)
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (a: DGis.RoadCameraInfo, b: DGis.RoadCameraInfo) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
}
public struct Schedule : Swift.Hashable {
  public var startTime: Foundation.Date?
  public var finishTime: Foundation.Date?
  public var weekTimeIntervals: [DGis.WeekTimeInterval]
  public init(startTime: Foundation.Date?, finishTime: Foundation.Date?, weekTimeIntervals: [DGis.WeekTimeInterval])
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (a: DGis.Schedule, b: DGis.Schedule) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
}
public enum Lane : Swift.UInt32 {
  case left
  case center
  case right
  public init?(rawValue: Swift.UInt32)
  public typealias RawValue = Swift.UInt32
  public var rawValue: Swift.UInt32 {
    get
  }
}
public struct LaneOptionSet : Swift.OptionSet, Swift.Hashable {
  public var rawValue: Swift.UInt32
  public static let left: DGis.LaneOptionSet
  public static let center: DGis.LaneOptionSet
  public static let right: DGis.LaneOptionSet
  public init(rawValue: Swift.UInt32)
  public typealias ArrayLiteralElement = DGis.LaneOptionSet
  public typealias Element = DGis.LaneOptionSet
  public typealias RawValue = Swift.UInt32
}
@_hasMissingDesignatedInitializers final public class RoadEventPhoto : Swift.Hashable {
  final public var photoUrl: Swift.String {
    get
  }
  final public var author: DGis.AuthorInfo {
    get
  }
  final public var timestamp: Foundation.Date {
    get
  }
  final public var remover: DGis.Remover? {
    get
  }
  @objc deinit
  public static func == (lhs: DGis.RoadEventPhoto, rhs: DGis.RoadEventPhoto) -> Swift.Bool
  final public func hash(into hasher: inout Swift.Hasher)
  final public func previewUrl(desiredSize: DGis.ScreenSize) -> Swift.String
  final public func report() -> DGis.Future<DGis.ActionResult>
  final public var hashValue: Swift.Int {
    get
  }
}
public enum ActionResult : Swift.UInt32 {
  case ok
  case networkError
  public init?(rawValue: Swift.UInt32)
  public typealias RawValue = Swift.UInt32
  public var rawValue: Swift.UInt32 {
    get
  }
}
@_hasMissingDesignatedInitializers final public class Remover : Swift.Hashable {
  @objc deinit
  public static func == (lhs: DGis.Remover, rhs: DGis.Remover) -> Swift.Bool
  final public func hash(into hasher: inout Swift.Hasher)
  final public func remove() -> DGis.Future<DGis.ActionResult>
  final public var hashValue: Swift.Int {
    get
  }
}
public enum RoadEventActionType : Swift.UInt32 {
  case like
  case dislike
  case confirmation
  case disproof
  public init?(rawValue: Swift.UInt32)
  public typealias RawValue = Swift.UInt32
  public var rawValue: Swift.UInt32 {
    get
  }
}
@_hasMissingDesignatedInitializers final public class RoadEventAction : Swift.Hashable {
  final public var type: DGis.RoadEventActionType {
    get
  }
  final public var name: Swift.String {
    get
  }
  final public var infoChannel: DGis.StatefulChannel<DGis.RoadEventActionInfo> {
    get
  }
  final public var info: DGis.RoadEventActionInfo {
    get
  }
  @objc deinit
  public static func == (lhs: DGis.RoadEventAction, rhs: DGis.RoadEventAction) -> Swift.Bool
  final public func hash(into hasher: inout Swift.Hasher)
  final public func set() -> DGis.Future<DGis.ActionResult>
  final public func reset() -> DGis.Future<DGis.ActionResult>
  final public var hashValue: Swift.Int {
    get
  }
}
public enum RoadEventActionState : Swift.UInt32 {
  case set
  case notSet
  public init?(rawValue: Swift.UInt32)
  public typealias RawValue = Swift.UInt32
  public var rawValue: Swift.UInt32 {
    get
  }
}
public struct RoadEventActionInfo : Swift.Hashable {
  public var state: DGis.RoadEventActionState
  public var count: Swift.UInt32?
  public init(state: DGis.RoadEventActionState, count: Swift.UInt32?)
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (a: DGis.RoadEventActionInfo, b: DGis.RoadEventActionInfo) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
}
@_hasMissingDesignatedInitializers final public class Style : Swift.Hashable {
  final public var styleAttributes: DGis.Attributes {
    get
  }
  @objc deinit
  public static func == (lhs: DGis.Style, rhs: DGis.Style) -> Swift.Bool
  final public func hash(into hasher: inout Swift.Hasher)
  final public var hashValue: Swift.Int {
    get
  }
}
@_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers final public class StyleZoomFollowController : DGis.FollowController {
  convenience public init(animationDuration: Foundation.TimeInterval = 0.3)
  final public func setStyleZoom(styleZoom: DGis.StyleZoom)
  final public func setStyleZoomRange(minStyleZoom: DGis.StyleZoom, maxStyleZoom: DGis.StyleZoom)
  @objc deinit
}
public protocol StyleZoomToTiltRelation {
  func styleZoomToTilt(styleZoom: DGis.StyleZoom) -> DGis.Tilt
}
@_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers final public class TiltFollowController : DGis.FollowController {
  convenience public init(styleZoomToTilt: DGis.StyleZoomToTiltRelation)
  @objc deinit
}
@_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers final public class TrafficSource : DGis.Source {
  convenience public init(context: DGis.Context)
  @objc deinit
}
public enum RoadEventDisplayCategory : Swift.UInt32 {
  case camera
  case comment
  case accident
  case roadRestriction
  case roadWorks
  case other
  case user
  public init?(rawValue: Swift.UInt32)
  public typealias RawValue = Swift.UInt32
  public var rawValue: Swift.UInt32 {
    get
  }
}
@_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers final public class RoadEventSource : DGis.Source {
  final public var visibleEvents: DGis.RoadEventDisplayCategoryOptionSet {
    get
    set(types)
  }
  final public var highlightedObjectsChannel: DGis.StatefulChannel<[DGis.DgisObjectId]> {
    get
  }
  final public var highlightedObjects: [DGis.DgisObjectId] {
    get
  }
  convenience public init(context: DGis.Context)
  final public func setHighlighted(directoryObjectIds: [DGis.DgisObjectId], highlighted: Swift.Bool)
  @objc deinit
}
public struct RoadEventDisplayCategoryOptionSet : Swift.OptionSet, Swift.Hashable {
  public var rawValue: Swift.UInt32
  public static let camera: DGis.RoadEventDisplayCategoryOptionSet
  public static let comment: DGis.RoadEventDisplayCategoryOptionSet
  public static let accident: DGis.RoadEventDisplayCategoryOptionSet
  public static let roadRestriction: DGis.RoadEventDisplayCategoryOptionSet
  public static let roadWorks: DGis.RoadEventDisplayCategoryOptionSet
  public static let other: DGis.RoadEventDisplayCategoryOptionSet
  public static let user: DGis.RoadEventDisplayCategoryOptionSet
  public init(rawValue: Swift.UInt32)
  public typealias ArrayLiteralElement = DGis.RoadEventDisplayCategoryOptionSet
  public typealias Element = DGis.RoadEventDisplayCategoryOptionSet
  public typealias RawValue = Swift.UInt32
}
public enum Alignment : Swift.UInt32 {
  case topLeft
  case topRight
  case bottomLeft
  case bottomRight
  public init?(rawValue: Swift.UInt32)
  public typealias RawValue = Swift.UInt32
  public var rawValue: Swift.UInt32 {
    get
  }
}
public enum AnimationMode : Swift.UInt32 {
  case normal
  case loop
  public init?(rawValue: Swift.UInt32)
  public typealias RawValue = Swift.UInt32
  public var rawValue: Swift.UInt32 {
    get
  }
}
public struct LogicalPixel : Swift.Hashable {
  public var value: Swift.Float
  public init(value: Swift.Float = 0)
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (a: DGis.LogicalPixel, b: DGis.LogicalPixel) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
}
public enum MapDataLoadingState : Swift.UInt32 {
  case loading
  case loaded
  public init?(rawValue: Swift.UInt32)
  public typealias RawValue = Swift.UInt32
  public var rawValue: Swift.UInt32 {
    get
  }
}
public struct MapDirection : Swift.Hashable {
  public var value: Swift.Double
  public init(value: Swift.Double = 0)
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (a: DGis.MapDirection, b: DGis.MapDirection) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
}
public struct MapId : Swift.Hashable {
  public var value: Swift.Int32
  public init(value: Swift.Int32 = 0)
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (a: DGis.MapId, b: DGis.MapId) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
}
public enum MapVisibilityState : Swift.UInt32 {
  case visible
  case hidden
  public init?(rawValue: Swift.UInt32)
  public typealias RawValue = Swift.UInt32
  public var rawValue: Swift.UInt32 {
    get
  }
}
public struct Opacity : Swift.Hashable {
  public var value: Swift.Float
  public init(value: Swift.Float = 0)
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (a: DGis.Opacity, b: DGis.Opacity) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
}
public struct Padding : Swift.Hashable {
  public var left: Swift.UInt32
  public var top: Swift.UInt32
  public var right: Swift.UInt32
  public var bottom: Swift.UInt32
  public init(left: Swift.UInt32 = 0, top: Swift.UInt32 = 0, right: Swift.UInt32 = 0, bottom: Swift.UInt32 = 0)
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (a: DGis.Padding, b: DGis.Padding) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
}
public struct RenderedObject : Swift.Hashable {
  public var item: DGis.MapObject
  public var source: DGis.Source
  public var levelId: DGis.LevelId?
  public init(item: DGis.MapObject, source: DGis.Source, levelId: DGis.LevelId? = nil)
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (a: DGis.RenderedObject, b: DGis.RenderedObject) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
}
public struct ScreenDistance : Swift.Hashable {
  public var value: Swift.Float
  public init(value: Swift.Float = 0)
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (a: DGis.ScreenDistance, b: DGis.ScreenDistance) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
}
public struct StyleLayerId : Swift.Hashable {
  public var id: Swift.String
  public init(id: Swift.String)
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (a: DGis.StyleLayerId, b: DGis.StyleLayerId) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
}
public enum TextPlacement : Swift.UInt32 {
  case noLabel
  case bottomCenter
  case bottomRight
  case bottomLeft
  case circleBottomRight
  case rightBottom
  case rightCenter
  case rightTop
  case circleTopRight
  case topCenter
  case topRight
  case topLeft
  case circleTopLeft
  case leftTop
  case leftCenter
  case leftBottom
  case circleBottomLeft
  case centerCenter
  public init?(rawValue: Swift.UInt32)
  public typealias RawValue = Swift.UInt32
  public var rawValue: Swift.UInt32 {
    get
  }
}
public struct TextStyle : Swift.Hashable {
  public var fontSize: DGis.LogicalPixel
  public var color: DGis.Color
  public var strokeWidth: DGis.LogicalPixel
  public var strokeColor: DGis.Color
  public var textPlacement: DGis.TextPlacement
  public var textOffset: DGis.LogicalPixel
  public var fontName: Swift.String?
  public init(fontSize: DGis.LogicalPixel = LogicalPixel(value: 8), color: DGis.Color = Color(), strokeWidth: DGis.LogicalPixel = LogicalPixel(value: 0.3499999940395355), strokeColor: DGis.Color = Color(argb: 4294967295), textPlacement: DGis.TextPlacement = TextPlacement.bottomCenter, textOffset: DGis.LogicalPixel = LogicalPixel(value: 0), fontName: Swift.String? = nil)
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (a: DGis.TextStyle, b: DGis.TextStyle) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
}
public struct CameraBehaviour : Swift.Hashable {
  public var position: DGis.FollowPosition?
  public var tilt: DGis.FollowTilt
  public init(position: DGis.FollowPosition?, tilt: DGis.FollowTilt = FollowTilt.off)
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (a: DGis.CameraBehaviour, b: DGis.CameraBehaviour) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
}
public struct CameraBehaviourChange : Swift.Hashable {
  public var newBehaviour: DGis.CameraBehaviour
  public var changeReason: DGis.CameraBehaviourChangeReason
  public init(newBehaviour: DGis.CameraBehaviour, changeReason: DGis.CameraBehaviourChangeReason)
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (a: DGis.CameraBehaviourChange, b: DGis.CameraBehaviourChange) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
}
public struct CameraPositionChange : Swift.Hashable {
  public var point: DGis.GeoPoint?
  public var zoom: DGis.Zoom?
  public var tilt: DGis.Tilt?
  public var bearing: DGis.Bearing?
  public init(point: DGis.GeoPoint? = nil, zoom: DGis.Zoom? = nil, tilt: DGis.Tilt? = nil, bearing: DGis.Bearing? = nil)
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (a: DGis.CameraPositionChange, b: DGis.CameraPositionChange) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
}
public struct CameraZoomRestrictions : Swift.Hashable {
  public var minZoom: DGis.Zoom
  public var maxZoom: DGis.Zoom
  public init(minZoom: DGis.Zoom = Zoom(value: 0), maxZoom: DGis.Zoom = Zoom(value: 20))
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (a: DGis.CameraZoomRestrictions, b: DGis.CameraZoomRestrictions) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
}
@_hasMissingDesignatedInitializers final public class GeometryMapObjectBuilder : Swift.Hashable {
  @objc deinit
  public static func == (lhs: DGis.GeometryMapObjectBuilder, rhs: DGis.GeometryMapObjectBuilder) -> Swift.Bool
  final public func hash(into hasher: inout Swift.Hasher)
  convenience public init()
  final public func setObjectAttribute(name: Swift.String, value: DGis.AttributeValue) -> DGis.GeometryMapObjectBuilder
  final public func setObjectAttributes(values: [Swift.String : DGis.AttributeValue]) -> DGis.GeometryMapObjectBuilder
  final public func setGeometry(geometry: DGis.Geometry) -> DGis.GeometryMapObjectBuilder
  final public func setVisible(visible: Swift.Bool) -> DGis.GeometryMapObjectBuilder
  final public func setDraggable(draggable: Swift.Bool) -> DGis.GeometryMapObjectBuilder
  final public func setUserData(userData: Any) -> DGis.GeometryMapObjectBuilder
  final public func createObject() -> DGis.GeometryMapObject
  final public var hashValue: Swift.Int {
    get
  }
}
@_hasMissingDesignatedInitializers final public class GeometryMapObjectSourceBuilder : Swift.Hashable {
  @objc deinit
  public static func == (lhs: DGis.GeometryMapObjectSourceBuilder, rhs: DGis.GeometryMapObjectSourceBuilder) -> Swift.Bool
  final public func hash(into hasher: inout Swift.Hasher)
  convenience public init(context: DGis.Context)
  final public func setSourceAttribute(name: Swift.String, value: DGis.AttributeValue) -> DGis.GeometryMapObjectSourceBuilder
  final public func setSourceAttributes(values: [Swift.String : DGis.AttributeValue]) -> DGis.GeometryMapObjectSourceBuilder
  final public func addObject(item: DGis.GeometryMapObject) -> DGis.GeometryMapObjectSourceBuilder
  final public func addObjects(objects: [DGis.GeometryMapObject]) -> DGis.GeometryMapObjectSourceBuilder
  final public func createSource() -> DGis.GeometryMapObjectSource
  final public var hashValue: Swift.Int {
    get
  }
}
@_hasMissingDesignatedInitializers final public class IndoorBuilding : Swift.Hashable {
  final public var id: DGis.DgisObjectId {
    get
  }
  final public var defaultLevelIndex: Swift.UInt64 {
    get
  }
  final public var levels: [DGis.LevelInfo] {
    get
  }
  final public var activeLevelIndexChannel: DGis.StatefulChannel<Swift.UInt64> {
    get
  }
  final public var activeLevelIndex: Swift.UInt64 {
    get
    set(levelIndex)
  }
  @objc deinit
  public static func == (lhs: DGis.IndoorBuilding, rhs: DGis.IndoorBuilding) -> Swift.Bool
  final public func hash(into hasher: inout Swift.Hasher)
  final public var hashValue: Swift.Int {
    get
  }
}
public enum IndoorManagerState : Swift.UInt32 {
  case disabled
  case enabled
  public init?(rawValue: Swift.UInt32)
  public typealias RawValue = Swift.UInt32
  public var rawValue: Swift.UInt32 {
    get
  }
}
@_hasMissingDesignatedInitializers final public class IndoorManager : Swift.Hashable {
  final public var focusedBuildingChannel: DGis.StatefulChannel<DGis.IndoorBuilding?> {
    get
  }
  final public var focusedBuilding: DGis.IndoorBuilding? {
    get
  }
  @objc deinit
  public static func == (lhs: DGis.IndoorManager, rhs: DGis.IndoorManager) -> Swift.Bool
  final public func hash(into hasher: inout Swift.Hasher)
  final public func setIndoorState(newState: DGis.IndoorManagerState)
  final public var hashValue: Swift.Int {
    get
  }
}
@_hasMissingDesignatedInitializers final public class IndoorControlModel : Swift.Hashable {
  final public var activeLevelIndexChannel: DGis.StatefulChannel<Swift.UInt64?> {
    get
  }
  final public var activeLevelIndex: Swift.UInt64? {
    get
    set(activeIndex)
  }
  final public var markedLevels: Swift.Set<DGis.LevelId> {
    get
    set(markedLevels)
  }
  final public var levelNamesChannel: DGis.StatefulChannel<[Swift.String]> {
    get
  }
  final public var levelNames: [Swift.String] {
    get
  }
  @objc deinit
  public static func == (lhs: DGis.IndoorControlModel, rhs: DGis.IndoorControlModel) -> Swift.Bool
  final public func hash(into hasher: inout Swift.Hasher)
  convenience public init(map: DGis.Map)
  final public func isLevelMarked(index: Swift.UInt64) -> Swift.Bool
  final public var hashValue: Swift.Int {
    get
  }
}
@_hasMissingDesignatedInitializers final public class Map : Swift.Hashable {
  final public var id: DGis.MapId {
    get
  }
  final public var camera: DGis.Camera {
    get
  }
  final public var indoorManager: DGis.IndoorManager {
    get
  }
  final public var dataLoadingStateChannel: DGis.StatefulChannel<DGis.MapDataLoadingState> {
    get
  }
  final public var dataLoadingState: DGis.MapDataLoadingState {
    get
  }
  final public var styleChannel: DGis.StatefulChannel<DGis.Style> {
    get
  }
  final public var style: DGis.Style {
    get
    set(style)
  }
  final public var fontIconSizeMultiplierChannel: DGis.StatefulChannel<Swift.Float> {
    get
  }
  final public var fontIconSizeMultiplier: Swift.Float {
    get
  }
  final public var sources: [DGis.Source] {
    get
  }
  final public var mapVisibilityStateChannel: DGis.StatefulChannel<DGis.MapVisibilityState> {
    get
  }
  final public var mapVisibilityState: DGis.MapVisibilityState {
    get
    set(state)
  }
  final public var attributes: DGis.Attributes {
    get
  }
  final public var interactiveChannel: DGis.StatefulChannel<Swift.Bool> {
    get
  }
  final public var interactive: Swift.Bool {
    get
    set(interactive)
  }
  @objc deinit
  public static func == (lhs: DGis.Map, rhs: DGis.Map) -> Swift.Bool
  final public func hash(into hasher: inout Swift.Hasher)
  final public func setFontIconSizeMultiplier(multiplier: Swift.Float) throws
  final public func resetFontIconSizeMultiplier()
  final public func addSource(source: DGis.Source)
  final public func removeSource(source: DGis.Source)
  final public func getRenderedObjects(centerPoint: DGis.ScreenPoint, radius: DGis.ScreenDistance = ScreenDistance(value: 1)) -> DGis.Future<[DGis.RenderedObjectInfo]>
  final public var hashValue: Swift.Int {
    get
  }
}
@_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers final public class Camera : DGis.BaseCamera {
  final public var stateChannel: DGis.StatefulChannel<DGis.CameraState> {
    get
  }
  final public var state: DGis.CameraState {
    get
  }
  final public var behaviourChannel: DGis.StatefulChannel<DGis.CameraBehaviourChange> {
    get
  }
  final public var behaviour: DGis.CameraBehaviourChange {
    get
  }
  final public func move(moveController: DGis.CameraMoveController) -> DGis.Future<DGis.CameraAnimatedMoveResult>
  final public func move(position: DGis.CameraPosition, time: Foundation.TimeInterval = 0.3, animationType: DGis.CameraAnimationType = CameraAnimationType.`default`) -> DGis.Future<DGis.CameraAnimatedMoveResult>
  final public func move(point: DGis.GeoPoint, zoom: DGis.Zoom, tilt: DGis.Tilt?, bearing: DGis.Bearing, time: Foundation.TimeInterval = 0.3, animationType: DGis.CameraAnimationType = CameraAnimationType.`default`) -> DGis.Future<DGis.CameraAnimatedMoveResult>
  final public func processMovementAndStop()
  final public func setBehaviour(behaviour: DGis.CameraBehaviour)
  final public func addFollowController(followController: DGis.FollowController)
  final public func removeFollowController(followController: DGis.FollowController)
  final public func setCustomFollowController(followController: DGis.CustomFollowController)
  final public func removeCustomFollowController()
  @objc deinit
}
public struct RenderedObjectInfo : Swift.Hashable {
  public var closestViewportPoint: DGis.ScreenPoint
  public var closestMapPoint: DGis.GeoPointWithElevation
  public var item: DGis.RenderedObject
  public init(closestViewportPoint: DGis.ScreenPoint, closestMapPoint: DGis.GeoPointWithElevation, item: DGis.RenderedObject)
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (a: DGis.RenderedObjectInfo, b: DGis.RenderedObjectInfo) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
}
@_hasMissingDesignatedInitializers final public class Projection : Swift.Hashable {
  @objc deinit
  public static func == (lhs: DGis.Projection, rhs: DGis.Projection) -> Swift.Bool
  final public func hash(into hasher: inout Swift.Hasher)
  final public func screenToMap(point: DGis.ScreenPoint) -> DGis.GeoPoint?
  final public func mapToScreen(point: DGis.GeoPoint) -> DGis.ScreenPoint?
  final public func mapToScreen(point: DGis.GeoPointWithElevation) -> DGis.ScreenPoint?
  final public func screenToMapClipped(point: DGis.ScreenPoint) -> DGis.GeoPoint
  final public var hashValue: Swift.Int {
    get
  }
}
@_hasMissingDesignatedInitializers public class BaseCamera : Swift.Hashable {
  public var projection: DGis.Projection {
    get
  }
  public var positionChannel: DGis.StatefulChannel<DGis.CameraPosition> {
    get
  }
  public var position: DGis.CameraPosition {
    get
  }
  public var zoomRestrictionsChannel: DGis.StatefulChannel<DGis.CameraZoomRestrictions> {
    get
  }
  public var zoomRestrictions: DGis.CameraZoomRestrictions {
    get
  }
  public var deviceDensityChannel: DGis.StatefulChannel<DGis.DeviceDensity> {
    get
  }
  public var deviceDensity: DGis.DeviceDensity {
    get
  }
  public var sizeChannel: DGis.StatefulChannel<DGis.ScreenSize> {
    get
  }
  public var size: DGis.ScreenSize {
    get
    set(size)
  }
  public var paddingChannel: DGis.StatefulChannel<DGis.Padding> {
    get
  }
  public var padding: DGis.Padding {
    get
    set(padding)
  }
  public var positionPointChannel: DGis.StatefulChannel<DGis.CameraPositionPoint> {
    get
  }
  public var positionPoint: DGis.CameraPositionPoint {
    get
  }
  public var visibleArea: DGis.Geometry {
    get
  }
  public var visibleRectChannel: DGis.StatefulChannel<DGis.GeoRect> {
    get
  }
  public var visibleRect: DGis.GeoRect {
    get
  }
  public var maxTiltRestrictionChannel: DGis.StatefulChannel<DGis.StyleZoomToTiltRelation?> {
    get
  }
  public var maxTiltRestriction: DGis.StyleZoomToTiltRelation? {
    get
    set(maxTiltRestriction)
  }
  @objc deinit
  public static func == (lhs: DGis.BaseCamera, rhs: DGis.BaseCamera) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public func clone() -> DGis.BaseCamera
  public func setPosition(position: DGis.CameraPosition) throws
  public func changePosition(positionChange: DGis.CameraPositionChange) throws
  public func setZoomRestrictions(zoomRestrictions: DGis.CameraZoomRestrictions) throws
  public func setPositionPoint(positionPoint: DGis.CameraPositionPoint) throws
  public var hashValue: Swift.Int {
    get
  }
}
@_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers public class SimpleMapObject : DGis.MapObject {
  public var isVisible: Swift.Bool {
    get
    set(visible)
  }
  public var zIndex: DGis.ZIndex {
    get
    set(zIndex)
  }
  public var levelId: DGis.LevelId? {
    get
    set(levelId)
  }
  public var bounds: DGis.GeoRect {
    get
  }
  @objc deinit
}
@_hasMissingDesignatedInitializers final public class MapObjectManager : Swift.Hashable {
  final public var isVisible: Swift.Bool {
    get
    set(visible)
  }
  @objc deinit
  public static func == (lhs: DGis.MapObjectManager, rhs: DGis.MapObjectManager) -> Swift.Bool
  final public func hash(into hasher: inout Swift.Hasher)
  convenience public init(map: DGis.Map, layerId: Swift.String? = nil)
  public static func withClustering(map: DGis.Map, logicalPixel: DGis.LogicalPixel, maxZoom: DGis.Zoom, clusterRenderer: DGis.SimpleClusterRenderer, minZoom: DGis.Zoom = Zoom(value: 0), layerId: Swift.String? = nil) -> DGis.MapObjectManager
  public static func withGeneralization(map: DGis.Map, logicalPixel: DGis.LogicalPixel, maxZoom: DGis.Zoom, minZoom: DGis.Zoom = Zoom(value: 0), layerId: Swift.String? = nil) -> DGis.MapObjectManager
  final public func addObject(item: DGis.SimpleMapObject)
  final public func removeObject(item: DGis.SimpleMapObject)
  final public func addObjects(objects: [DGis.SimpleMapObject])
  final public func removeObjects(objects: [DGis.SimpleMapObject])
  final public func removeAndAddObjects(objectsToRemove: [DGis.SimpleMapObject], objectsToAdd: [DGis.SimpleMapObject])
  final public func removeAll()
  final public func clusteringObjects(position: DGis.CameraPosition) -> [DGis.MapObject]
  final public var hashValue: Swift.Int {
    get
  }
}
public struct SimpleClusterOptions {
  public var icon: DGis.Image?
  public var iconMapDirection: DGis.MapDirection?
  public var anchor: DGis.Anchor
  public var text: Swift.String?
  public var textStyle: DGis.TextStyle?
  public var iconOpacity: DGis.Opacity
  public var iconWidth: DGis.LogicalPixel
  public var userData: Any
  public var zIndex: DGis.ZIndex
  public var animatedAppearance: Swift.Bool
  public var iconAnimationMode: DGis.AnimationMode
  public init(icon: DGis.Image?, iconMapDirection: DGis.MapDirection? = nil, anchor: DGis.Anchor = Anchor(x: 0.5, y: 0.5), text: Swift.String? = nil, textStyle: DGis.TextStyle? = nil, iconOpacity: DGis.Opacity = Opacity(value: 1), iconWidth: DGis.LogicalPixel = LogicalPixel(value: 0), userData: Any = (), zIndex: DGis.ZIndex = ZIndex(value: 0), animatedAppearance: Swift.Bool = true, iconAnimationMode: DGis.AnimationMode = AnimationMode.normal)
}
@_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers final public class SimpleClusterObject : DGis.MapObject {
  final public var position: DGis.GeoPointWithElevation {
    get
  }
  final public var objectCount: Swift.UInt32 {
    get
  }
  final public var objects: [DGis.SimpleMapObject] {
    get
  }
  final public var anchor: DGis.Anchor {
    get
    set(anchor)
  }
  final public var iconOpacity: DGis.Opacity {
    get
    set(opacity)
  }
  final public var text: Swift.String {
    get
    set(text)
  }
  final public var textStyle: DGis.TextStyle {
    get
    set(style)
  }
  final public var iconWidth: DGis.LogicalPixel {
    get
    set(width)
  }
  final public var iconMapDirection: DGis.MapDirection? {
    get
    set(direction)
  }
  final public var animatedAppearance: Swift.Bool {
    get
    set(animatedAppearance)
  }
  final public var zIndex: DGis.ZIndex {
    get
    set(zIndex)
  }
  final public func setIcon(icon: DGis.Image?)
  @objc deinit
}
public protocol SimpleClusterRenderer {
  func renderCluster(cluster: DGis.SimpleClusterObject) -> DGis.SimpleClusterOptions
}
@_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers final public class Marker : DGis.SimpleMapObject {
  final public var position: DGis.GeoPointWithElevation {
    get
    set(position)
  }
  final public var icon: DGis.Image? {
    get
    set(icon)
  }
  final public var anchor: DGis.Anchor {
    get
    set(anchor)
  }
  final public var iconOpacity: DGis.Opacity {
    get
    set(opacity)
  }
  final public var text: Swift.String {
    get
    set(text)
  }
  final public var textStyle: DGis.TextStyle {
    get
    set(style)
  }
  final public var isDraggable: Swift.Bool {
    get
    set(draggable)
  }
  final public var iconWidth: DGis.LogicalPixel {
    get
    set(width)
  }
  final public var iconMapDirection: DGis.MapDirection? {
    get
    set(direction)
  }
  final public var animatedAppearance: Swift.Bool {
    get
    set(animatedAppearance)
  }
  final public var iconAnimationMode: DGis.AnimationMode {
    get
    set(iconAnimationMode)
  }
  convenience public init(options: DGis.MarkerOptions) throws
  @objc deinit
}
public struct MarkerOptions {
  public var position: DGis.GeoPointWithElevation
  public var icon: DGis.Image?
  public var iconMapDirection: DGis.MapDirection?
  public var anchor: DGis.Anchor
  public var text: Swift.String?
  public var textStyle: DGis.TextStyle?
  public var iconOpacity: DGis.Opacity
  public var visible: Swift.Bool
  public var draggable: Swift.Bool
  public var iconWidth: DGis.LogicalPixel
  public var userData: Any
  public var zIndex: DGis.ZIndex
  public var animatedAppearance: Swift.Bool
  public var levelId: DGis.LevelId?
  public var iconAnimationMode: DGis.AnimationMode
  public init(position: DGis.GeoPointWithElevation, icon: DGis.Image?, iconMapDirection: DGis.MapDirection? = nil, anchor: DGis.Anchor = Anchor(x: 0.5, y: 0.5), text: Swift.String? = nil, textStyle: DGis.TextStyle? = nil, iconOpacity: DGis.Opacity = Opacity(value: 1), visible: Swift.Bool = true, draggable: Swift.Bool = false, iconWidth: DGis.LogicalPixel = LogicalPixel(value: 0), userData: Any = (), zIndex: DGis.ZIndex = ZIndex(value: 0), animatedAppearance: Swift.Bool = true, levelId: DGis.LevelId? = nil, iconAnimationMode: DGis.AnimationMode = AnimationMode.normal)
}
public struct DashedStrokeCircleOptions : Swift.Hashable {
  public var dashLength: DGis.LogicalPixel
  public var dashSpaceLength: DGis.LogicalPixel
  public init(dashLength: DGis.LogicalPixel = LogicalPixel(value: 5), dashSpaceLength: DGis.LogicalPixel = LogicalPixel(value: 2))
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (a: DGis.DashedStrokeCircleOptions, b: DGis.DashedStrokeCircleOptions) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
}
@_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers final public class Circle : DGis.SimpleMapObject {
  final public var position: DGis.GeoPoint {
    get
  }
  final public var radius: DGis.Meter {
    get
  }
  final public var color: DGis.Color {
    get
    set(color)
  }
  final public var strokeWidth: DGis.LogicalPixel {
    get
    set(width)
  }
  final public var strokeColor: DGis.Color {
    get
    set(color)
  }
  final public var dashedStrokeOptions: DGis.DashedStrokeCircleOptions? {
    get
    set(options)
  }
  convenience public init(options: DGis.CircleOptions) throws
  final public func setPosition(position: DGis.GeoPoint) throws
  final public func setRadius(radius: DGis.Meter) throws
  @objc deinit
}
public struct CircleOptions {
  public var position: DGis.GeoPoint
  public var radius: DGis.Meter
  public var color: DGis.Color
  public var strokeWidth: DGis.LogicalPixel
  public var strokeColor: DGis.Color
  public var dashedStrokeOptions: DGis.DashedStrokeCircleOptions?
  public var visible: Swift.Bool
  public var userData: Any
  public var zIndex: DGis.ZIndex
  public var levelId: DGis.LevelId?
  public init(position: DGis.GeoPoint, radius: DGis.Meter, color: DGis.Color = Color(), strokeWidth: DGis.LogicalPixel = LogicalPixel(value: 0), strokeColor: DGis.Color = Color(), dashedStrokeOptions: DGis.DashedStrokeCircleOptions? = nil, visible: Swift.Bool = true, userData: Any = (), zIndex: DGis.ZIndex = ZIndex(value: 0), levelId: DGis.LevelId? = nil)
}
@_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers final public class Polygon : DGis.SimpleMapObject {
  final public var contours: [[DGis.GeoPoint]] {
    get
    set(contours)
  }
  final public var color: DGis.Color {
    get
    set(color)
  }
  final public var strokeWidth: DGis.LogicalPixel {
    get
    set(width)
  }
  final public var strokeColor: DGis.Color {
    get
    set(color)
  }
  convenience public init(options: DGis.PolygonOptions) throws
  @objc deinit
}
public struct PolygonOptions {
  public var contours: [[DGis.GeoPoint]]
  public var color: DGis.Color
  public var strokeWidth: DGis.LogicalPixel
  public var strokeColor: DGis.Color
  public var visible: Swift.Bool
  public var userData: Any
  public var zIndex: DGis.ZIndex
  public var levelId: DGis.LevelId?
  public init(contours: [[DGis.GeoPoint]], color: DGis.Color = Color(), strokeWidth: DGis.LogicalPixel = LogicalPixel(value: 0), strokeColor: DGis.Color = Color(), visible: Swift.Bool = true, userData: Any = (), zIndex: DGis.ZIndex = ZIndex(value: 0), levelId: DGis.LevelId? = nil)
}
public struct DashedPolylineOptions : Swift.Hashable {
  public var dashLength: DGis.LogicalPixel
  public var dashSpaceLength: DGis.LogicalPixel
  public init(dashLength: DGis.LogicalPixel = LogicalPixel(value: 5), dashSpaceLength: DGis.LogicalPixel = LogicalPixel(value: 2))
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (a: DGis.DashedPolylineOptions, b: DGis.DashedPolylineOptions) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
}
public struct GradientPolylineOptions : Swift.Hashable {
  public var borderWidth: DGis.LogicalPixel
  public var secondBorderWidth: DGis.LogicalPixel
  public var gradientLength: DGis.LogicalPixel
  public var borderColor: DGis.Color
  public var secondBorderColor: DGis.Color
  public var colors: [DGis.Color]
  public var colorIndices: Foundation.Data
  public init(borderWidth: DGis.LogicalPixel = LogicalPixel(value: 0), secondBorderWidth: DGis.LogicalPixel = LogicalPixel(value: 0), gradientLength: DGis.LogicalPixel = LogicalPixel(value: 1), borderColor: DGis.Color = Color(), secondBorderColor: DGis.Color = Color(), colors: [DGis.Color], colorIndices: Foundation.Data)
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (a: DGis.GradientPolylineOptions, b: DGis.GradientPolylineOptions) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
}
@_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers final public class Polyline : DGis.SimpleMapObject {
  final public var points: [DGis.GeoPoint] {
    get
    set(points)
  }
  final public var width: DGis.LogicalPixel {
    get
    set(width)
  }
  final public var color: DGis.Color {
    get
    set(color)
  }
  final public var erasedPart: Swift.Double {
    get
    set(part)
  }
  final public var dashedPolylineOptions: DGis.DashedPolylineOptions? {
    get
    set(options)
  }
  final public var gradientPolylineOptions: DGis.GradientPolylineOptions? {
    get
    set(options)
  }
  convenience public init(options: DGis.PolylineOptions) throws
  @objc deinit
}
public struct PolylineOptions {
  public var points: [DGis.GeoPoint]
  public var width: DGis.LogicalPixel
  public var color: DGis.Color
  public var erasedPart: Swift.Double
  public var dashedPolylineOptions: DGis.DashedPolylineOptions?
  public var gradientPolylineOptions: DGis.GradientPolylineOptions?
  public var visible: Swift.Bool
  public var userData: Any
  public var zIndex: DGis.ZIndex
  public var levelId: DGis.LevelId?
  public init(points: [DGis.GeoPoint], width: DGis.LogicalPixel = LogicalPixel(value: 1), color: DGis.Color = Color(), erasedPart: Swift.Double = 0, dashedPolylineOptions: DGis.DashedPolylineOptions? = nil, gradientPolylineOptions: DGis.GradientPolylineOptions? = nil, visible: Swift.Bool = true, userData: Any = (), zIndex: DGis.ZIndex = ZIndex(value: 0), levelId: DGis.LevelId? = nil)
}
public enum CameraFollowState : Swift.UInt32 {
  case off
  case followPosition
  case followDirection
  public init?(rawValue: Swift.UInt32)
  public typealias RawValue = Swift.UInt32
  public var rawValue: Swift.UInt32 {
    get
  }
}
@_hasMissingDesignatedInitializers final public class MyLocationControlModel : Swift.Hashable {
  final public var isEnabledChannel: DGis.StatefulChannel<Swift.Bool> {
    get
  }
  final public var isEnabled: Swift.Bool {
    get
  }
  final public var followStateChannel: DGis.StatefulChannel<DGis.CameraFollowState> {
    get
  }
  final public var followState: DGis.CameraFollowState {
    get
  }
  @objc deinit
  public static func == (lhs: DGis.MyLocationControlModel, rhs: DGis.MyLocationControlModel) -> Swift.Bool
  final public func hash(into hasher: inout Swift.Hasher)
  convenience public init(map: DGis.Map)
  final public func onClicked()
  final public var hashValue: Swift.Int {
    get
  }
}
@_hasMissingDesignatedInitializers final public class CompassControlModel : Swift.Hashable {
  final public var bearingChannel: DGis.StatefulChannel<DGis.Bearing> {
    get
  }
  final public var bearing: DGis.Bearing {
    get
  }
  @objc deinit
  public static func == (lhs: DGis.CompassControlModel, rhs: DGis.CompassControlModel) -> Swift.Bool
  final public func hash(into hasher: inout Swift.Hasher)
  convenience public init(map: DGis.Map)
  final public func onClicked()
  final public var hashValue: Swift.Int {
    get
  }
}
public enum ZoomControlButton : Swift.UInt32 {
  case zoomIn
  case zoomOut
  public init?(rawValue: Swift.UInt32)
  public typealias RawValue = Swift.UInt32
  public var rawValue: Swift.UInt32 {
    get
  }
}
@_hasMissingDesignatedInitializers final public class ZoomControlModel : Swift.Hashable {
  @objc deinit
  public static func == (lhs: DGis.ZoomControlModel, rhs: DGis.ZoomControlModel) -> Swift.Bool
  final public func hash(into hasher: inout Swift.Hasher)
  convenience public init(map: DGis.Map)
  final public func isEnabled(button: DGis.ZoomControlButton) -> DGis.StatefulChannel<Swift.Bool>
  final public func setPressed(button: DGis.ZoomControlButton, value: Swift.Bool)
  final public var hashValue: Swift.Int {
    get
  }
}
public func parseGeoJsonFile(fsPath: Swift.String) -> [DGis.GeometryMapObject]
public func parseGeoJson(geoJsonData: Swift.String) -> [DGis.GeometryMapObject]
public func calcPosition(camera: DGis.BaseCamera, objects: [DGis.SimpleMapObject], styleZoomToTiltRelation: DGis.StyleZoomToTiltRelation? = nil, screenArea: DGis.Padding? = nil, tilt: DGis.Tilt? = nil, bearing: DGis.Bearing? = nil, size: DGis.ScreenSize? = nil) -> DGis.CameraPosition
public func calcPosition(camera: DGis.BaseCamera, geometry: DGis.Geometry, styleZoomToTiltRelation: DGis.StyleZoomToTiltRelation? = nil, screenArea: DGis.Padding? = nil, tilt: DGis.Tilt? = nil, bearing: DGis.Bearing? = nil, size: DGis.ScreenSize? = nil) -> DGis.CameraPosition
public func zoomOutToFit(camera: DGis.BaseCamera, objects: [DGis.SimpleMapObject], styleZoomToTiltRelation: DGis.StyleZoomToTiltRelation? = nil, size: DGis.ScreenSize? = nil) -> DGis.CameraPosition
public func zoomOutToFit(camera: DGis.BaseCamera, geometry: DGis.Geometry, styleZoomToTiltRelation: DGis.StyleZoomToTiltRelation? = nil, size: DGis.ScreenSize? = nil) -> DGis.CameraPosition
public func createRasterTileDataSource(context: DGis.Context, sublayerName: Swift.String, urlTemplate: Swift.String) -> DGis.Source
public func createDefaultMaxTiltRestriction() -> DGis.StyleZoomToTiltRelation
public func createDefaultStyleZoomToTiltRelation() -> DGis.StyleZoomToTiltRelation
public func createStyleZoomToTiltRelation(points: [DGis.StyleZoom : DGis.Tilt]) -> DGis.StyleZoomToTiltRelation
public func projectionZToStyleZ(projectionZ: DGis.Zoom, latitude: DGis.Latitude) -> DGis.StyleZoom
public func styleZToProjectionZ(styleZ: DGis.StyleZoom, latitude: DGis.Latitude) -> DGis.Zoom
public func toMapGeometry(geometry: DGis.GeoPointRouteAttribute) -> DGis.Geometry
@_hasMissingDesignatedInitializers final public class GeoPointRouteAttribute : Swift.Hashable {
  final public var size: Swift.UInt64 {
    get
  }
  final public var isEmpty: Swift.Bool {
    get
  }
  final public var first: DGis.GeoPointRouteEntry? {
    get
  }
  final public var last: DGis.GeoPointRouteEntry? {
    get
  }
  final public var entries: [DGis.GeoPointRouteEntry] {
    get
  }
  final public var length: DGis.RouteDistance {
    get
  }
  @objc deinit
  public static func == (lhs: DGis.GeoPointRouteAttribute, rhs: DGis.GeoPointRouteAttribute) -> Swift.Bool
  final public func hash(into hasher: inout Swift.Hasher)
  final public func entries(begin: DGis.RoutePoint, end: DGis.RoutePoint) -> [DGis.GeoPointRouteEntry]
  final public func findNearBackward(point: DGis.RoutePoint) -> DGis.GeoPointRouteEntry?
  final public func findNearForward(point: DGis.RoutePoint) -> DGis.GeoPointRouteEntry?
  final public func calculateGeoPoint(routePoint: DGis.RoutePoint) -> DGis.SegmentGeoPoint?
  final public var hashValue: Swift.Int {
    get
  }
}
public struct RouteDistance : Swift.Hashable {
  public var millimeters: Swift.Int64
  public init(millimeters: Swift.Int64 = 0)
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (a: DGis.RouteDistance, b: DGis.RouteDistance) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
}
public struct RoutePoint : Swift.Hashable {
  public var distance: DGis.RouteDistance
  public init(distance: DGis.RouteDistance)
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (a: DGis.RoutePoint, b: DGis.RoutePoint) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
}
public struct GeoPointRouteEntry : Swift.Hashable {
  public var point: DGis.RoutePoint
  public var value: DGis.GeoPoint
  public init(point: DGis.RoutePoint, value: DGis.GeoPoint)
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (a: DGis.GeoPointRouteEntry, b: DGis.GeoPointRouteEntry) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
}
public struct SegmentGeoPoint : Swift.Hashable {
  public var point: DGis.GeoPoint
  public var bearing: DGis.Bearing
  public init(point: DGis.GeoPoint, bearing: DGis.Bearing)
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (a: DGis.SegmentGeoPoint, b: DGis.SegmentGeoPoint) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
}
@_hasMissingDesignatedInitializers final public class PackedMapState : Swift.Hashable {
  final public var showTraffic: Swift.Bool {
    get
    set(showTraffic)
  }
  final public var cameraPosition: DGis.CameraPosition {
    get
    set(position)
  }
  final public var cameraBehaviour: DGis.CameraBehaviour {
    get
    set(behaviour)
  }
  @objc deinit
  public static func == (lhs: DGis.PackedMapState, rhs: DGis.PackedMapState) -> Swift.Bool
  final public func hash(into hasher: inout Swift.Hasher)
  public static func of(position: DGis.CameraPosition, showTraffic: Swift.Bool, behaviour: DGis.CameraBehaviour) -> DGis.PackedMapState
  public static func fromBytes(data: Foundation.Data) throws -> DGis.PackedMapState
  public static func fromMap(map: DGis.Map) -> DGis.PackedMapState
  final public func toBytes() -> Foundation.Data
  final public var hashValue: Swift.Int {
    get
  }
}
public struct CalloutMapPosition : Swift.Hashable {
  public var mapId: DGis.MapId
  public var calloutPosition: DGis.GeoPoint?
  public var routePoint: DGis.RoutePoint?
  public init(mapId: DGis.MapId, calloutPosition: DGis.GeoPoint?, routePoint: DGis.RoutePoint?)
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (a: DGis.CalloutMapPosition, b: DGis.CalloutMapPosition) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
}
public enum CalloutVisualizationMode : Swift.UInt32 {
  case always
  case multipleRoutes
  case none
  public init?(rawValue: Swift.UInt32)
  public typealias RawValue = Swift.UInt32
  public var rawValue: Swift.UInt32 {
    get
  }
}
public struct LanesCalloutMapPosition : Swift.Hashable {
  public var mapId: DGis.MapId
  public var routePoint: DGis.RoutePoint
  public var geoPoint: DGis.GeoPoint
  public init(mapId: DGis.MapId, routePoint: DGis.RoutePoint, geoPoint: DGis.GeoPoint)
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (a: DGis.LanesCalloutMapPosition, b: DGis.LanesCalloutMapPosition) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
}
@_hasMissingDesignatedInitializers final public class IndoorRouteLevelsGetter : Swift.Hashable {
  final public var levelIdsChannel: DGis.StatefulChannel<Swift.Set<DGis.LevelId>> {
    get
  }
  final public var levelIds: Swift.Set<DGis.LevelId> {
    get
  }
  @objc deinit
  public static func == (lhs: DGis.IndoorRouteLevelsGetter, rhs: DGis.IndoorRouteLevelsGetter) -> Swift.Bool
  final public func hash(into hasher: inout Swift.Hasher)
  convenience public init(map: DGis.Map)
  final public var hashValue: Swift.Int {
    get
  }
}
public enum RouteMapObjectPassedDistanceVisualization : Swift.UInt32 {
  case showRemainingRoutePart
  case showPassedRoutePart
  case showWholeRoute
  public init?(rawValue: Swift.UInt32)
  public typealias RawValue = Swift.UInt32
  public var rawValue: Swift.UInt32 {
    get
  }
}
public enum RouteMapObjectDisplayFlag : Swift.UInt32 {
  case routeParts
  case startPoint
  case finishPoint
  case intermediatePoints
  case transportConnectionPoints
  case maneuvers
  case cameras
  case humps
  case barriers
  case gates
  case stairways
  case publicTransportPlatforms
  case accidents
  case roadWorks
  case comments
  case roadRestrictions
  case otherEvents
  case tollRoads
  case lanesBubbles
  case bubbles
  case indoorInstructions
  case inactiveFloors
  case trafficLights
  public init?(rawValue: Swift.UInt32)
  public typealias RawValue = Swift.UInt32
  public var rawValue: Swift.UInt32 {
    get
  }
}
public enum RouteMapObjectPermanentDisplayFlag : Swift.UInt32 {
  case startPoint
  case finishPoint
  case intermediatePoints
  case cameras
  case accidents
  case roadWorks
  case comments
  case roadRestrictions
  case otherEvents
  case tollRoads
  public init?(rawValue: Swift.UInt32)
  public typealias RawValue = Swift.UInt32
  public var rawValue: Swift.UInt32 {
    get
  }
}
public enum RouteMapObjectCalloutLabelFlag : Swift.UInt32 {
  case duration
  case length
  public init?(rawValue: Swift.UInt32)
  public typealias RawValue = Swift.UInt32
  public var rawValue: Swift.UInt32 {
    get
  }
}
public enum RouteMapObjectCalloutLabelDisplayMode : Swift.UInt32 {
  case absoluteValues
  case relativeToActiveRouteValues
  public init?(rawValue: Swift.UInt32)
  public typealias RawValue = Swift.UInt32
  public var rawValue: Swift.UInt32 {
    get
  }
}
@_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers final public class RouteMapObject : DGis.MapObject {
  final public var displayFlagsChannel: DGis.StatefulChannel<DGis.RouteMapObjectDisplayFlagOptionSet?> {
    get
  }
  final public var displayFlags: DGis.RouteMapObjectDisplayFlagOptionSet? {
    get
    set(flags)
  }
  final public var permanentDisplayFlagsChannel: DGis.StatefulChannel<DGis.RouteMapObjectPermanentDisplayFlagOptionSet?> {
    get
  }
  final public var permanentDisplayFlags: DGis.RouteMapObjectPermanentDisplayFlagOptionSet? {
    get
    set(flags)
  }
  final public var isActiveChannel: DGis.StatefulChannel<Swift.Bool> {
    get
  }
  final public var isActive: Swift.Bool {
    get
    set(active)
  }
  final public var route: DGis.TrafficRoute {
    get
  }
  final public var routeIndex: DGis.RouteIndex {
    get
  }
  final public var passedDistanceChannel: DGis.StatefulChannel<DGis.RouteDistance> {
    get
  }
  final public var passedDistance: DGis.RouteDistance {
    get
    set(distance)
  }
  final public var passedDistanceVisualizationChannel: DGis.StatefulChannel<DGis.RouteMapObjectPassedDistanceVisualization> {
    get
  }
  final public var passedDistanceVisualization: DGis.RouteMapObjectPassedDistanceVisualization {
    get
    set(visualization)
  }
  final public var calloutPositionChannel: DGis.StatefulChannel<[DGis.CalloutMapPosition]> {
    get
  }
  final public var calloutPosition: [DGis.CalloutMapPosition] {
    get
  }
  final public var calloutLabelFlagsChannel: DGis.StatefulChannel<DGis.RouteMapObjectCalloutLabelFlagOptionSet?> {
    get
  }
  final public var calloutLabelFlags: DGis.RouteMapObjectCalloutLabelFlagOptionSet? {
    get
    set(flags)
  }
  final public var calloutLabelDisplayModeChannel: DGis.StatefulChannel<DGis.RouteMapObjectCalloutLabelDisplayMode> {
    get
  }
  final public var calloutLabelDisplayMode: DGis.RouteMapObjectCalloutLabelDisplayMode {
    get
    set(mode)
  }
  final public var lanesCalloutPositionsChannel: DGis.StatefulChannel<[DGis.LanesCalloutMapPosition]> {
    get
  }
  final public var lanesCalloutPositions: [DGis.LanesCalloutMapPosition] {
    get
  }
  convenience public init(trafficRoute: DGis.TrafficRoute, isActive: Swift.Bool, index: DGis.RouteIndex, displayFlags: DGis.RouteMapObjectDisplayFlagOptionSet? = nil, calloutLabelFlags: DGis.RouteMapObjectCalloutLabelFlagOptionSet? = nil, calloutLabelDisplayMode: DGis.RouteMapObjectCalloutLabelDisplayMode = RouteMapObjectCalloutLabelDisplayMode.absoluteValues, permanentDisplayFlags: DGis.RouteMapObjectPermanentDisplayFlagOptionSet? = nil)
  @objc deinit
}
public struct RouteMapObjectDisplayFlagOptionSet : Swift.OptionSet, Swift.Hashable {
  public var rawValue: Swift.UInt32
  public static let routeParts: DGis.RouteMapObjectDisplayFlagOptionSet
  public static let startPoint: DGis.RouteMapObjectDisplayFlagOptionSet
  public static let finishPoint: DGis.RouteMapObjectDisplayFlagOptionSet
  public static let intermediatePoints: DGis.RouteMapObjectDisplayFlagOptionSet
  public static let transportConnectionPoints: DGis.RouteMapObjectDisplayFlagOptionSet
  public static let maneuvers: DGis.RouteMapObjectDisplayFlagOptionSet
  public static let cameras: DGis.RouteMapObjectDisplayFlagOptionSet
  public static let humps: DGis.RouteMapObjectDisplayFlagOptionSet
  public static let barriers: DGis.RouteMapObjectDisplayFlagOptionSet
  public static let gates: DGis.RouteMapObjectDisplayFlagOptionSet
  public static let stairways: DGis.RouteMapObjectDisplayFlagOptionSet
  public static let publicTransportPlatforms: DGis.RouteMapObjectDisplayFlagOptionSet
  public static let accidents: DGis.RouteMapObjectDisplayFlagOptionSet
  public static let roadWorks: DGis.RouteMapObjectDisplayFlagOptionSet
  public static let comments: DGis.RouteMapObjectDisplayFlagOptionSet
  public static let roadRestrictions: DGis.RouteMapObjectDisplayFlagOptionSet
  public static let otherEvents: DGis.RouteMapObjectDisplayFlagOptionSet
  public static let tollRoads: DGis.RouteMapObjectDisplayFlagOptionSet
  public static let lanesBubbles: DGis.RouteMapObjectDisplayFlagOptionSet
  public static let bubbles: DGis.RouteMapObjectDisplayFlagOptionSet
  public static let indoorInstructions: DGis.RouteMapObjectDisplayFlagOptionSet
  public static let inactiveFloors: DGis.RouteMapObjectDisplayFlagOptionSet
  public static let trafficLights: DGis.RouteMapObjectDisplayFlagOptionSet
  public init(rawValue: Swift.UInt32)
  public typealias ArrayLiteralElement = DGis.RouteMapObjectDisplayFlagOptionSet
  public typealias Element = DGis.RouteMapObjectDisplayFlagOptionSet
  public typealias RawValue = Swift.UInt32
}
public struct RouteMapObjectPermanentDisplayFlagOptionSet : Swift.OptionSet, Swift.Hashable {
  public var rawValue: Swift.UInt32
  public static let startPoint: DGis.RouteMapObjectPermanentDisplayFlagOptionSet
  public static let finishPoint: DGis.RouteMapObjectPermanentDisplayFlagOptionSet
  public static let intermediatePoints: DGis.RouteMapObjectPermanentDisplayFlagOptionSet
  public static let cameras: DGis.RouteMapObjectPermanentDisplayFlagOptionSet
  public static let accidents: DGis.RouteMapObjectPermanentDisplayFlagOptionSet
  public static let roadWorks: DGis.RouteMapObjectPermanentDisplayFlagOptionSet
  public static let comments: DGis.RouteMapObjectPermanentDisplayFlagOptionSet
  public static let roadRestrictions: DGis.RouteMapObjectPermanentDisplayFlagOptionSet
  public static let otherEvents: DGis.RouteMapObjectPermanentDisplayFlagOptionSet
  public static let tollRoads: DGis.RouteMapObjectPermanentDisplayFlagOptionSet
  public init(rawValue: Swift.UInt32)
  public typealias ArrayLiteralElement = DGis.RouteMapObjectPermanentDisplayFlagOptionSet
  public typealias Element = DGis.RouteMapObjectPermanentDisplayFlagOptionSet
  public typealias RawValue = Swift.UInt32
}
@_hasMissingDesignatedInitializers final public class TrafficRoute : Swift.Hashable {
  final public var route: DGis.Route {
    get
  }
  final public var traffic: DGis.Traffic {
    get
  }
  @objc deinit
  public static func == (lhs: DGis.TrafficRoute, rhs: DGis.TrafficRoute) -> Swift.Bool
  final public func hash(into hasher: inout Swift.Hasher)
  public static func fromNavigationState(navigationState: DGis.PackedNavigationState, context: DGis.Context) -> DGis.TrafficRoute
  final public var hashValue: Swift.Int {
    get
  }
}
@_hasMissingDesignatedInitializers final public class Route : Swift.Hashable {
  final public var geometry: DGis.GeoPointRouteAttribute {
    get
  }
  final public var instructions: DGis.InstructionRouteAttribute {
    get
  }
  final public var intermediatePoints: DGis.GeoPointRouteAttribute {
    get
  }
  final public var altitudes: DGis.DoubleRouteAttribute {
    get
  }
  final public var badRoads: DGis.BoolRouteLongAttribute {
    get
  }
  final public var obstacles: DGis.ObstacleInfoRouteAttribute {
    get
  }
  final public var roadNames: DGis.StringRouteLongAttribute {
    get
  }
  final public var settlements: DGis.SettlementRouteLongAttribute {
    get
  }
  final public var transportTypes: DGis.TransportTypeRouteLongAttribute {
    get
  }
  final public var cameras: DGis.CameraRouteAttribute {
    get
  }
  final public var carriagewaysWidth: DGis.UIntRouteLongAttribute {
    get
  }
  final public var exitSigns: DGis.RouteExitSignRouteAttribute {
    get
  }
  final public var humps: DGis.VoidRouteAttribute {
    get
  }
  final public var lanes: DGis.LaneSignRouteLongAttribute {
    get
  }
  final public var levels: DGis.RouteLevelInfoRouteLongAttribute {
    get
  }
  final public var maxSpeedLimits: DGis.FloatRouteLongAttribute {
    get
  }
  final public var roadRules: DGis.RoadRuleRouteLongAttribute {
    get
  }
  final public var roadSubtypes: DGis.RoadSubtypeRouteLongAttribute {
    get
  }
  final public var roadSurfaces: DGis.RoadSurfaceRouteLongAttribute {
    get
  }
  final public var roadTypes: DGis.RoadTypeRouteLongAttribute {
    get
  }
  final public var tolls: DGis.BoolRouteLongAttribute {
    get
  }
  final public var truckData: DGis.BoolRouteLongAttribute {
    get
  }
  final public var truckPassZoneIds: DGis.TruckPassZoneIdRouteLongAttribute {
    get
  }
  final public var truckRestrictedAreas: DGis.BoolRouteLongAttribute {
    get
  }
  final public var vehicleRestrictedAreas: DGis.BoolRouteLongAttribute {
    get
  }
  final public var bicycleLanes: DGis.BoolRouteLongAttribute {
    get
  }
  final public var trafficLights: DGis.VoidRouteAttribute {
    get
  }
  final public var publicTransportTransfers: DGis.PublicTransportTransferRouteLongAttribute {
    get
  }
  @objc deinit
  public static func == (lhs: DGis.Route, rhs: DGis.Route) -> Swift.Bool
  final public func hash(into hasher: inout Swift.Hasher)
  final public var hashValue: Swift.Int {
    get
  }
}
@_hasMissingDesignatedInitializers final public class InstructionRouteAttribute : Swift.Hashable {
  final public var size: Swift.UInt64 {
    get
  }
  final public var isEmpty: Swift.Bool {
    get
  }
  final public var first: DGis.InstructionRouteEntry? {
    get
  }
  final public var last: DGis.InstructionRouteEntry? {
    get
  }
  final public var entries: [DGis.InstructionRouteEntry] {
    get
  }
  @objc deinit
  public static func == (lhs: DGis.InstructionRouteAttribute, rhs: DGis.InstructionRouteAttribute) -> Swift.Bool
  final public func hash(into hasher: inout Swift.Hasher)
  final public func entries(begin: DGis.RoutePoint, end: DGis.RoutePoint) -> [DGis.InstructionRouteEntry]
  final public func findNearBackward(point: DGis.RoutePoint) -> DGis.InstructionRouteEntry?
  final public func findNearForward(point: DGis.RoutePoint) -> DGis.InstructionRouteEntry?
  final public var hashValue: Swift.Int {
    get
  }
}
public struct BicycleInstructionStart : Swift.Hashable {
  public init()
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (a: DGis.BicycleInstructionStart, b: DGis.BicycleInstructionStart) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
}
public struct BicycleInstructionFinish : Swift.Hashable {
  public init()
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (a: DGis.BicycleInstructionFinish, b: DGis.BicycleInstructionFinish) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
}
public enum BicycleInstructionCrossroadLandmark : Swift.UInt32 {
  case none
  case crosswalk
  case trafficLight
  public init?(rawValue: Swift.UInt32)
  public typealias RawValue = Swift.UInt32
  public var rawValue: Swift.UInt32 {
    get
  }
}
public struct BicycleInstructionCrossroad : Swift.Hashable {
  public var landmark: DGis.BicycleInstructionCrossroadLandmark
  public var maneuvers: [DGis.BicycleInstructionCrossroadManeuver]
  public init(landmark: DGis.BicycleInstructionCrossroadLandmark = BicycleInstructionCrossroadLandmark.`none`, maneuvers: [DGis.BicycleInstructionCrossroadManeuver])
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (a: DGis.BicycleInstructionCrossroad, b: DGis.BicycleInstructionCrossroad) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
}
public struct CarInstructionStart : Swift.Hashable {
  public init()
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (a: DGis.CarInstructionStart, b: DGis.CarInstructionStart) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
}
public struct CarInstructionFinish : Swift.Hashable {
  public init()
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (a: DGis.CarInstructionFinish, b: DGis.CarInstructionFinish) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
}
public enum CarInstructionCrossroadDirection : Swift.UInt32 {
  case straight
  case slightlyLeft
  case left
  case sharplyLeft
  case uTurn
  case sharplyRight
  case right
  case slightlyRight
  case keepLeft
  case keepRight
  public init?(rawValue: Swift.UInt32)
  public typealias RawValue = Swift.UInt32
  public var rawValue: Swift.UInt32 {
    get
  }
}
public enum CarInstructionCrossroadLandmark : Swift.UInt32 {
  case none
  case tunnelBefore
  case tunnelEntry
  case bridgeBefore
  case bridgeEntry
  case archwayEntry
  case onTrafficLight
  case courtyardEntry
  public init?(rawValue: Swift.UInt32)
  public typealias RawValue = Swift.UInt32
  public var rawValue: Swift.UInt32 {
    get
  }
}
public struct CarInstructionCrossroad : Swift.Hashable {
  public var direction: DGis.CarInstructionCrossroadDirection
  public var turnAngle: Swift.Int32
  public var landmark: DGis.CarInstructionCrossroadLandmark
  public var exitName: Swift.String
  public init(direction: DGis.CarInstructionCrossroadDirection = CarInstructionCrossroadDirection.straight, turnAngle: Swift.Int32 = 0, landmark: DGis.CarInstructionCrossroadLandmark = CarInstructionCrossroadLandmark.`none`, exitName: Swift.String)
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (a: DGis.CarInstructionCrossroad, b: DGis.CarInstructionCrossroad) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
}
public enum CarInstructionRoundaboutType : Swift.UInt32 {
  case entry
  case intermediate
  case exit
  public init?(rawValue: Swift.UInt32)
  public typealias RawValue = Swift.UInt32
  public var rawValue: Swift.UInt32 {
    get
  }
}
public struct CarInstructionRoundabout : Swift.Hashable {
  public var type: DGis.CarInstructionRoundaboutType
  public var turnAngle: Swift.Int32
  public var exitNumber: Swift.UInt32
  public var exitName: Swift.String
  public init(type: DGis.CarInstructionRoundaboutType = CarInstructionRoundaboutType.entry, turnAngle: Swift.Int32 = 0, exitNumber: Swift.UInt32 = 0, exitName: Swift.String)
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (a: DGis.CarInstructionRoundabout, b: DGis.CarInstructionRoundabout) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
}
public struct CarInstructionUTurn : Swift.Hashable {
  public var exitName: Swift.String
  public init(exitName: Swift.String)
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (a: DGis.CarInstructionUTurn, b: DGis.CarInstructionUTurn) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
}
public struct PedestrianInstructionStart : Swift.Hashable {
  public init()
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (a: DGis.PedestrianInstructionStart, b: DGis.PedestrianInstructionStart) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
}
public struct PedestrianInstructionFinish : Swift.Hashable {
  public init()
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (a: DGis.PedestrianInstructionFinish, b: DGis.PedestrianInstructionFinish) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
}
public enum PedestrianInstructionCrossroadLandmark : Swift.UInt32 {
  case none
  case crosswalk
  case trafficLight
  public init?(rawValue: Swift.UInt32)
  public typealias RawValue = Swift.UInt32
  public var rawValue: Swift.UInt32 {
    get
  }
}
public struct PedestrianInstructionCrossroad : Swift.Hashable {
  public var landmark: DGis.PedestrianInstructionCrossroadLandmark
  public var maneuvers: [DGis.PedestrianInstructionCrossroadManeuver]
  public init(landmark: DGis.PedestrianInstructionCrossroadLandmark = PedestrianInstructionCrossroadLandmark.`none`, maneuvers: [DGis.PedestrianInstructionCrossroadManeuver])
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (a: DGis.PedestrianInstructionCrossroad, b: DGis.PedestrianInstructionCrossroad) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
}
public enum PedestrianInstructionIndoorFloorChangeType : Swift.UInt32 {
  case undefined
  case stairway
  case elevator
  case escalator
  public init?(rawValue: Swift.UInt32)
  public typealias RawValue = Swift.UInt32
  public var rawValue: Swift.UInt32 {
    get
  }
}
public struct PedestrianInstructionIndoorFloorChange : Swift.Hashable {
  public var type: DGis.PedestrianInstructionIndoorFloorChangeType
  public var beginId: DGis.LevelId
  public var endId: DGis.LevelId
  public init(type: DGis.PedestrianInstructionIndoorFloorChangeType = PedestrianInstructionIndoorFloorChangeType.undefined, beginId: DGis.LevelId = LevelId(), endId: DGis.LevelId = LevelId())
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (a: DGis.PedestrianInstructionIndoorFloorChange, b: DGis.PedestrianInstructionIndoorFloorChange) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
}
public struct PedestrianInstructionIndoorEnter : Swift.Hashable {
  public var levelId: DGis.LevelId
  public init(levelId: DGis.LevelId = LevelId())
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (a: DGis.PedestrianInstructionIndoorEnter, b: DGis.PedestrianInstructionIndoorEnter) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
}
public struct PedestrianInstructionIndoorExit : Swift.Hashable {
  public init()
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (a: DGis.PedestrianInstructionIndoorExit, b: DGis.PedestrianInstructionIndoorExit) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
}
public struct ScooterInstructionStart : Swift.Hashable {
  public init()
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (a: DGis.ScooterInstructionStart, b: DGis.ScooterInstructionStart) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
}
public struct ScooterInstructionFinish : Swift.Hashable {
  public init()
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (a: DGis.ScooterInstructionFinish, b: DGis.ScooterInstructionFinish) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
}
public enum ScooterInstructionCrossroadLandmark : Swift.UInt32 {
  case none
  case crosswalk
  case trafficLight
  public init?(rawValue: Swift.UInt32)
  public typealias RawValue = Swift.UInt32
  public var rawValue: Swift.UInt32 {
    get
  }
}
public struct ScooterInstructionCrossroad : Swift.Hashable {
  public var landmark: DGis.ScooterInstructionCrossroadLandmark
  public var maneuvers: [DGis.ScooterInstructionCrossroadManeuver]
  public init(landmark: DGis.ScooterInstructionCrossroadLandmark = ScooterInstructionCrossroadLandmark.`none`, maneuvers: [DGis.ScooterInstructionCrossroadManeuver])
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (a: DGis.ScooterInstructionCrossroad, b: DGis.ScooterInstructionCrossroad) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
}
public enum ExtraInstructionInfo : Swift.Hashable {
  case bicycleStart(DGis.BicycleInstructionStart)
  case bicycleFinish(DGis.BicycleInstructionFinish)
  case bicycleCrossroad(DGis.BicycleInstructionCrossroad)
  case carStart(DGis.CarInstructionStart)
  case carFinish(DGis.CarInstructionFinish)
  case carCrossroad(DGis.CarInstructionCrossroad)
  case carRoundabout(DGis.CarInstructionRoundabout)
  case carUturn(DGis.CarInstructionUTurn)
  case pedestrianStart(DGis.PedestrianInstructionStart)
  case pedestrianFinish(DGis.PedestrianInstructionFinish)
  case pedestrianCrossroad(DGis.PedestrianInstructionCrossroad)
  case pedestrianIndoorFloorChange(DGis.PedestrianInstructionIndoorFloorChange)
  case pedestrianIndoorEnter(DGis.PedestrianInstructionIndoorEnter)
  case pedestrianIndoorExit(DGis.PedestrianInstructionIndoorExit)
  case scooterStart(DGis.ScooterInstructionStart)
  case scooterFinish(DGis.ScooterInstructionFinish)
  case scooterCrossroad(DGis.ScooterInstructionCrossroad)
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (a: DGis.ExtraInstructionInfo, b: DGis.ExtraInstructionInfo) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
}
public struct RouteInstruction : Swift.Hashable {
  public var roadName: Swift.String
  public var range: DGis.RouteDistance
  public var extraInstructionInfo: DGis.ExtraInstructionInfo
  public init(roadName: Swift.String, range: DGis.RouteDistance, extraInstructionInfo: DGis.ExtraInstructionInfo)
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (a: DGis.RouteInstruction, b: DGis.RouteInstruction) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
}
public struct InstructionRouteEntry : Swift.Hashable {
  public var point: DGis.RoutePoint
  public var value: DGis.RouteInstruction
  public init(point: DGis.RoutePoint, value: DGis.RouteInstruction)
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (a: DGis.InstructionRouteEntry, b: DGis.InstructionRouteEntry) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
}
public enum BicycleInstructionCrossroadManeuverDirection : Swift.UInt32 {
  case straight
  case left
  case right
  case sharplyLeft
  case sharplyRight
  case keepLeft
  case keepRight
  public init?(rawValue: Swift.UInt32)
  public typealias RawValue = Swift.UInt32
  public var rawValue: Swift.UInt32 {
    get
  }
}
public struct BicycleInstructionCrossroadManeuver : Swift.Hashable {
  public var direction: DGis.BicycleInstructionCrossroadManeuverDirection
  public var turnAngle: Swift.Int32
  public init(direction: DGis.BicycleInstructionCrossroadManeuverDirection = BicycleInstructionCrossroadManeuverDirection.straight, turnAngle: Swift.Int32 = 0)
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (a: DGis.BicycleInstructionCrossroadManeuver, b: DGis.BicycleInstructionCrossroadManeuver) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
}
public enum PedestrianInstructionCrossroadManeuverDirection : Swift.UInt32 {
  case straight
  case left
  case right
  case sharplyLeft
  case sharplyRight
  case keepLeft
  case keepRight
  public init?(rawValue: Swift.UInt32)
  public typealias RawValue = Swift.UInt32
  public var rawValue: Swift.UInt32 {
    get
  }
}
public struct PedestrianInstructionCrossroadManeuver : Swift.Hashable {
  public var direction: DGis.PedestrianInstructionCrossroadManeuverDirection
  public var turnAngle: Swift.Int32
  public init(direction: DGis.PedestrianInstructionCrossroadManeuverDirection = PedestrianInstructionCrossroadManeuverDirection.straight, turnAngle: Swift.Int32 = 0)
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (a: DGis.PedestrianInstructionCrossroadManeuver, b: DGis.PedestrianInstructionCrossroadManeuver) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
}
public enum ScooterInstructionCrossroadManeuverDirection : Swift.UInt32 {
  case straight
  case left
  case right
  case sharplyLeft
  case sharplyRight
  case keepLeft
  case keepRight
  public init?(rawValue: Swift.UInt32)
  public typealias RawValue = Swift.UInt32
  public var rawValue: Swift.UInt32 {
    get
  }
}
public struct ScooterInstructionCrossroadManeuver : Swift.Hashable {
  public var direction: DGis.ScooterInstructionCrossroadManeuverDirection
  public var turnAngle: Swift.Int32
  public init(direction: DGis.ScooterInstructionCrossroadManeuverDirection = ScooterInstructionCrossroadManeuverDirection.straight, turnAngle: Swift.Int32 = 0)
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (a: DGis.ScooterInstructionCrossroadManeuver, b: DGis.ScooterInstructionCrossroadManeuver) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
}
@_hasMissingDesignatedInitializers final public class DoubleRouteAttribute : Swift.Hashable {
  final public var size: Swift.UInt64 {
    get
  }
  final public var isEmpty: Swift.Bool {
    get
  }
  final public var first: DGis.DoubleRouteEntry? {
    get
  }
  final public var last: DGis.DoubleRouteEntry? {
    get
  }
  final public var entries: [DGis.DoubleRouteEntry] {
    get
  }
  @objc deinit
  public static func == (lhs: DGis.DoubleRouteAttribute, rhs: DGis.DoubleRouteAttribute) -> Swift.Bool
  final public func hash(into hasher: inout Swift.Hasher)
  final public func entries(begin: DGis.RoutePoint, end: DGis.RoutePoint) -> [DGis.DoubleRouteEntry]
  final public func findNearBackward(point: DGis.RoutePoint) -> DGis.DoubleRouteEntry?
  final public func findNearForward(point: DGis.RoutePoint) -> DGis.DoubleRouteEntry?
  final public var hashValue: Swift.Int {
    get
  }
}
public struct DoubleRouteEntry : Swift.Hashable {
  public var point: DGis.RoutePoint
  public var value: Swift.Double
  public init(point: DGis.RoutePoint, value: Swift.Double)
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (a: DGis.DoubleRouteEntry, b: DGis.DoubleRouteEntry) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
}
@_hasMissingDesignatedInitializers final public class BoolRouteLongAttribute : Swift.Hashable {
  final public var size: Swift.UInt64 {
    get
  }
  final public var isEmpty: Swift.Bool {
    get
  }
  final public var first: DGis.BoolRouteLongEntry? {
    get
  }
  final public var last: DGis.BoolRouteLongEntry? {
    get
  }
  final public var entries: [DGis.BoolRouteLongEntry] {
    get
  }
  @objc deinit
  public static func == (lhs: DGis.BoolRouteLongAttribute, rhs: DGis.BoolRouteLongAttribute) -> Swift.Bool
  final public func hash(into hasher: inout Swift.Hasher)
  final public func entry(point: DGis.RoutePoint) -> DGis.BoolRouteLongEntry?
  final public func entries(begin: DGis.RoutePoint, end: DGis.RoutePoint) -> [DGis.BoolRouteLongEntry]
  final public var hashValue: Swift.Int {
    get
  }
}
public struct BoolRouteLongEntry : Swift.Hashable {
  public var point: DGis.RoutePoint
  public var length: DGis.RouteDistance
  public var value: Swift.Bool
  public init(point: DGis.RoutePoint, length: DGis.RouteDistance, value: Swift.Bool)
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (a: DGis.BoolRouteLongEntry, b: DGis.BoolRouteLongEntry) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
}
@_hasMissingDesignatedInitializers final public class ObstacleInfoRouteAttribute : Swift.Hashable {
  final public var size: Swift.UInt64 {
    get
  }
  final public var isEmpty: Swift.Bool {
    get
  }
  final public var first: DGis.ObstacleInfoRouteEntry? {
    get
  }
  final public var last: DGis.ObstacleInfoRouteEntry? {
    get
  }
  final public var entries: [DGis.ObstacleInfoRouteEntry] {
    get
  }
  @objc deinit
  public static func == (lhs: DGis.ObstacleInfoRouteAttribute, rhs: DGis.ObstacleInfoRouteAttribute) -> Swift.Bool
  final public func hash(into hasher: inout Swift.Hasher)
  final public func entries(begin: DGis.RoutePoint, end: DGis.RoutePoint) -> [DGis.ObstacleInfoRouteEntry]
  final public func findNearBackward(point: DGis.RoutePoint) -> DGis.ObstacleInfoRouteEntry?
  final public func findNearForward(point: DGis.RoutePoint) -> DGis.ObstacleInfoRouteEntry?
  final public var hashValue: Swift.Int {
    get
  }
}
public enum Obstacle : Swift.UInt32 {
  case other
  case barrier
  case gate
  case tourniquet
  case wicket
  public init?(rawValue: Swift.UInt32)
  public typealias RawValue = Swift.UInt32
  public var rawValue: Swift.UInt32 {
    get
  }
}
public enum ObstaclePassLimitation : Swift.UInt32 {
  case unlimited
  case paid
  case passRequired
  public init?(rawValue: Swift.UInt32)
  public typealias RawValue = Swift.UInt32
  public var rawValue: Swift.UInt32 {
    get
  }
}
public struct ObstacleInfo : Swift.Hashable {
  public var type: DGis.Obstacle
  public var limitation: DGis.ObstaclePassLimitation
  public init(type: DGis.Obstacle = Obstacle.other, limitation: DGis.ObstaclePassLimitation = ObstaclePassLimitation.unlimited)
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (a: DGis.ObstacleInfo, b: DGis.ObstacleInfo) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
}
public struct ObstacleInfoRouteEntry : Swift.Hashable {
  public var point: DGis.RoutePoint
  public var value: DGis.ObstacleInfo
  public init(point: DGis.RoutePoint, value: DGis.ObstacleInfo)
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (a: DGis.ObstacleInfoRouteEntry, b: DGis.ObstacleInfoRouteEntry) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
}
@_hasMissingDesignatedInitializers final public class StringRouteLongAttribute : Swift.Hashable {
  final public var size: Swift.UInt64 {
    get
  }
  final public var isEmpty: Swift.Bool {
    get
  }
  final public var first: DGis.StringRouteLongEntry? {
    get
  }
  final public var last: DGis.StringRouteLongEntry? {
    get
  }
  final public var entries: [DGis.StringRouteLongEntry] {
    get
  }
  @objc deinit
  public static func == (lhs: DGis.StringRouteLongAttribute, rhs: DGis.StringRouteLongAttribute) -> Swift.Bool
  final public func hash(into hasher: inout Swift.Hasher)
  final public func entry(point: DGis.RoutePoint) -> DGis.StringRouteLongEntry?
  final public func entries(begin: DGis.RoutePoint, end: DGis.RoutePoint) -> [DGis.StringRouteLongEntry]
  final public var hashValue: Swift.Int {
    get
  }
}
public struct StringRouteLongEntry : Swift.Hashable {
  public var point: DGis.RoutePoint
  public var length: DGis.RouteDistance
  public var value: Swift.String
  public init(point: DGis.RoutePoint, length: DGis.RouteDistance, value: Swift.String)
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (a: DGis.StringRouteLongEntry, b: DGis.StringRouteLongEntry) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
}
@_hasMissingDesignatedInitializers final public class SettlementRouteLongAttribute : Swift.Hashable {
  final public var size: Swift.UInt64 {
    get
  }
  final public var isEmpty: Swift.Bool {
    get
  }
  final public var first: DGis.SettlementRouteLongEntry? {
    get
  }
  final public var last: DGis.SettlementRouteLongEntry? {
    get
  }
  final public var entries: [DGis.SettlementRouteLongEntry] {
    get
  }
  @objc deinit
  public static func == (lhs: DGis.SettlementRouteLongAttribute, rhs: DGis.SettlementRouteLongAttribute) -> Swift.Bool
  final public func hash(into hasher: inout Swift.Hasher)
  final public func entry(point: DGis.RoutePoint) -> DGis.SettlementRouteLongEntry?
  final public func entries(begin: DGis.RoutePoint, end: DGis.RoutePoint) -> [DGis.SettlementRouteLongEntry]
  final public var hashValue: Swift.Int {
    get
  }
}
public enum Settlement : Swift.UInt32 {
  case unknown
  case inside
  case outside
  public init?(rawValue: Swift.UInt32)
  public typealias RawValue = Swift.UInt32
  public var rawValue: Swift.UInt32 {
    get
  }
}
public struct SettlementRouteLongEntry : Swift.Hashable {
  public var point: DGis.RoutePoint
  public var length: DGis.RouteDistance
  public var value: DGis.Settlement
  public init(point: DGis.RoutePoint, length: DGis.RouteDistance, value: DGis.Settlement)
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (a: DGis.SettlementRouteLongEntry, b: DGis.SettlementRouteLongEntry) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
}
@_hasMissingDesignatedInitializers final public class TransportTypeRouteLongAttribute : Swift.Hashable {
  final public var size: Swift.UInt64 {
    get
  }
  final public var isEmpty: Swift.Bool {
    get
  }
  final public var first: DGis.TransportTypeRouteLongEntry? {
    get
  }
  final public var last: DGis.TransportTypeRouteLongEntry? {
    get
  }
  final public var entries: [DGis.TransportTypeRouteLongEntry] {
    get
  }
  @objc deinit
  public static func == (lhs: DGis.TransportTypeRouteLongAttribute, rhs: DGis.TransportTypeRouteLongAttribute) -> Swift.Bool
  final public func hash(into hasher: inout Swift.Hasher)
  final public func entry(point: DGis.RoutePoint) -> DGis.TransportTypeRouteLongEntry?
  final public func entries(begin: DGis.RoutePoint, end: DGis.RoutePoint) -> [DGis.TransportTypeRouteLongEntry]
  final public var hashValue: Swift.Int {
    get
  }
}
public enum TransportType : Swift.UInt32 {
  case unknown
  case bicycle
  case car
  case pedestrian
  case `public`
  case scooter
  public init?(rawValue: Swift.UInt32)
  public typealias RawValue = Swift.UInt32
  public var rawValue: Swift.UInt32 {
    get
  }
}
public struct TransportTypeRouteLongEntry : Swift.Hashable {
  public var point: DGis.RoutePoint
  public var length: DGis.RouteDistance
  public var value: DGis.TransportType
  public init(point: DGis.RoutePoint, length: DGis.RouteDistance, value: DGis.TransportType)
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (a: DGis.TransportTypeRouteLongEntry, b: DGis.TransportTypeRouteLongEntry) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
}
@_hasMissingDesignatedInitializers final public class CameraRouteAttribute : Swift.Hashable {
  final public var size: Swift.UInt64 {
    get
  }
  final public var isEmpty: Swift.Bool {
    get
  }
  final public var first: DGis.CameraRouteEntry? {
    get
  }
  final public var last: DGis.CameraRouteEntry? {
    get
  }
  final public var entries: [DGis.CameraRouteEntry] {
    get
  }
  @objc deinit
  public static func == (lhs: DGis.CameraRouteAttribute, rhs: DGis.CameraRouteAttribute) -> Swift.Bool
  final public func hash(into hasher: inout Swift.Hasher)
  final public func entries(begin: DGis.RoutePoint, end: DGis.RoutePoint) -> [DGis.CameraRouteEntry]
  final public func findNearBackward(point: DGis.RoutePoint) -> DGis.CameraRouteEntry?
  final public func findNearForward(point: DGis.RoutePoint) -> DGis.CameraRouteEntry?
  final public var hashValue: Swift.Int {
    get
  }
}
public enum RouteCameraPurpose : Swift.UInt32 {
  case speedControl
  case trafficLightsControl
  case stopLineControl
  case publicTransportLaneControl
  case oncomingTrafficLaneControl
  case pedestrianAdvantageControl
  case laneDisciplineControl
  case roadMarkingsCrossingControl
  case averageSpeedControl
  case noStoppingControl
  case dummy
  case platon
  public init?(rawValue: Swift.UInt32)
  public typealias RawValue = Swift.UInt32
  public var rawValue: Swift.UInt32 {
    get
  }
}
public struct RouteCameraPurposeOptionSet : Swift.OptionSet, Swift.Hashable {
  public var rawValue: Swift.UInt32
  public static let speedControl: DGis.RouteCameraPurposeOptionSet
  public static let trafficLightsControl: DGis.RouteCameraPurposeOptionSet
  public static let stopLineControl: DGis.RouteCameraPurposeOptionSet
  public static let publicTransportLaneControl: DGis.RouteCameraPurposeOptionSet
  public static let oncomingTrafficLaneControl: DGis.RouteCameraPurposeOptionSet
  public static let pedestrianAdvantageControl: DGis.RouteCameraPurposeOptionSet
  public static let laneDisciplineControl: DGis.RouteCameraPurposeOptionSet
  public static let roadMarkingsCrossingControl: DGis.RouteCameraPurposeOptionSet
  public static let averageSpeedControl: DGis.RouteCameraPurposeOptionSet
  public static let noStoppingControl: DGis.RouteCameraPurposeOptionSet
  public static let dummy: DGis.RouteCameraPurposeOptionSet
  public static let platon: DGis.RouteCameraPurposeOptionSet
  public init(rawValue: Swift.UInt32)
  public typealias ArrayLiteralElement = DGis.RouteCameraPurposeOptionSet
  public typealias Element = DGis.RouteCameraPurposeOptionSet
  public typealias RawValue = Swift.UInt32
}
public enum RouteCameraDirection : Swift.UInt32 {
  case against
  case along
  case both
  public init?(rawValue: Swift.UInt32)
  public typealias RawValue = Swift.UInt32
  public var rawValue: Swift.UInt32 {
    get
  }
}
public struct RouteCamera : Swift.Hashable {
  public var purposes: DGis.RouteCameraPurposeOptionSet
  public var rangeAgainst: DGis.RouteDistance
  public var rangeAlong: DGis.RouteDistance
  public var direction: DGis.RouteCameraDirection
  public init(purposes: DGis.RouteCameraPurposeOptionSet, rangeAgainst: DGis.RouteDistance, rangeAlong: DGis.RouteDistance, direction: DGis.RouteCameraDirection = RouteCameraDirection.against)
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (a: DGis.RouteCamera, b: DGis.RouteCamera) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
}
public struct CameraRouteEntry : Swift.Hashable {
  public var point: DGis.RoutePoint
  public var value: DGis.RouteCamera
  public init(point: DGis.RoutePoint, value: DGis.RouteCamera)
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (a: DGis.CameraRouteEntry, b: DGis.CameraRouteEntry) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
}
@_hasMissingDesignatedInitializers final public class UIntRouteLongAttribute : Swift.Hashable {
  final public var size: Swift.UInt64 {
    get
  }
  final public var isEmpty: Swift.Bool {
    get
  }
  final public var first: DGis.UIntRouteLongEntry? {
    get
  }
  final public var last: DGis.UIntRouteLongEntry? {
    get
  }
  final public var entries: [DGis.UIntRouteLongEntry] {
    get
  }
  @objc deinit
  public static func == (lhs: DGis.UIntRouteLongAttribute, rhs: DGis.UIntRouteLongAttribute) -> Swift.Bool
  final public func hash(into hasher: inout Swift.Hasher)
  final public func entry(point: DGis.RoutePoint) -> DGis.UIntRouteLongEntry?
  final public func entries(begin: DGis.RoutePoint, end: DGis.RoutePoint) -> [DGis.UIntRouteLongEntry]
  final public var hashValue: Swift.Int {
    get
  }
}
public struct UIntRouteLongEntry : Swift.Hashable {
  public var point: DGis.RoutePoint
  public var length: DGis.RouteDistance
  public var value: Swift.UInt32
  public init(point: DGis.RoutePoint, length: DGis.RouteDistance, value: Swift.UInt32)
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (a: DGis.UIntRouteLongEntry, b: DGis.UIntRouteLongEntry) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
}
@_hasMissingDesignatedInitializers final public class RouteExitSignRouteAttribute : Swift.Hashable {
  final public var size: Swift.UInt64 {
    get
  }
  final public var isEmpty: Swift.Bool {
    get
  }
  final public var first: DGis.RouteExitSignRouteEntry? {
    get
  }
  final public var last: DGis.RouteExitSignRouteEntry? {
    get
  }
  final public var entries: [DGis.RouteExitSignRouteEntry] {
    get
  }
  @objc deinit
  public static func == (lhs: DGis.RouteExitSignRouteAttribute, rhs: DGis.RouteExitSignRouteAttribute) -> Swift.Bool
  final public func hash(into hasher: inout Swift.Hasher)
  final public func entries(begin: DGis.RoutePoint, end: DGis.RoutePoint) -> [DGis.RouteExitSignRouteEntry]
  final public func findNearBackward(point: DGis.RoutePoint) -> DGis.RouteExitSignRouteEntry?
  final public func findNearForward(point: DGis.RoutePoint) -> DGis.RouteExitSignRouteEntry?
  final public var hashValue: Swift.Int {
    get
  }
}
public enum RouteExitSignType : Swift.UInt32 {
  case undefined
  case airport
  public init?(rawValue: Swift.UInt32)
  public typealias RawValue = Swift.UInt32
  public var rawValue: Swift.UInt32 {
    get
  }
}
public enum RouteExitSignTableColor : Swift.UInt32 {
  case undefined
  case white
  case red
  case green
  case blue
  case brown
  public init?(rawValue: Swift.UInt32)
  public typealias RawValue = Swift.UInt32
  public var rawValue: Swift.UInt32 {
    get
  }
}
public struct RouteExitSignTable : Swift.Hashable {
  public var backgroundColor: DGis.RouteExitSignTableColor
  public var text: Swift.String
  public init(backgroundColor: DGis.RouteExitSignTableColor = RouteExitSignTableColor.undefined, text: Swift.String)
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (a: DGis.RouteExitSignTable, b: DGis.RouteExitSignTable) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
}
public struct RouteExitSign : Swift.Hashable {
  public var type: DGis.RouteExitSignType
  public var roadNameTable: DGis.RouteExitSignTable
  public var roadNumberTable: DGis.RouteExitSignTable?
  public init(type: DGis.RouteExitSignType = RouteExitSignType.undefined, roadNameTable: DGis.RouteExitSignTable, roadNumberTable: DGis.RouteExitSignTable?)
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (a: DGis.RouteExitSign, b: DGis.RouteExitSign) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
}
public struct RouteExitSignRouteEntry : Swift.Hashable {
  public var point: DGis.RoutePoint
  public var value: DGis.RouteExitSign
  public init(point: DGis.RoutePoint, value: DGis.RouteExitSign)
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (a: DGis.RouteExitSignRouteEntry, b: DGis.RouteExitSignRouteEntry) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
}
@_hasMissingDesignatedInitializers final public class VoidRouteAttribute : Swift.Hashable {
  final public var size: Swift.UInt64 {
    get
  }
  final public var isEmpty: Swift.Bool {
    get
  }
  final public var first: DGis.RoutePoint? {
    get
  }
  final public var last: DGis.RoutePoint? {
    get
  }
  final public var entries: [DGis.RoutePoint] {
    get
  }
  @objc deinit
  public static func == (lhs: DGis.VoidRouteAttribute, rhs: DGis.VoidRouteAttribute) -> Swift.Bool
  final public func hash(into hasher: inout Swift.Hasher)
  final public func entries(begin: DGis.RoutePoint, end: DGis.RoutePoint) -> [DGis.RoutePoint]
  final public func findNearBackward(point: DGis.RoutePoint) -> DGis.RoutePoint?
  final public func findNearForward(point: DGis.RoutePoint) -> DGis.RoutePoint?
  final public var hashValue: Swift.Int {
    get
  }
}
@_hasMissingDesignatedInitializers final public class LaneSignRouteLongAttribute : Swift.Hashable {
  final public var size: Swift.UInt64 {
    get
  }
  final public var isEmpty: Swift.Bool {
    get
  }
  final public var first: DGis.LaneSignRouteLongEntry? {
    get
  }
  final public var last: DGis.LaneSignRouteLongEntry? {
    get
  }
  final public var entries: [DGis.LaneSignRouteLongEntry] {
    get
  }
  @objc deinit
  public static func == (lhs: DGis.LaneSignRouteLongAttribute, rhs: DGis.LaneSignRouteLongAttribute) -> Swift.Bool
  final public func hash(into hasher: inout Swift.Hasher)
  final public func entry(point: DGis.RoutePoint) -> DGis.LaneSignRouteLongEntry?
  final public func entries(begin: DGis.RoutePoint, end: DGis.RoutePoint) -> [DGis.LaneSignRouteLongEntry]
  final public var hashValue: Swift.Int {
    get
  }
}
public struct RouteLaneSign : Swift.Hashable {
  public var lanes: [DGis.RouteLane]
  public var signStartPoint: DGis.RoutePoint?
  public var signPoint: DGis.RoutePoint?
  public var signEndPoint: DGis.RoutePoint?
  public init(lanes: [DGis.RouteLane], signStartPoint: DGis.RoutePoint?, signPoint: DGis.RoutePoint?, signEndPoint: DGis.RoutePoint?)
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (a: DGis.RouteLaneSign, b: DGis.RouteLaneSign) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
}
public struct LaneSignRouteLongEntry : Swift.Hashable {
  public var point: DGis.RoutePoint
  public var length: DGis.RouteDistance
  public var value: DGis.RouteLaneSign
  public init(point: DGis.RoutePoint, length: DGis.RouteDistance, value: DGis.RouteLaneSign)
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (a: DGis.LaneSignRouteLongEntry, b: DGis.LaneSignRouteLongEntry) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
}
public enum RouteLaneManeuver : Swift.UInt32 {
  case undefined
  case forward
  case right
  case left
  case slightlyRight
  case slightlyLeft
  case sharplyRight
  case sharplyLeft
  case rightWithLeftTurns
  case turnover
  public init?(rawValue: Swift.UInt32)
  public typealias RawValue = Swift.UInt32
  public var rawValue: Swift.UInt32 {
    get
  }
}
public struct RouteLaneManeuverOptionSet : Swift.OptionSet, Swift.Hashable {
  public var rawValue: Swift.UInt32
  public static let undefined: DGis.RouteLaneManeuverOptionSet
  public static let forward: DGis.RouteLaneManeuverOptionSet
  public static let right: DGis.RouteLaneManeuverOptionSet
  public static let left: DGis.RouteLaneManeuverOptionSet
  public static let slightlyRight: DGis.RouteLaneManeuverOptionSet
  public static let slightlyLeft: DGis.RouteLaneManeuverOptionSet
  public static let sharplyRight: DGis.RouteLaneManeuverOptionSet
  public static let sharplyLeft: DGis.RouteLaneManeuverOptionSet
  public static let rightWithLeftTurns: DGis.RouteLaneManeuverOptionSet
  public static let turnover: DGis.RouteLaneManeuverOptionSet
  public init(rawValue: Swift.UInt32)
  public typealias ArrayLiteralElement = DGis.RouteLaneManeuverOptionSet
  public typealias Element = DGis.RouteLaneManeuverOptionSet
  public typealias RawValue = Swift.UInt32
}
public struct RouteLane : Swift.Hashable {
  public var routeManeuver: DGis.RouteLaneManeuver
  public var maneuvers: DGis.RouteLaneManeuverOptionSet
  public var speedLimit: Swift.Float
  public var prohibited: Swift.Bool
  public var onlyPublicTransport: Swift.Bool
  public init(routeManeuver: DGis.RouteLaneManeuver = RouteLaneManeuver.undefined, maneuvers: DGis.RouteLaneManeuverOptionSet, speedLimit: Swift.Float = 0, prohibited: Swift.Bool = false, onlyPublicTransport: Swift.Bool = false)
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (a: DGis.RouteLane, b: DGis.RouteLane) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
}
@_hasMissingDesignatedInitializers final public class RouteLevelInfoRouteLongAttribute : Swift.Hashable {
  final public var size: Swift.UInt64 {
    get
  }
  final public var isEmpty: Swift.Bool {
    get
  }
  final public var first: DGis.RouteLevelInfoRouteLongEntry? {
    get
  }
  final public var last: DGis.RouteLevelInfoRouteLongEntry? {
    get
  }
  final public var entries: [DGis.RouteLevelInfoRouteLongEntry] {
    get
  }
  @objc deinit
  public static func == (lhs: DGis.RouteLevelInfoRouteLongAttribute, rhs: DGis.RouteLevelInfoRouteLongAttribute) -> Swift.Bool
  final public func hash(into hasher: inout Swift.Hasher)
  final public func entry(point: DGis.RoutePoint) -> DGis.RouteLevelInfoRouteLongEntry?
  final public func entries(begin: DGis.RoutePoint, end: DGis.RoutePoint) -> [DGis.RouteLevelInfoRouteLongEntry]
  final public var hashValue: Swift.Int {
    get
  }
}
public struct RouteLevelInfo : Swift.Hashable {
  public var beginId: DGis.LevelId?
  public var endId: DGis.LevelId?
  public var name: Swift.String
  public init(beginId: DGis.LevelId?, endId: DGis.LevelId?, name: Swift.String)
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (a: DGis.RouteLevelInfo, b: DGis.RouteLevelInfo) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
}
public struct RouteLevelInfoRouteLongEntry : Swift.Hashable {
  public var point: DGis.RoutePoint
  public var length: DGis.RouteDistance
  public var value: DGis.RouteLevelInfo
  public init(point: DGis.RoutePoint, length: DGis.RouteDistance, value: DGis.RouteLevelInfo)
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (a: DGis.RouteLevelInfoRouteLongEntry, b: DGis.RouteLevelInfoRouteLongEntry) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
}
@_hasMissingDesignatedInitializers final public class FloatRouteLongAttribute : Swift.Hashable {
  final public var size: Swift.UInt64 {
    get
  }
  final public var isEmpty: Swift.Bool {
    get
  }
  final public var first: DGis.FloatRouteLongEntry? {
    get
  }
  final public var last: DGis.FloatRouteLongEntry? {
    get
  }
  final public var entries: [DGis.FloatRouteLongEntry] {
    get
  }
  @objc deinit
  public static func == (lhs: DGis.FloatRouteLongAttribute, rhs: DGis.FloatRouteLongAttribute) -> Swift.Bool
  final public func hash(into hasher: inout Swift.Hasher)
  final public func entry(point: DGis.RoutePoint) -> DGis.FloatRouteLongEntry?
  final public func entries(begin: DGis.RoutePoint, end: DGis.RoutePoint) -> [DGis.FloatRouteLongEntry]
  final public var hashValue: Swift.Int {
    get
  }
}
public struct FloatRouteLongEntry : Swift.Hashable {
  public var point: DGis.RoutePoint
  public var length: DGis.RouteDistance
  public var value: Swift.Float
  public init(point: DGis.RoutePoint, length: DGis.RouteDistance, value: Swift.Float)
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (a: DGis.FloatRouteLongEntry, b: DGis.FloatRouteLongEntry) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
}
@_hasMissingDesignatedInitializers final public class RoadRuleRouteLongAttribute : Swift.Hashable {
  final public var size: Swift.UInt64 {
    get
  }
  final public var isEmpty: Swift.Bool {
    get
  }
  final public var first: DGis.RoadRuleRouteLongEntry? {
    get
  }
  final public var last: DGis.RoadRuleRouteLongEntry? {
    get
  }
  final public var entries: [DGis.RoadRuleRouteLongEntry] {
    get
  }
  @objc deinit
  public static func == (lhs: DGis.RoadRuleRouteLongAttribute, rhs: DGis.RoadRuleRouteLongAttribute) -> Swift.Bool
  final public func hash(into hasher: inout Swift.Hasher)
  final public func entry(point: DGis.RoutePoint) -> DGis.RoadRuleRouteLongEntry?
  final public func entries(begin: DGis.RoutePoint, end: DGis.RoutePoint) -> [DGis.RoadRuleRouteLongEntry]
  final public var hashValue: Swift.Int {
    get
  }
}
public enum RoadRule : Swift.UInt32 {
  case unknown
  case rightHandTraffic
  case leftHandTraffic
  public init?(rawValue: Swift.UInt32)
  public typealias RawValue = Swift.UInt32
  public var rawValue: Swift.UInt32 {
    get
  }
}
public struct RoadRuleRouteLongEntry : Swift.Hashable {
  public var point: DGis.RoutePoint
  public var length: DGis.RouteDistance
  public var value: DGis.RoadRule
  public init(point: DGis.RoutePoint, length: DGis.RouteDistance, value: DGis.RoadRule)
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (a: DGis.RoadRuleRouteLongEntry, b: DGis.RoadRuleRouteLongEntry) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
}
@_hasMissingDesignatedInitializers final public class RoadSubtypeRouteLongAttribute : Swift.Hashable {
  final public var size: Swift.UInt64 {
    get
  }
  final public var isEmpty: Swift.Bool {
    get
  }
  final public var first: DGis.RoadSubtypeRouteLongEntry? {
    get
  }
  final public var last: DGis.RoadSubtypeRouteLongEntry? {
    get
  }
  final public var entries: [DGis.RoadSubtypeRouteLongEntry] {
    get
  }
  @objc deinit
  public static func == (lhs: DGis.RoadSubtypeRouteLongAttribute, rhs: DGis.RoadSubtypeRouteLongAttribute) -> Swift.Bool
  final public func hash(into hasher: inout Swift.Hasher)
  final public func entry(point: DGis.RoutePoint) -> DGis.RoadSubtypeRouteLongEntry?
  final public func entries(begin: DGis.RoutePoint, end: DGis.RoutePoint) -> [DGis.RoadSubtypeRouteLongEntry]
  final public var hashValue: Swift.Int {
    get
  }
}
public enum RoadSubtype : Swift.UInt32 {
  case none
  case archway
  case bridge
  case crosswalk
  case footbridge
  case ford
  case indoor
  case overgroundCrossing
  case parkFootpath
  case parkPath
  case residentialArea
  case stairwayUp
  case stairwayDown
  case subwayCrossing
  case tunnel
  case underpass
  public init?(rawValue: Swift.UInt32)
  public typealias RawValue = Swift.UInt32
  public var rawValue: Swift.UInt32 {
    get
  }
}
public struct RoadSubtypeRouteLongEntry : Swift.Hashable {
  public var point: DGis.RoutePoint
  public var length: DGis.RouteDistance
  public var value: DGis.RoadSubtype
  public init(point: DGis.RoutePoint, length: DGis.RouteDistance, value: DGis.RoadSubtype)
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (a: DGis.RoadSubtypeRouteLongEntry, b: DGis.RoadSubtypeRouteLongEntry) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
}
@_hasMissingDesignatedInitializers final public class RoadSurfaceRouteLongAttribute : Swift.Hashable {
  final public var size: Swift.UInt64 {
    get
  }
  final public var isEmpty: Swift.Bool {
    get
  }
  final public var first: DGis.RoadSurfaceRouteLongEntry? {
    get
  }
  final public var last: DGis.RoadSurfaceRouteLongEntry? {
    get
  }
  final public var entries: [DGis.RoadSurfaceRouteLongEntry] {
    get
  }
  @objc deinit
  public static func == (lhs: DGis.RoadSurfaceRouteLongAttribute, rhs: DGis.RoadSurfaceRouteLongAttribute) -> Swift.Bool
  final public func hash(into hasher: inout Swift.Hasher)
  final public func entry(point: DGis.RoutePoint) -> DGis.RoadSurfaceRouteLongEntry?
  final public func entries(begin: DGis.RoutePoint, end: DGis.RoutePoint) -> [DGis.RoadSurfaceRouteLongEntry]
  final public var hashValue: Swift.Int {
    get
  }
}
public enum RoadSurface : Swift.UInt32 {
  case unknown
  case asphalt
  case gravel
  case ground
  case concrete
  public init?(rawValue: Swift.UInt32)
  public typealias RawValue = Swift.UInt32
  public var rawValue: Swift.UInt32 {
    get
  }
}
public struct RoadSurfaceRouteLongEntry : Swift.Hashable {
  public var point: DGis.RoutePoint
  public var length: DGis.RouteDistance
  public var value: DGis.RoadSurface
  public init(point: DGis.RoutePoint, length: DGis.RouteDistance, value: DGis.RoadSurface)
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (a: DGis.RoadSurfaceRouteLongEntry, b: DGis.RoadSurfaceRouteLongEntry) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
}
@_hasMissingDesignatedInitializers final public class RoadTypeRouteLongAttribute : Swift.Hashable {
  final public var size: Swift.UInt64 {
    get
  }
  final public var isEmpty: Swift.Bool {
    get
  }
  final public var first: DGis.RoadTypeRouteLongEntry? {
    get
  }
  final public var last: DGis.RoadTypeRouteLongEntry? {
    get
  }
  final public var entries: [DGis.RoadTypeRouteLongEntry] {
    get
  }
  @objc deinit
  public static func == (lhs: DGis.RoadTypeRouteLongAttribute, rhs: DGis.RoadTypeRouteLongAttribute) -> Swift.Bool
  final public func hash(into hasher: inout Swift.Hasher)
  final public func entry(point: DGis.RoutePoint) -> DGis.RoadTypeRouteLongEntry?
  final public func entries(begin: DGis.RoutePoint, end: DGis.RoutePoint) -> [DGis.RoadTypeRouteLongEntry]
  final public var hashValue: Swift.Int {
    get
  }
}
public enum RoadType : Swift.UInt32 {
  case unknown
  case walkway
  case bikeway
  case pathway
  case fieldForestRoad
  case serviceRoad
  case otherStreetRoad
  case mainStreetRoad
  case highway
  case intercityRoad
  case federalRoad
  public init?(rawValue: Swift.UInt32)
  public typealias RawValue = Swift.UInt32
  public var rawValue: Swift.UInt32 {
    get
  }
}
public struct RoadTypeRouteLongEntry : Swift.Hashable {
  public var point: DGis.RoutePoint
  public var length: DGis.RouteDistance
  public var value: DGis.RoadType
  public init(point: DGis.RoutePoint, length: DGis.RouteDistance, value: DGis.RoadType)
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (a: DGis.RoadTypeRouteLongEntry, b: DGis.RoadTypeRouteLongEntry) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
}
@_hasMissingDesignatedInitializers final public class TruckPassZoneIdRouteLongAttribute : Swift.Hashable {
  final public var size: Swift.UInt64 {
    get
  }
  final public var isEmpty: Swift.Bool {
    get
  }
  final public var first: DGis.TruckPassZoneIdRouteLongEntry? {
    get
  }
  final public var last: DGis.TruckPassZoneIdRouteLongEntry? {
    get
  }
  final public var entries: [DGis.TruckPassZoneIdRouteLongEntry] {
    get
  }
  @objc deinit
  public static func == (lhs: DGis.TruckPassZoneIdRouteLongAttribute, rhs: DGis.TruckPassZoneIdRouteLongAttribute) -> Swift.Bool
  final public func hash(into hasher: inout Swift.Hasher)
  final public func entry(point: DGis.RoutePoint) -> DGis.TruckPassZoneIdRouteLongEntry?
  final public func entries(begin: DGis.RoutePoint, end: DGis.RoutePoint) -> [DGis.TruckPassZoneIdRouteLongEntry]
  final public var hashValue: Swift.Int {
    get
  }
}
public struct TruckPassZoneId : Swift.Hashable {
  public var value: Swift.UInt32
  public init(value: Swift.UInt32 = 0)
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (a: DGis.TruckPassZoneId, b: DGis.TruckPassZoneId) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
}
public struct TruckPassZoneIdRouteLongEntry : Swift.Hashable {
  public var point: DGis.RoutePoint
  public var length: DGis.RouteDistance
  public var value: DGis.TruckPassZoneId
  public init(point: DGis.RoutePoint, length: DGis.RouteDistance, value: DGis.TruckPassZoneId)
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (a: DGis.TruckPassZoneIdRouteLongEntry, b: DGis.TruckPassZoneIdRouteLongEntry) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
}
@_hasMissingDesignatedInitializers final public class PublicTransportTransferRouteLongAttribute : Swift.Hashable {
  final public var size: Swift.UInt64 {
    get
  }
  final public var isEmpty: Swift.Bool {
    get
  }
  final public var first: DGis.PublicTransportTransferRouteLongEntry? {
    get
  }
  final public var last: DGis.PublicTransportTransferRouteLongEntry? {
    get
  }
  final public var entries: [DGis.PublicTransportTransferRouteLongEntry] {
    get
  }
  @objc deinit
  public static func == (lhs: DGis.PublicTransportTransferRouteLongAttribute, rhs: DGis.PublicTransportTransferRouteLongAttribute) -> Swift.Bool
  final public func hash(into hasher: inout Swift.Hasher)
  final public func entry(point: DGis.RoutePoint) -> DGis.PublicTransportTransferRouteLongEntry?
  final public func entries(begin: DGis.RoutePoint, end: DGis.RoutePoint) -> [DGis.PublicTransportTransferRouteLongEntry]
  final public var hashValue: Swift.Int {
    get
  }
}
public struct PublicTransportTransfer : Swift.Hashable {
  public var startPointName: Swift.String
  public var finishPointName: Swift.String
  public var routeParts: [DGis.PublicRoutePart]
  public init(startPointName: Swift.String, finishPointName: Swift.String, routeParts: [DGis.PublicRoutePart])
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (a: DGis.PublicTransportTransfer, b: DGis.PublicTransportTransfer) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
}
public struct PublicTransportTransferRouteLongEntry : Swift.Hashable {
  public var point: DGis.RoutePoint
  public var length: DGis.RouteDistance
  public var value: DGis.PublicTransportTransfer
  public init(point: DGis.RoutePoint, length: DGis.RouteDistance, value: DGis.PublicTransportTransfer)
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (a: DGis.PublicTransportTransferRouteLongEntry, b: DGis.PublicTransportTransferRouteLongEntry) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
}
public struct PublicRoutePart : Swift.Hashable {
  public var transports: [DGis.PublicTransportInfo]
  public var intermediateStops: [DGis.PublicTransportStop]
  public init(transports: [DGis.PublicTransportInfo], intermediateStops: [DGis.PublicTransportStop])
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (a: DGis.PublicRoutePart, b: DGis.PublicRoutePart) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
}
public enum PublicTransportType : Swift.UInt32 {
  case bus
  case trolleybus
  case tram
  case shuttleBus
  case metro
  case suburbanTrain
  case funicularRailway
  case monorail
  case waterwayTransport
  case cableCar
  case speedTram
  case premetro
  case lightMetro
  case aeroexpress
  case moscowCentralRing
  case moscowCentralDiameters
  public init?(rawValue: Swift.UInt32)
  public typealias RawValue = Swift.UInt32
  public var rawValue: Swift.UInt32 {
    get
  }
}
public struct PublicTransportInfo : Swift.Hashable {
  public var type: DGis.PublicTransportType
  public var names: [Swift.String]
  public var suggestedCarNumbers: [Swift.UInt32]
  public var boardingSuggest: Swift.String
  public var color: Swift.UInt32?
  public var routeLogo: Swift.String
  public init(type: DGis.PublicTransportType = PublicTransportType.bus, names: [Swift.String], suggestedCarNumbers: [Swift.UInt32], boardingSuggest: Swift.String, color: Swift.UInt32?, routeLogo: Swift.String)
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (a: DGis.PublicTransportInfo, b: DGis.PublicTransportInfo) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
}
public struct PublicTransportStop : Swift.Hashable {
  public var name: Swift.String
  public var coordinates: DGis.GeoPoint
  public init(name: Swift.String, coordinates: DGis.GeoPoint)
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (a: DGis.PublicTransportStop, b: DGis.PublicTransportStop) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
}
@_hasMissingDesignatedInitializers final public class Traffic : Swift.Hashable {
  final public var durations: DGis.MillisecondsRouteAttribute {
    get
  }
  final public var speedColors: DGis.TrafficSpeedColorRouteLongAttribute {
    get
  }
  @objc deinit
  public static func == (lhs: DGis.Traffic, rhs: DGis.Traffic) -> Swift.Bool
  final public func hash(into hasher: inout Swift.Hasher)
  final public var hashValue: Swift.Int {
    get
  }
}
@_hasMissingDesignatedInitializers final public class MillisecondsRouteAttribute : Swift.Hashable {
  final public var size: Swift.UInt64 {
    get
  }
  final public var isEmpty: Swift.Bool {
    get
  }
  final public var first: DGis.MillisecondsRouteEntry? {
    get
  }
  final public var last: DGis.MillisecondsRouteEntry? {
    get
  }
  final public var entries: [DGis.MillisecondsRouteEntry] {
    get
  }
  @objc deinit
  public static func == (lhs: DGis.MillisecondsRouteAttribute, rhs: DGis.MillisecondsRouteAttribute) -> Swift.Bool
  final public func hash(into hasher: inout Swift.Hasher)
  final public func entries(begin: DGis.RoutePoint, end: DGis.RoutePoint) -> [DGis.MillisecondsRouteEntry]
  final public func findNearBackward(point: DGis.RoutePoint) -> DGis.MillisecondsRouteEntry?
  final public func findNearForward(point: DGis.RoutePoint) -> DGis.MillisecondsRouteEntry?
  final public func calculateDuration(routePoint: DGis.RoutePoint) -> Foundation.TimeInterval
  final public var hashValue: Swift.Int {
    get
  }
}
public struct MillisecondsRouteEntry : Swift.Hashable {
  public var point: DGis.RoutePoint
  public var value: Foundation.TimeInterval
  public init(point: DGis.RoutePoint, value: Foundation.TimeInterval)
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (a: DGis.MillisecondsRouteEntry, b: DGis.MillisecondsRouteEntry) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
}
@_hasMissingDesignatedInitializers final public class TrafficSpeedColorRouteLongAttribute : Swift.Hashable {
  final public var size: Swift.UInt64 {
    get
  }
  final public var isEmpty: Swift.Bool {
    get
  }
  final public var first: DGis.TrafficSpeedColorRouteLongEntry? {
    get
  }
  final public var last: DGis.TrafficSpeedColorRouteLongEntry? {
    get
  }
  final public var entries: [DGis.TrafficSpeedColorRouteLongEntry] {
    get
  }
  @objc deinit
  public static func == (lhs: DGis.TrafficSpeedColorRouteLongAttribute, rhs: DGis.TrafficSpeedColorRouteLongAttribute) -> Swift.Bool
  final public func hash(into hasher: inout Swift.Hasher)
  final public func entry(point: DGis.RoutePoint) -> DGis.TrafficSpeedColorRouteLongEntry?
  final public func entries(begin: DGis.RoutePoint, end: DGis.RoutePoint) -> [DGis.TrafficSpeedColorRouteLongEntry]
  final public var hashValue: Swift.Int {
    get
  }
}
public enum TrafficSpeedColor : Swift.UInt32 {
  case undefined
  case green
  case yellow
  case red
  case deepRed
  public init?(rawValue: Swift.UInt32)
  public typealias RawValue = Swift.UInt32
  public var rawValue: Swift.UInt32 {
    get
  }
}
public struct TrafficSpeedColorRouteLongEntry : Swift.Hashable {
  public var point: DGis.RoutePoint
  public var length: DGis.RouteDistance
  public var value: DGis.TrafficSpeedColor
  public init(point: DGis.RoutePoint, length: DGis.RouteDistance, value: DGis.TrafficSpeedColor)
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (a: DGis.TrafficSpeedColorRouteLongEntry, b: DGis.TrafficSpeedColorRouteLongEntry) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
}
public enum State : Swift.UInt32 {
  case disabled
  case navigation
  case routeSearch
  case finished
  public init?(rawValue: Swift.UInt32)
  public typealias RawValue = Swift.UInt32
  public var rawValue: Swift.UInt32 {
    get
  }
}
@_hasMissingDesignatedInitializers final public class PackedNavigationState : Swift.Hashable {
  final public var trafficRoute: DGis.TrafficRoute {
    get
    set(trafficRoute)
  }
  final public var finishPoint: DGis.RouteSearchPoint? {
    get
    set(finishPoint)
  }
  final public var routeSearchOptions: DGis.RouteSearchOptions? {
    get
    set(routeSearchOptions)
  }
  final public var routePosition: DGis.RoutePoint? {
    get
    set(routePosition)
  }
  final public var state: DGis.State {
    get
    set(state)
  }
  @objc deinit
  public static func == (lhs: DGis.PackedNavigationState, rhs: DGis.PackedNavigationState) -> Swift.Bool
  final public func hash(into hasher: inout Swift.Hasher)
  public static func of(trafficRoute: DGis.TrafficRoute, routeSearchOptions: DGis.RouteSearchOptions? = nil, finishPoint: DGis.RouteSearchPoint? = nil, routePosition: DGis.RoutePoint? = nil, state: DGis.State = State.disabled) -> DGis.PackedNavigationState
  public static func fromBytes(data: Foundation.Data) throws -> DGis.PackedNavigationState
  public static func fromModel(model: DGis.Model) -> DGis.PackedNavigationState
  final public func toBytes() -> Foundation.Data
  final public var hashValue: Swift.Int {
    get
  }
}
public struct BicycleRouteSearchOptions : Swift.Hashable {
  public var avoidCarRoads: Swift.Bool
  public var avoidStairways: Swift.Bool
  public var avoidUnderpassesAndOverpasses: Swift.Bool
  public var excludedAreas: [DGis.ExcludedArea]
  public init(avoidCarRoads: Swift.Bool = false, avoidStairways: Swift.Bool = false, avoidUnderpassesAndOverpasses: Swift.Bool = false, excludedAreas: [DGis.ExcludedArea] = [])
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (a: DGis.BicycleRouteSearchOptions, b: DGis.BicycleRouteSearchOptions) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
}
public enum RouteSearchType : Swift.UInt32 {
  case jam
  case statistic
  case shortest
  public init?(rawValue: Swift.UInt32)
  public typealias RawValue = Swift.UInt32
  public var rawValue: Swift.UInt32 {
    get
  }
}
public struct CarRouteSearchOptions : Swift.Hashable {
  public var avoidTollRoads: Swift.Bool
  public var avoidUnpavedRoads: Swift.Bool
  public var avoidFerries: Swift.Bool
  public var avoidLockedRoads: Swift.Bool
  public var routeSearchType: DGis.RouteSearchType
  public var excludedAreas: [DGis.ExcludedArea]
  public init(avoidTollRoads: Swift.Bool = false, avoidUnpavedRoads: Swift.Bool = false, avoidFerries: Swift.Bool = true, avoidLockedRoads: Swift.Bool = true, routeSearchType: DGis.RouteSearchType = RouteSearchType.jam, excludedAreas: [DGis.ExcludedArea] = [])
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (a: DGis.CarRouteSearchOptions, b: DGis.CarRouteSearchOptions) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
}
public struct PedestrianRouteSearchOptions : Swift.Hashable {
  public var avoidStairways: Swift.Bool
  public var avoidUnderpassesAndOverpasses: Swift.Bool
  public var useIndoor: Swift.Bool
  public var excludedAreas: [DGis.ExcludedArea]
  public init(avoidStairways: Swift.Bool = false, avoidUnderpassesAndOverpasses: Swift.Bool = false, useIndoor: Swift.Bool = true, excludedAreas: [DGis.ExcludedArea] = [])
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (a: DGis.PedestrianRouteSearchOptions, b: DGis.PedestrianRouteSearchOptions) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
}
public struct PublicTransportTypeOptionSet : Swift.OptionSet, Swift.Hashable {
  public var rawValue: Swift.UInt32
  public static let bus: DGis.PublicTransportTypeOptionSet
  public static let trolleybus: DGis.PublicTransportTypeOptionSet
  public static let tram: DGis.PublicTransportTypeOptionSet
  public static let shuttleBus: DGis.PublicTransportTypeOptionSet
  public static let metro: DGis.PublicTransportTypeOptionSet
  public static let suburbanTrain: DGis.PublicTransportTypeOptionSet
  public static let funicularRailway: DGis.PublicTransportTypeOptionSet
  public static let monorail: DGis.PublicTransportTypeOptionSet
  public static let waterwayTransport: DGis.PublicTransportTypeOptionSet
  public static let cableCar: DGis.PublicTransportTypeOptionSet
  public static let speedTram: DGis.PublicTransportTypeOptionSet
  public static let premetro: DGis.PublicTransportTypeOptionSet
  public static let lightMetro: DGis.PublicTransportTypeOptionSet
  public static let aeroexpress: DGis.PublicTransportTypeOptionSet
  public static let moscowCentralRing: DGis.PublicTransportTypeOptionSet
  public static let moscowCentralDiameters: DGis.PublicTransportTypeOptionSet
  public init(rawValue: Swift.UInt32)
  public typealias ArrayLiteralElement = DGis.PublicTransportTypeOptionSet
  public typealias Element = DGis.PublicTransportTypeOptionSet
  public typealias RawValue = Swift.UInt32
}
public struct PublicTransportRouteSearchOptions : Swift.Hashable {
  public var startTime: Foundation.Date?
  public var useSchedule: Swift.Bool
  public var transportTypes: DGis.PublicTransportTypeOptionSet
  public init(startTime: Foundation.Date? = nil, useSchedule: Swift.Bool = false, transportTypes: DGis.PublicTransportTypeOptionSet = [])
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (a: DGis.PublicTransportRouteSearchOptions, b: DGis.PublicTransportRouteSearchOptions) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
}
public struct ScooterRouteSearchOptions : Swift.Hashable {
  public var avoidCarRoads: Swift.Bool
  public var avoidStairways: Swift.Bool
  public var avoidUnderpassesAndOverpasses: Swift.Bool
  public var excludedAreas: [DGis.ExcludedArea]
  public init(avoidCarRoads: Swift.Bool = true, avoidStairways: Swift.Bool = true, avoidUnderpassesAndOverpasses: Swift.Bool = true, excludedAreas: [DGis.ExcludedArea] = [])
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (a: DGis.ScooterRouteSearchOptions, b: DGis.ScooterRouteSearchOptions) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
}
public struct TaxiRouteSearchOptions : Swift.Hashable {
  public var car: DGis.CarRouteSearchOptions
  public init(car: DGis.CarRouteSearchOptions)
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (a: DGis.TaxiRouteSearchOptions, b: DGis.TaxiRouteSearchOptions) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
}
public struct TruckRouteSearchOptions : Swift.Hashable {
  public var car: DGis.CarRouteSearchOptions
  public var truckLength: Swift.UInt32?
  public var truckHeight: Swift.UInt32?
  public var truckWidth: Swift.UInt32?
  public var actualMass: Swift.UInt32?
  public var maxPermittedMass: Swift.UInt32?
  public var axleLoad: Swift.UInt32?
  public var dangerousCargo: Swift.Bool
  public var explosiveCargo: Swift.Bool
  public var passIds: Swift.Set<DGis.TruckPassZonePassId>
  public var fallbackOnCar: Swift.Bool
  public init(car: DGis.CarRouteSearchOptions, truckLength: Swift.UInt32? = nil, truckHeight: Swift.UInt32? = nil, truckWidth: Swift.UInt32? = nil, actualMass: Swift.UInt32? = nil, maxPermittedMass: Swift.UInt32? = nil, axleLoad: Swift.UInt32? = nil, dangerousCargo: Swift.Bool = false, explosiveCargo: Swift.Bool = false, passIds: Swift.Set<DGis.TruckPassZonePassId> = [], fallbackOnCar: Swift.Bool = false)
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (a: DGis.TruckRouteSearchOptions, b: DGis.TruckRouteSearchOptions) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
}
public enum RouteSearchOptions : Swift.Hashable {
  case bicycle(DGis.BicycleRouteSearchOptions)
  case car(DGis.CarRouteSearchOptions)
  case pedestrian(DGis.PedestrianRouteSearchOptions)
  case publicTransport(DGis.PublicTransportRouteSearchOptions)
  case scooter(DGis.ScooterRouteSearchOptions)
  case taxi(DGis.TaxiRouteSearchOptions)
  case truck(DGis.TruckRouteSearchOptions)
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (a: DGis.RouteSearchOptions, b: DGis.RouteSearchOptions) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
}
public enum ExcludedAreaType : Swift.UInt32 {
  case point
  case polyline
  case polygon
  public init?(rawValue: Swift.UInt32)
  public typealias RawValue = Swift.UInt32
  public var rawValue: Swift.UInt32 {
    get
  }
}
public enum ExcludedAreaSeverity : Swift.UInt32 {
  case soft
  case hard
  public init?(rawValue: Swift.UInt32)
  public typealias RawValue = Swift.UInt32
  public var rawValue: Swift.UInt32 {
    get
  }
}
public struct ExcludedArea : Swift.Hashable {
  public var type: DGis.ExcludedAreaType
  public var severity: DGis.ExcludedAreaSeverity
  public var extent: DGis.RouteDistance
  public var points: [DGis.GeoPoint]
  public init(type: DGis.ExcludedAreaType = ExcludedAreaType.point, severity: DGis.ExcludedAreaSeverity = ExcludedAreaSeverity.soft, extent: DGis.RouteDistance, points: [DGis.GeoPoint])
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (a: DGis.ExcludedArea, b: DGis.ExcludedArea) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
}
public struct TruckPassZonePassId : Swift.Hashable {
  public var value: Swift.UInt32
  public init(value: Swift.UInt32 = 0)
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (a: DGis.TruckPassZonePassId, b: DGis.TruckPassZonePassId) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
}
public struct RouteSearchPoint : Swift.Hashable {
  public var coordinates: DGis.GeoPoint
  public var course: DGis.Bearing?
  public var objectId: DGis.DgisObjectId
  public var levelId: DGis.LevelId?
  public init(coordinates: DGis.GeoPoint, course: DGis.Bearing? = nil, objectId: DGis.DgisObjectId = DgisObjectId(objectId: 0, entranceId: 0), levelId: DGis.LevelId? = nil)
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (a: DGis.RouteSearchPoint, b: DGis.RouteSearchPoint) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
}
public enum BetterRouteResponse : Swift.UInt32 {
  case accept
  case reject
  case timeout
  public init?(rawValue: Swift.UInt32)
  public typealias RawValue = Swift.UInt32
  public var rawValue: Swift.UInt32 {
    get
  }
}
@_hasMissingDesignatedInitializers final public class Model : Swift.Hashable {
  final public var stateChannel: DGis.StatefulChannel<DGis.State> {
    get
  }
  final public var state: DGis.State {
    get
  }
  final public var locationChannel: DGis.StatefulChannel<DGis.Location?> {
    get
  }
  final public var location: DGis.Location? {
    get
  }
  final public var locationAvailableChannel: DGis.StatefulChannel<Swift.Bool> {
    get
  }
  final public var locationAvailable: Swift.Bool {
    get
  }
  final public var routeChannel: DGis.StatefulChannel<DGis.RouteInfo> {
    get
  }
  final public var route: DGis.RouteInfo {
    get
  }
  final public var dynamicRouteInfoChannel: DGis.StatefulChannel<DGis.DynamicRouteInfo> {
    get
  }
  final public var dynamicRouteInfo: DGis.DynamicRouteInfo {
    get
  }
  final public var routePositionChannel: DGis.StatefulChannel<DGis.RoutePoint?> {
    get
  }
  final public var routePosition: DGis.RoutePoint? {
    get
  }
  final public var exceedingMaxSpeedLimitChannel: DGis.StatefulChannel<Swift.Bool> {
    get
  }
  final public var exceedingMaxSpeedLimit: Swift.Bool {
    get
  }
  final public var betterRouteChannel: DGis.StatefulChannel<DGis.BetterRouteInfo?> {
    get
  }
  final public var betterRoute: DGis.BetterRouteInfo? {
    get
  }
  @objc deinit
  public static func == (lhs: DGis.Model, rhs: DGis.Model) -> Swift.Bool
  final public func hash(into hasher: inout Swift.Hasher)
  final public func betterRouteResponse(response: DGis.BetterRouteResponse)
  final public var hashValue: Swift.Int {
    get
  }
}
public struct LocationCoordinates : Swift.Hashable {
  public var value: DGis.GeoPoint
  public var accuracy: Swift.Double
  public init(value: DGis.GeoPoint, accuracy: Swift.Double)
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (a: DGis.LocationCoordinates, b: DGis.LocationCoordinates) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
}
public struct LocationFuzzyDouble : Swift.Hashable {
  public var value: Swift.Double
  public var accuracy: Swift.Double?
  public init(value: Swift.Double, accuracy: Swift.Double?)
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (a: DGis.LocationFuzzyDouble, b: DGis.LocationFuzzyDouble) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
}
public struct LocationCourse : Swift.Hashable {
  public var value: DGis.Bearing
  public var accuracy: DGis.Bearing?
  public init(value: DGis.Bearing, accuracy: DGis.Bearing?)
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (a: DGis.LocationCourse, b: DGis.LocationCourse) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
}
public struct Location : Swift.Hashable {
  public var coordinates: DGis.LocationCoordinates
  public var altitude: DGis.LocationFuzzyDouble?
  public var course: DGis.LocationCourse?
  public var groundSpeed: DGis.LocationFuzzyDouble?
  public var source: Swift.String
  public var timestamp: Foundation.TimeInterval
  public init(coordinates: DGis.LocationCoordinates, altitude: DGis.LocationFuzzyDouble?, course: DGis.LocationCourse?, groundSpeed: DGis.LocationFuzzyDouble?, source: Swift.String, timestamp: Foundation.TimeInterval)
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (a: DGis.Location, b: DGis.Location) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
}
public struct RouteBuildOptions : Swift.Hashable {
  public var finishPoint: DGis.RouteSearchPoint
  public var routeSearchOptions: DGis.RouteSearchOptions
  public init(finishPoint: DGis.RouteSearchPoint, routeSearchOptions: DGis.RouteSearchOptions)
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (a: DGis.RouteBuildOptions, b: DGis.RouteBuildOptions) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
}
public struct RouteInfo : Swift.Hashable {
  public var route: DGis.Route
  public var routeBuildOptions: DGis.RouteBuildOptions?
  public init(route: DGis.Route, routeBuildOptions: DGis.RouteBuildOptions?)
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (a: DGis.RouteInfo, b: DGis.RouteInfo) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
}
@_hasMissingDesignatedInitializers final public class RoadEventRouteAttribute : Swift.Hashable {
  final public var size: Swift.UInt64 {
    get
  }
  final public var isEmpty: Swift.Bool {
    get
  }
  final public var first: DGis.RoadEventRouteEntry? {
    get
  }
  final public var last: DGis.RoadEventRouteEntry? {
    get
  }
  final public var entries: [DGis.RoadEventRouteEntry] {
    get
  }
  @objc deinit
  public static func == (lhs: DGis.RoadEventRouteAttribute, rhs: DGis.RoadEventRouteAttribute) -> Swift.Bool
  final public func hash(into hasher: inout Swift.Hasher)
  final public func entries(begin: DGis.RoutePoint, end: DGis.RoutePoint) -> [DGis.RoadEventRouteEntry]
  final public func findNearBackward(point: DGis.RoutePoint) -> DGis.RoadEventRouteEntry?
  final public func findNearForward(point: DGis.RoutePoint) -> DGis.RoadEventRouteEntry?
  final public var hashValue: Swift.Int {
    get
  }
}
public struct DynamicRouteInfo : Swift.Hashable {
  public var roadEvents: DGis.RoadEventRouteAttribute
  public var traffic: DGis.Traffic
  public init(roadEvents: DGis.RoadEventRouteAttribute, traffic: DGis.Traffic)
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (a: DGis.DynamicRouteInfo, b: DGis.DynamicRouteInfo) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
}
public struct BriefRoadEvent : Swift.Hashable {
  public var id: Swift.UInt64
  public var eventType: DGis.RoadEventType
  public var lanes: DGis.LaneOptionSet
  public init(id: Swift.UInt64 = 0, eventType: DGis.RoadEventType = RoadEventType.other, lanes: DGis.LaneOptionSet)
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (a: DGis.BriefRoadEvent, b: DGis.BriefRoadEvent) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
}
public struct RoadEventRouteEntry : Swift.Hashable {
  public var point: DGis.RoutePoint
  public var value: DGis.BriefRoadEvent
  public init(point: DGis.RoutePoint, value: DGis.BriefRoadEvent)
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (a: DGis.RoadEventRouteEntry, b: DGis.RoadEventRouteEntry) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
}
public struct BetterRouteInfo : Swift.Hashable {
  public var trafficRoute: DGis.TrafficRoute
  public var startPoint: DGis.RoutePoint
  public init(trafficRoute: DGis.TrafficRoute, startPoint: DGis.RoutePoint)
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (a: DGis.BetterRouteInfo, b: DGis.BetterRouteInfo) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
}
public struct RouteIndex : Swift.Hashable {
  public var value: Swift.UInt64
  public init(value: Swift.UInt64 = 0)
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (a: DGis.RouteIndex, b: DGis.RouteIndex) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
}
public struct RouteMapObjectCalloutLabelFlagOptionSet : Swift.OptionSet, Swift.Hashable {
  public var rawValue: Swift.UInt32
  public static let duration: DGis.RouteMapObjectCalloutLabelFlagOptionSet
  public static let length: DGis.RouteMapObjectCalloutLabelFlagOptionSet
  public init(rawValue: Swift.UInt32)
  public typealias ArrayLiteralElement = DGis.RouteMapObjectCalloutLabelFlagOptionSet
  public typealias Element = DGis.RouteMapObjectCalloutLabelFlagOptionSet
  public typealias RawValue = Swift.UInt32
}
@_hasMissingDesignatedInitializers final public class RouteSourceSettings : Swift.Hashable {
  final public var largeScaleRingroadOffsetMeters: Swift.Float {
    get
    set(offset)
  }
  final public var smallScaleRingroadOffsetMeters: Swift.Float {
    get
    set(offset)
  }
  final public var calloutVisualizationMode: DGis.CalloutVisualizationMode {
    get
    set(mode)
  }
  @objc deinit
  public static func == (lhs: DGis.RouteSourceSettings, rhs: DGis.RouteSourceSettings) -> Swift.Bool
  final public func hash(into hasher: inout Swift.Hasher)
  final public func getLargeScaleMergeDistanceMeters(transportType: DGis.TransportType) -> Swift.Float
  final public func setLargeScaleMergeDistanceMeters(distance: Swift.Float, transportType: DGis.TransportType)
  final public func getSmallScaleMergeDistanceMeters(transportType: DGis.TransportType) -> Swift.Float
  final public func setSmallScaleMergeDistanceMeters(distance: Swift.Float, transportType: DGis.TransportType)
  final public func getLargeScaleCrossroadsOffsetMeters(transportType: DGis.TransportType) -> Swift.Float
  final public func setLargeScaleCrossroadsOffsetMeters(offset: Swift.Float, transportType: DGis.TransportType)
  final public func getSmallScaleCrossroadsOffsetMeters(transportType: DGis.TransportType) -> Swift.Float
  final public func setSmallScaleCrossroadsOffsetMeters(offset: Swift.Float, transportType: DGis.TransportType)
  final public var hashValue: Swift.Int {
    get
  }
}
@_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers final public class RouteEditorSource : DGis.Source {
  final public var objects: [DGis.RouteMapObject] {
    get
  }
  final public var routeSourceSettings: DGis.RouteSourceSettings {
    get
  }
  final public var activeDisplayFlags: DGis.RouteMapObjectDisplayFlagOptionSet? {
    get
    set(flags)
  }
  final public var inactiveDisplayFlags: DGis.RouteMapObjectDisplayFlagOptionSet? {
    get
    set(flags)
  }
  final public var activeCalloutLabelFlags: DGis.RouteMapObjectCalloutLabelFlagOptionSet? {
    get
    set(flags)
  }
  final public var inactiveCalloutLabelFlags: DGis.RouteMapObjectCalloutLabelFlagOptionSet? {
    get
    set(flags)
  }
  final public var calloutLabelDisplayMode: DGis.RouteMapObjectCalloutLabelDisplayMode {
    get
    set(mode)
  }
  final public var activePermanentDisplayFlags: DGis.RouteMapObjectPermanentDisplayFlagOptionSet? {
    get
    set(flags)
  }
  final public var inactivePermanentDisplayFlags: DGis.RouteMapObjectPermanentDisplayFlagOptionSet? {
    get
    set(flags)
  }
  convenience public init(context: DGis.Context, routeEditor: DGis.RouteEditor, activeDisplayFlags: DGis.RouteMapObjectDisplayFlagOptionSet? = nil, inactiveDisplayFlags: DGis.RouteMapObjectDisplayFlagOptionSet? = nil, activeCalloutLabelFlags: DGis.RouteMapObjectCalloutLabelFlagOptionSet? = nil, inactiveCalloutLabelFlags: DGis.RouteMapObjectCalloutLabelFlagOptionSet? = nil, calloutLabelDisplayMode: DGis.RouteMapObjectCalloutLabelDisplayMode = RouteMapObjectCalloutLabelDisplayMode.absoluteValues, activePermanentDisplayFlags: DGis.RouteMapObjectPermanentDisplayFlagOptionSet? = nil, inactivePermanentDisplayFlags: DGis.RouteMapObjectPermanentDisplayFlagOptionSet? = nil)
  final public func setRoutesVisible(visible: Swift.Bool)
  final public func setShowOnlyActiveRoute(showOnlyActiveRoute: Swift.Bool)
  final public func setPassedDistanceVisualization(passedDistanceVisualization: DGis.RouteMapObjectPassedDistanceVisualization)
  @objc deinit
}
@_hasMissingDesignatedInitializers final public class RouteEditor : Swift.Hashable {
  final public var routesInfoChannel: DGis.StatefulChannel<DGis.RouteEditorRoutesInfo> {
    get
  }
  final public var routesInfo: DGis.RouteEditorRoutesInfo {
    get
  }
  final public var activeRouteIndexChannel: DGis.StatefulChannel<DGis.RouteIndex?> {
    get
  }
  final public var activeRouteIndex: DGis.RouteIndex? {
    get
  }
  @objc deinit
  public static func == (lhs: DGis.RouteEditor, rhs: DGis.RouteEditor) -> Swift.Bool
  final public func hash(into hasher: inout Swift.Hasher)
  convenience public init(context: DGis.Context)
  final public func setRouteParams(routeParams: DGis.RouteEditorRouteParams)
  final public func setActiveRouteIndex(index: DGis.RouteIndex)
  final public var hashValue: Swift.Int {
    get
  }
}
public struct RouteEditorRouteParams : Swift.Hashable {
  public var startPoint: DGis.RouteSearchPoint
  public var finishPoint: DGis.RouteSearchPoint
  public var routeSearchOptions: DGis.RouteSearchOptions
  public var intermediatePoints: [DGis.RouteSearchPoint]
  public init(startPoint: DGis.RouteSearchPoint, finishPoint: DGis.RouteSearchPoint, routeSearchOptions: DGis.RouteSearchOptions, intermediatePoints: [DGis.RouteSearchPoint] = [])
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (a: DGis.RouteEditorRouteParams, b: DGis.RouteEditorRouteParams) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
}
public struct RouteEditorRoutesInfo : Swift.Hashable {
  public var routes: [DGis.TrafficRoute]
  public var routeParams: DGis.RouteEditorRouteParams
  public init(routes: [DGis.TrafficRoute], routeParams: DGis.RouteEditorRouteParams)
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (a: DGis.RouteEditorRoutesInfo, b: DGis.RouteEditorRoutesInfo) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
}
public enum RouteVisualizationType : Swift.UInt32 {
  case normal
  case navigation
  public init?(rawValue: Swift.UInt32)
  public typealias RawValue = Swift.UInt32
  public var rawValue: Swift.UInt32 {
    get
  }
}
@_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers final public class RouteMapObjectSource : DGis.Source {
  final public var objects: [DGis.RouteMapObject] {
    get
  }
  final public var routeSourceSettings: DGis.RouteSourceSettings {
    get
  }
  convenience public init(context: DGis.Context, routeVisualizationType: DGis.RouteVisualizationType = RouteVisualizationType.normal)
  final public func addObject(item: DGis.RouteMapObject)
  final public func removeObject(item: DGis.RouteMapObject)
  final public func replaceObject(oldObject: DGis.RouteMapObject, newObject: DGis.RouteMapObject)
  final public func clear()
  final public func replaceAllObjects(objects: [DGis.RouteMapObject])
  @objc deinit
}
@_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers final public class RouteInfoCalloutMapObject : DGis.MapObject {
  final public var route: DGis.TrafficRoute {
    get
  }
  final public var routeIndex: DGis.RouteIndex {
    get
  }
  final public var routePoint: DGis.RoutePoint {
    get
  }
  @objc deinit
}
public enum RoutePointKind : Swift.UInt32 {
  case start
  case finish
  case intermediate
  case camera
  case accident
  case roadWork
  case comment
  case roadRestriction
  case otherEvent
  case tollRoad
  case transportConnectionPoint
  case hump
  case gate
  case barrier
  case stairway
  case indoorInstruction
  case badRoad
  case publicTransportPlatform
  case ground
  case gravel
  case carRoad
  case bicycleRoad
  case bicycleLane
  case trafficLight
  public init?(rawValue: Swift.UInt32)
  public typealias RawValue = Swift.UInt32
  public var rawValue: Swift.UInt32 {
    get
  }
}
@_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers final public class RoutePointMapObject : DGis.MapObject {
  final public var route: DGis.TrafficRoute {
    get
  }
  final public var routeIndex: DGis.RouteIndex {
    get
  }
  final public var kind: DGis.RoutePointKind {
    get
  }
  final public var routePoint: DGis.RoutePoint {
    get
  }
  final public var pointChannel: DGis.StatefulChannel<DGis.GeoPoint> {
    get
  }
  final public var point: DGis.GeoPoint {
    get
    set(point)
  }
  @objc deinit
}
@_hasMissingDesignatedInitializers final public class IndoorDetector : Swift.Hashable {
  final public var indoorChannel: DGis.StatefulChannel<Swift.Bool> {
    get
  }
  final public var indoor: Swift.Bool {
    get
  }
  @objc deinit
  public static func == (lhs: DGis.IndoorDetector, rhs: DGis.IndoorDetector) -> Swift.Bool
  final public func hash(into hasher: inout Swift.Hasher)
  final public var hashValue: Swift.Int {
    get
  }
}
@_hasMissingDesignatedInitializers final public class NavigationFollowController : Swift.Hashable {
  final public var followReturnDelay: Foundation.TimeInterval {
    get
    set(delay)
  }
  final public var cameraBehaviour: DGis.CameraBehaviour {
    get
    set(cameraBehaviour)
  }
  @objc deinit
  public static func == (lhs: DGis.NavigationFollowController, rhs: DGis.NavigationFollowController) -> Swift.Bool
  final public func hash(into hasher: inout Swift.Hasher)
  final public func setFollow(follow: Swift.Bool)
  final public var hashValue: Swift.Int {
    get
  }
}
@_hasMissingDesignatedInitializers final public class MapLocationController : Swift.Hashable {
  final public var myLocationIndicatorController: DGis.MyLocationController {
    get
  }
  final public var mapToNorthOrientation: Swift.Bool {
    get
    set(enable)
  }
  @objc deinit
  public static func == (lhs: DGis.MapLocationController, rhs: DGis.MapLocationController) -> Swift.Bool
  final public func hash(into hasher: inout Swift.Hasher)
  final public var hashValue: Swift.Int {
    get
  }
}
@_hasMissingDesignatedInitializers final public class MapManager : Swift.Hashable {
  @objc deinit
  public static func == (lhs: DGis.MapManager, rhs: DGis.MapManager) -> Swift.Bool
  final public func hash(into hasher: inout Swift.Hasher)
  final public func addMap(map: DGis.Map)
  final public func removeMap(map: DGis.Map)
  final public var hashValue: Swift.Int {
    get
  }
}
public struct SpeedRange : Swift.Hashable {
  public var minSpeed: Swift.Double
  public var maxSpeed: Swift.Double
  public init(minSpeed: Swift.Double = 0, maxSpeed: Swift.Double = 0)
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (a: DGis.SpeedRange, b: DGis.SpeedRange) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
}
public struct SpeedRangeToStyleZoom : Swift.Hashable {
  public var range: DGis.SpeedRange
  public var minDistanceToManeuver: DGis.RouteDistance
  public var maxDistanceToManeuver: DGis.RouteDistance
  public var styleZoom: DGis.StyleZoom
  public init(range: DGis.SpeedRange, minDistanceToManeuver: DGis.RouteDistance, maxDistanceToManeuver: DGis.RouteDistance, styleZoom: DGis.StyleZoom)
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (a: DGis.SpeedRangeToStyleZoom, b: DGis.SpeedRangeToStyleZoom) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
}
@_hasMissingDesignatedInitializers final public class ZoomFollowSettings : Swift.Hashable {
  final public var speedRangeToStyleZoomSequence: [DGis.SpeedRangeToStyleZoom] {
    get
    set(sequence)
  }
  final public var speedRangeToStyleZoomFreeRoamSequence: [DGis.SpeedRangeToStyleZoom] {
    get
  }
  final public var styleZoomSpeedRangesAnimationDuration: Foundation.TimeInterval {
    get
    set(duration)
  }
  final public var zoomInBeforeManeuverAnimationDuration: Foundation.TimeInterval {
    get
    set(duration)
  }
  final public var zoomOutAfterManeuverAnimationDuration: Foundation.TimeInterval {
    get
    set(duration)
  }
  final public var minSpeedToConsiderInZoomInBeforeManeuverAnimation: Swift.Double {
    get
    set(speed)
  }
  final public var zoomInBeforeManeuverAnimationAcceleration: Swift.Double {
    get
    set(acceleration)
  }
  final public var distanceGapToManeuver: DGis.RouteDistance {
    get
    set(distance)
  }
  final public var minAnimationDuration: Foundation.TimeInterval {
    get
    set(duration)
  }
  @objc deinit
  public static func == (lhs: DGis.ZoomFollowSettings, rhs: DGis.ZoomFollowSettings) -> Swift.Bool
  final public func hash(into hasher: inout Swift.Hasher)
  final public var hashValue: Swift.Int {
    get
  }
}
@_hasMissingDesignatedInitializers final public class RouteMapSettings : Swift.Hashable {
  final public var onRouteDisplayFlags: DGis.RouteMapObjectDisplayFlagOptionSet {
    get
    set(displayFlags)
  }
  final public var freeRoamDisplayFlags: DGis.RouteMapObjectDisplayFlagOptionSet {
    get
    set(displayFlags)
  }
  final public var onRoutePermanentDisplayFlags: DGis.RouteMapObjectPermanentDisplayFlagOptionSet {
    get
    set(flags)
  }
  final public var freeRoamPermanentDisplayFlags: DGis.RouteMapObjectPermanentDisplayFlagOptionSet {
    get
    set(flags)
  }
  @objc deinit
  public static func == (lhs: DGis.RouteMapSettings, rhs: DGis.RouteMapSettings) -> Swift.Bool
  final public func hash(into hasher: inout Swift.Hasher)
  final public var hashValue: Swift.Int {
    get
  }
}
public struct SimulationConstantSpeed : Swift.Hashable {
  public var speed: Swift.Double
  public init(speed: Swift.Double = 0)
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (a: DGis.SimulationConstantSpeed, b: DGis.SimulationConstantSpeed) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
}
public struct SimulationAutoWithOverSpeed : Swift.Hashable {
  public var overSpeed: Swift.Double
  public init(overSpeed: Swift.Double = 0)
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (a: DGis.SimulationAutoWithOverSpeed, b: DGis.SimulationAutoWithOverSpeed) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
}
public enum SimulationSpeedMode : Swift.Hashable {
  case speed(DGis.SimulationConstantSpeed)
  case overSpeed(DGis.SimulationAutoWithOverSpeed)
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (a: DGis.SimulationSpeedMode, b: DGis.SimulationSpeedMode) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
}
@_hasMissingDesignatedInitializers final public class SimulationSettings : Swift.Hashable {
  final public var speedMode: DGis.SimulationSpeedMode {
    get
    set(mode)
  }
  @objc deinit
  public static func == (lhs: DGis.SimulationSettings, rhs: DGis.SimulationSettings) -> Swift.Bool
  final public func hash(into hasher: inout Swift.Hasher)
  final public var hashValue: Swift.Int {
    get
  }
}
@_hasMissingDesignatedInitializers final public class NavigationVoice : Swift.Hashable {
  @objc deinit
  public static func == (lhs: DGis.NavigationVoice, rhs: DGis.NavigationVoice) -> Swift.Bool
  final public func hash(into hasher: inout Swift.Hasher)
  final public var hashValue: Swift.Int {
    get
  }
}
@_hasMissingDesignatedInitializers final public class VoiceSelector : Swift.Hashable {
  final public var voice: DGis.NavigationVoice? {
    get
    set(voice)
  }
  @objc deinit
  public static func == (lhs: DGis.VoiceSelector, rhs: DGis.VoiceSelector) -> Swift.Bool
  final public func hash(into hasher: inout Swift.Hasher)
  final public var hashValue: Swift.Int {
    get
  }
}
@_hasMissingDesignatedInitializers final public class ExceedSpeedLimitSettings : Swift.Hashable {
  final public var exceedSpeedNotificationEnabled: Swift.Bool {
    get
    set(enabled)
  }
  final public var allowableSpeedExcess: Swift.Float {
    get
    set(excess)
  }
  @objc deinit
  public static func == (lhs: DGis.ExceedSpeedLimitSettings, rhs: DGis.ExceedSpeedLimitSettings) -> Swift.Bool
  final public func hash(into hasher: inout Swift.Hasher)
  final public var hashValue: Swift.Int {
    get
  }
}
@_hasMissingDesignatedInitializers final public class DynamicRouteInfoSettings : Swift.Hashable {
  final public var updatePeriod: Foundation.TimeInterval {
    get
    set(period)
  }
  @objc deinit
  public static func == (lhs: DGis.DynamicRouteInfoSettings, rhs: DGis.DynamicRouteInfoSettings) -> Swift.Bool
  final public func hash(into hasher: inout Swift.Hasher)
  final public var hashValue: Swift.Int {
    get
  }
}
public enum SoundCategory : Swift.UInt32 {
  case crossroadCameras
  case laneCameras
  case noStoppingControlCameras
  case roadMarkingCameras
  case averageSpeedCameras
  case maxSpeedCameras
  case accidents
  case roadWorks
  case tolls
  case exceedSpeedLimits
  case intermediatePoints
  case routeRebuild
  case instructions
  case obstacles
  case roadSubtypes
  case lostLocation
  case routeEnd
  public init?(rawValue: Swift.UInt32)
  public typealias RawValue = Swift.UInt32
  public var rawValue: Swift.UInt32 {
    get
  }
}
@_hasMissingDesignatedInitializers final public class SoundNotificationSettings : Swift.Hashable {
  final public var enabledSoundCategories: DGis.SoundCategoryOptionSet {
    get
    set(soundCategories)
  }
  @objc deinit
  public static func == (lhs: DGis.SoundNotificationSettings, rhs: DGis.SoundNotificationSettings) -> Swift.Bool
  final public func hash(into hasher: inout Swift.Hasher)
  final public var hashValue: Swift.Int {
    get
  }
}
public struct SoundCategoryOptionSet : Swift.OptionSet, Swift.Hashable {
  public var rawValue: Swift.UInt32
  public static let crossroadCameras: DGis.SoundCategoryOptionSet
  public static let laneCameras: DGis.SoundCategoryOptionSet
  public static let noStoppingControlCameras: DGis.SoundCategoryOptionSet
  public static let roadMarkingCameras: DGis.SoundCategoryOptionSet
  public static let averageSpeedCameras: DGis.SoundCategoryOptionSet
  public static let maxSpeedCameras: DGis.SoundCategoryOptionSet
  public static let accidents: DGis.SoundCategoryOptionSet
  public static let roadWorks: DGis.SoundCategoryOptionSet
  public static let tolls: DGis.SoundCategoryOptionSet
  public static let exceedSpeedLimits: DGis.SoundCategoryOptionSet
  public static let intermediatePoints: DGis.SoundCategoryOptionSet
  public static let routeRebuild: DGis.SoundCategoryOptionSet
  public static let instructions: DGis.SoundCategoryOptionSet
  public static let obstacles: DGis.SoundCategoryOptionSet
  public static let roadSubtypes: DGis.SoundCategoryOptionSet
  public static let lostLocation: DGis.SoundCategoryOptionSet
  public static let routeEnd: DGis.SoundCategoryOptionSet
  public init(rawValue: Swift.UInt32)
  public typealias ArrayLiteralElement = DGis.SoundCategoryOptionSet
  public typealias Element = DGis.SoundCategoryOptionSet
  public typealias RawValue = Swift.UInt32
}
@_hasMissingDesignatedInitializers final public class FreeRoamSettings : Swift.Hashable {
  final public var onRoutePrefetchLength: DGis.RouteDistance {
    get
    set(length)
  }
  final public var onRoutePrefetchRadiusMeters: Swift.Double {
    get
    set(radius)
  }
  final public var prefetchRadiusMeters: Swift.Double {
    get
    set(radius)
  }
  @objc deinit
  public static func == (lhs: DGis.FreeRoamSettings, rhs: DGis.FreeRoamSettings) -> Swift.Bool
  final public func hash(into hasher: inout Swift.Hasher)
  final public var hashValue: Swift.Int {
    get
  }
}
@_hasMissingDesignatedInitializers final public class AlternativeRoutesProviderSettings : Swift.Hashable {
  final public var alternativeRoutesEnabled: Swift.Bool {
    get
    set(enabled)
  }
  final public var betterRouteEnabled: Swift.Bool {
    get
    set(enabled)
  }
  final public var routeSearchDelay: Foundation.TimeInterval {
    get
    set(delay)
  }
  final public var betterRouteTimeCostThreshold: Foundation.TimeInterval {
    get
    set(threshold)
  }
  final public var betterRouteLengthThreshold: DGis.RouteDistance {
    get
    set(threshold)
  }
  @objc deinit
  public static func == (lhs: DGis.AlternativeRoutesProviderSettings, rhs: DGis.AlternativeRoutesProviderSettings) -> Swift.Bool
  final public func hash(into hasher: inout Swift.Hasher)
  final public var hashValue: Swift.Int {
    get
  }
}
@_hasMissingDesignatedInitializers final public class AlternativeRouteSelector : Swift.Hashable {
  @objc deinit
  public static func == (lhs: DGis.AlternativeRouteSelector, rhs: DGis.AlternativeRouteSelector) -> Swift.Bool
  final public func hash(into hasher: inout Swift.Hasher)
  final public func selectAlternativeRoute(trafficRoute: DGis.TrafficRoute)
  final public var hashValue: Swift.Int {
    get
  }
}
@_hasMissingDesignatedInitializers final public class NavigationManager : Swift.Hashable {
  final public var uiModel: DGis.Model {
    get
  }
  final public var indoorDetector: DGis.IndoorDetector {
    get
  }
  final public var mapFollowController: DGis.NavigationFollowController {
    get
  }
  final public var mapLocationController: DGis.MapLocationController {
    get
  }
  final public var mapManager: DGis.MapManager {
    get
  }
  final public var zoomFollowSettings: DGis.ZoomFollowSettings {
    get
  }
  final public var routeMapSettings: DGis.RouteMapSettings {
    get
  }
  final public var routeSourceSettings: DGis.RouteSourceSettings {
    get
  }
  final public var simulationSettings: DGis.SimulationSettings {
    get
  }
  final public var voiceSelector: DGis.VoiceSelector {
    get
  }
  final public var exceedSpeedLimitSettings: DGis.ExceedSpeedLimitSettings {
    get
  }
  final public var dynamicRouteInfoSettings: DGis.DynamicRouteInfoSettings {
    get
  }
  final public var soundNotificationSettings: DGis.SoundNotificationSettings {
    get
  }
  final public var freeRoamSettings: DGis.FreeRoamSettings {
    get
  }
  final public var alternativeRoutesProviderSettings: DGis.AlternativeRoutesProviderSettings {
    get
  }
  final public var alternativeRouteSelector: DGis.AlternativeRouteSelector {
    get
  }
  @objc deinit
  public static func == (lhs: DGis.NavigationManager, rhs: DGis.NavigationManager) -> Swift.Bool
  final public func hash(into hasher: inout Swift.Hasher)
  convenience public init(platformContext: DGis.Context) throws
  final public func start() throws
  final public func start(routeBuildOptions: DGis.RouteBuildOptions, trafficRoute: DGis.TrafficRoute? = nil) throws
  final public func startSimulation(routeBuildOptions: DGis.RouteBuildOptions, trafficRoute: DGis.TrafficRoute) throws
  final public func stop()
  final public var hashValue: Swift.Int {
    get
  }
}
public enum InstructionManeuver : Swift.UInt32 {
  case none
  case start
  case finish
  case crossroadStraight
  case crossroadSlightlyLeft
  case crossroadLeft
  case crossroadSharplyLeft
  case crossroadSlightlyRight
  case crossroadRight
  case crossroadSharplyRight
  case crossroadKeepLeft
  case crossroadKeepRight
  case crossroadUTurn
  case roundaboutForward
  case roundaboutLeft45
  case roundaboutLeft90
  case roundaboutLeft135
  case roundaboutRight45
  case roundaboutRight90
  case roundaboutRight135
  case roundaboutBackward
  case roundaboutExit
  case uTurn
  case roadCrossing
  public init?(rawValue: Swift.UInt32)
  public typealias RawValue = Swift.UInt32
  public var rawValue: Swift.UInt32 {
    get
  }
}
public func getInstructionManeuver(extraInstructionInfo: DGis.ExtraInstructionInfo) -> DGis.InstructionManeuver
public func getLanesControlImages(laneSign: DGis.RouteLaneSign, maxCount: Swift.UInt32, ignoreActiveManeuver: Swift.Bool) -> [DGis.LanesControlImage]
public enum LanesControlImage : Swift.UInt32 {
  case dotsLeft
  case dotsRight
  case nonInformation
  case separator
  case prohibited_0
  case prohibited_1
  case publicTransport_0
  case publicTransport_1
  case left_0
  case left_1
  case left_Right_0_0
  case left_Right_0_1
  case left_Right_1_0
  case left_Right_1_1
  case left_SlightlyLeft_0_0
  case left_SlightlyLeft_0_1
  case left_SlightlyLeft_1_0
  case left_SlightlyLeft_1_1
  case left_SlightlyRight_0_0
  case left_SlightlyRight_0_1
  case left_SlightlyRight_1_0
  case left_SlightlyRight_1_1
  case left_Forward_0_0
  case left_Forward_0_1
  case left_Forward_1_0
  case left_Forward_1_1
  case left_Forward_Right_0_0_0
  case left_Forward_Right_0_0_1
  case left_Forward_Right_0_1_0
  case left_Forward_Right_1_0_0
  case left_Forward_Right_1_1_1
  case rightWithLeftTurn_0
  case rightWithLeftTurn_1
  case right_0
  case right_1
  case right_SharplyRight_0_0
  case right_SharplyRight_0_1
  case right_SharplyRight_1_0
  case right_SharplyRight_1_1
  case sharplyLeft_0
  case sharplyLeft_1
  case sharplyLeft_Left_0_0
  case sharplyLeft_Left_0_1
  case sharplyLeft_Left_1_0
  case sharplyLeft_Left_1_1
  case sharplyLeft_SlightlyLeft_0_0
  case sharplyLeft_SlightlyLeft_0_1
  case sharplyLeft_SlightlyLeft_1_0
  case sharplyLeft_SlightlyLeft_1_1
  case sharplyLeft_SlightlyRight_0_0
  case sharplyLeft_SlightlyRight_0_1
  case sharplyLeft_SlightlyRight_1_0
  case sharplyLeft_SlightlyRight_1_1
  case sharplyLeft_Forward_0_0
  case sharplyLeft_Forward_0_1
  case sharplyLeft_Forward_1_0
  case sharplyLeft_Forward_1_1
  case sharplyRight_0
  case sharplyRight_1
  case slightlyLeft_0
  case slightlyLeft_1
  case slightlyLeft_Right_0_0
  case slightlyLeft_Right_0_1
  case slightlyLeft_Right_1_0
  case slightlyLeft_Right_1_1
  case slightlyLeft_SharplyRight_0_0
  case slightlyLeft_SharplyRight_0_1
  case slightlyLeft_SharplyRight_1_0
  case slightlyLeft_SharplyRight_1_1
  case slightlyLeft_SlightlyRight_0_0
  case slightlyLeft_SlightlyRight_0_1
  case slightlyLeft_SlightlyRight_1_0
  case slightlyLeft_SlightlyRight_1_1
  case slightlyLeft_Forward_0_0
  case slightlyLeft_Forward_0_1
  case slightlyLeft_Forward_1_0
  case slightlyLeft_Forward_1_1
  case slightlyRight_0
  case slightlyRight_1
  case slightlyRight_Right_0_0
  case slightlyRight_Right_0_1
  case slightlyRight_Right_1_0
  case slightlyRight_Right_1_1
  case slightlyRight_SharplyRight_0_0
  case slightlyRight_SharplyRight_0_1
  case slightlyRight_SharplyRight_1_0
  case slightlyRight_SharplyRight_1_1
  case forward_0
  case forward_1
  case forward_RightWithLeftTurn_0_0
  case forward_RightWithLeftTurn_0_1
  case forward_RightWithLeftTurn_1_0
  case forward_RightWithLeftTurn_1_1
  case forward_Right_0_0
  case forward_Right_0_1
  case forward_Right_1_0
  case forward_Right_1_1
  case forward_SharplyRight_0_0
  case forward_SharplyRight_0_1
  case forward_SharplyRight_1_0
  case forward_SharplyRight_1_1
  case forward_SlightlyRight_0_0
  case forward_SlightlyRight_0_1
  case forward_SlightlyRight_1_0
  case forward_SlightlyRight_1_1
  case turnover_0
  case turnover_1
  public init?(rawValue: Swift.UInt32)
  public typealias RawValue = Swift.UInt32
  public var rawValue: Swift.UInt32 {
    get
  }
}
public func getVoiceManager(context: DGis.Context) -> DGis.VoiceManager
@_hasMissingDesignatedInitializers final public class VoiceManager : Swift.Hashable {
  final public var voicesChannel: DGis.StatefulChannel<[DGis.Voice]> {
    get
  }
  final public var voices: [DGis.Voice] {
    get
  }
  @objc deinit
  public static func == (lhs: DGis.VoiceManager, rhs: DGis.VoiceManager) -> Swift.Bool
  final public func hash(into hasher: inout Swift.Hasher)
  final public var hashValue: Swift.Int {
    get
  }
}
@_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers final public class Voice : DGis.Package {
  final public var navigationVoice: DGis.NavigationVoice {
    get
  }
  final public var language: Swift.String {
    get
  }
  @objc deinit
}
@_hasMissingDesignatedInitializers final public class ActivityTracker : Swift.Hashable {
  final public var stopChannel: DGis.StatefulChannel<Swift.Bool> {
    get
  }
  final public var stop: Swift.Bool {
    get
  }
  @objc deinit
  public static func == (lhs: DGis.ActivityTracker, rhs: DGis.ActivityTracker) -> Swift.Bool
  final public func hash(into hasher: inout Swift.Hasher)
  convenience public init(platformContext: DGis.Context, model: DGis.Model, speedBound: Swift.Double = 4.2, timeThreshold: Foundation.TimeInterval = 20)
  final public var hashValue: Swift.Int {
    get
  }
}
public struct CameraProgressInfo : Swift.Hashable {
  public var camera: DGis.RouteCamera
  public var position: DGis.RoutePoint
  public var progress: Swift.Float
  public init(camera: DGis.RouteCamera, position: DGis.RoutePoint, progress: Swift.Float = 0)
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (a: DGis.CameraProgressInfo, b: DGis.CameraProgressInfo) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
}
@_hasMissingDesignatedInitializers final public class CameraNotifier : Swift.Hashable {
  final public var cameraProgressChannel: DGis.StatefulChannel<DGis.CameraProgressInfo?> {
    get
  }
  final public var cameraProgress: DGis.CameraProgressInfo? {
    get
  }
  @objc deinit
  public static func == (lhs: DGis.CameraNotifier, rhs: DGis.CameraNotifier) -> Swift.Bool
  final public func hash(into hasher: inout Swift.Hasher)
  convenience public init(model: DGis.Model)
  final public var hashValue: Swift.Int {
    get
  }
}
public struct Locale : Swift.Hashable {
  public var language: Swift.String
  public var region: Swift.String
  public init(language: Swift.String, region: Swift.String)
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (a: DGis.Locale, b: DGis.Locale) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
}
public struct HttpHeader : Swift.Hashable {
  public var name: Swift.String
  public var value: Swift.String
  public init(name: Swift.String, value: Swift.String)
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (a: DGis.HttpHeader, b: DGis.HttpHeader) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
}
public enum HttpMethod : Swift.UInt32 {
  case gET
  case pOST
  public init?(rawValue: Swift.UInt32)
  public typealias RawValue = Swift.UInt32
  public var rawValue: Swift.UInt32 {
    get
  }
}
public struct HttpRequest : Swift.Hashable {
  public var url: Swift.String
  public var method: DGis.HttpMethod
  public var headers: [DGis.HttpHeader]
  public var body: Foundation.Data?
  public init(url: Swift.String, method: DGis.HttpMethod = HttpMethod.gET, headers: [DGis.HttpHeader] = [], body: Foundation.Data? = nil)
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (a: DGis.HttpRequest, b: DGis.HttpRequest) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
}
public struct HttpStatusCode : Swift.Hashable {
  public var value: Swift.Int32
  public init(value: Swift.Int32 = 0)
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (a: DGis.HttpStatusCode, b: DGis.HttpStatusCode) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
}
public struct HttpResponse : Swift.Hashable {
  public var statusCode: DGis.HttpStatusCode
  public var headers: [DGis.HttpHeader]
  public init(statusCode: DGis.HttpStatusCode, headers: [DGis.HttpHeader])
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (a: DGis.HttpResponse, b: DGis.HttpResponse) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
}
@_hasMissingDesignatedInitializers final public class HttpCacheManager : Swift.Hashable {
  final public var currentSize: Swift.UInt64 {
    get
  }
  final public var maxSize: Swift.UInt64 {
    get
    set(size)
  }
  @objc deinit
  public static func == (lhs: DGis.HttpCacheManager, rhs: DGis.HttpCacheManager) -> Swift.Bool
  final public func hash(into hasher: inout Swift.Hasher)
  final public func clear()
  final public var hashValue: Swift.Int {
    get
  }
}
@_hasMissingDesignatedInitializers final public class HttpResponseCallback : Swift.Hashable {
  @objc deinit
  public static func == (lhs: DGis.HttpResponseCallback, rhs: DGis.HttpResponseCallback) -> Swift.Bool
  final public func hash(into hasher: inout Swift.Hasher)
  final public func onResponse(response: DGis.HttpResponse) -> Swift.Bool
  final public func onReceive(body: Foundation.Data, size: Swift.Int32) -> Swift.Bool
  final public func onFinished()
  final public var hashValue: Swift.Int {
    get
  }
}
public protocol HttpClient {
  func sendRequest(request: DGis.HttpRequest, callback: DGis.HttpResponseCallback)
}
@_hasMissingDesignatedInitializers final public class LocaleManager : Swift.Hashable {
  final public var localesChannel: DGis.StatefulChannel<[DGis.Locale]> {
    get
  }
  final public var locales: [DGis.Locale] {
    get
  }
  final public var systemLocalesChannel: DGis.StatefulChannel<[DGis.Locale]> {
    get
  }
  final public var systemLocales: [DGis.Locale] {
    get
  }
  @objc deinit
  public static func == (lhs: DGis.LocaleManager, rhs: DGis.LocaleManager) -> Swift.Bool
  final public func hash(into hasher: inout Swift.Hasher)
  final public func overrideLocales(locales: [DGis.Locale])
  final public var hashValue: Swift.Int {
    get
  }
}
public func getHttpCacheManager(context: DGis.Context) -> DGis.HttpCacheManager?
public func getLocaleManager(context: DGis.Context) -> DGis.LocaleManager
extension DGis.Locale {
  public static func makeLocale(localeStr: Swift.String) -> DGis.Locale?
}
extension DGis.Locale {
  public func toLocalePosix() -> Swift.String
}
public enum DesiredAccuracy : Swift.UInt32 {
  case low
  case medium
  case high
  public init?(rawValue: Swift.UInt32)
  public typealias RawValue = Swift.UInt32
  public var rawValue: Swift.UInt32 {
    get
  }
}
public enum AddEventError : Swift.UInt32 {
  case networkError
  case territoryNotSupported
  case unknownUserLocation
  case userLocationTooFarFromEvent
  case notAuthorized
  case noPersonalDataCollectionConsent
  case userBlocked
  case tooManyRequests
  public init?(rawValue: Swift.UInt32)
  public typealias RawValue = Swift.UInt32
  public var rawValue: Swift.UInt32 {
    get
  }
}
public enum AddEventResult : Swift.Hashable {
  case event(DGis.RoadEvent)
  case error(DGis.AddEventError)
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (a: DGis.AddEventResult, b: DGis.AddEventResult) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
}
@_hasMissingDesignatedInitializers final public class RoadEventManager : Swift.Hashable {
  @objc deinit
  public static func == (lhs: DGis.RoadEventManager, rhs: DGis.RoadEventManager) -> Swift.Bool
  final public func hash(into hasher: inout Swift.Hasher)
  convenience public init(context: DGis.Context)
  final public func createAccident(location: DGis.GeoPoint, lanes: DGis.LaneOptionSet, description: Swift.String) -> DGis.Future<DGis.AddEventResult>
  final public func createCamera(location: DGis.GeoPoint, description: Swift.String) -> DGis.Future<DGis.AddEventResult>
  final public func createRoadRestriction(location: DGis.GeoPoint, description: Swift.String) -> DGis.Future<DGis.AddEventResult>
  final public func createComment(location: DGis.GeoPoint, description: Swift.String) -> DGis.Future<DGis.AddEventResult>
  final public func createOther(location: DGis.GeoPoint, lanes: DGis.LaneOptionSet, description: Swift.String) -> DGis.Future<DGis.AddEventResult>
  final public func createRoadWorks(location: DGis.GeoPoint, lanes: DGis.LaneOptionSet, description: Swift.String) -> DGis.Future<DGis.AddEventResult>
  final public var hashValue: Swift.Int {
    get
  }
}
@_hasMissingDesignatedInitializers final public class IntRouteAttribute : Swift.Hashable {
  final public var size: Swift.UInt64 {
    get
  }
  final public var isEmpty: Swift.Bool {
    get
  }
  final public var first: DGis.IntRouteEntry? {
    get
  }
  final public var last: DGis.IntRouteEntry? {
    get
  }
  final public var entries: [DGis.IntRouteEntry] {
    get
  }
  @objc deinit
  public static func == (lhs: DGis.IntRouteAttribute, rhs: DGis.IntRouteAttribute) -> Swift.Bool
  final public func hash(into hasher: inout Swift.Hasher)
  final public func entries(begin: DGis.RoutePoint, end: DGis.RoutePoint) -> [DGis.IntRouteEntry]
  final public func findNearBackward(point: DGis.RoutePoint) -> DGis.IntRouteEntry?
  final public func findNearForward(point: DGis.RoutePoint) -> DGis.IntRouteEntry?
  final public var hashValue: Swift.Int {
    get
  }
}
public struct IntRouteEntry : Swift.Hashable {
  public var point: DGis.RoutePoint
  public var value: Swift.Int32
  public init(point: DGis.RoutePoint, value: Swift.Int32)
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (a: DGis.IntRouteEntry, b: DGis.IntRouteEntry) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
}
@_hasMissingDesignatedInitializers final public class ObstacleInfoRouteLongAttribute : Swift.Hashable {
  final public var size: Swift.UInt64 {
    get
  }
  final public var isEmpty: Swift.Bool {
    get
  }
  final public var first: DGis.ObstacleInfoRouteLongEntry? {
    get
  }
  final public var last: DGis.ObstacleInfoRouteLongEntry? {
    get
  }
  final public var entries: [DGis.ObstacleInfoRouteLongEntry] {
    get
  }
  @objc deinit
  public static func == (lhs: DGis.ObstacleInfoRouteLongAttribute, rhs: DGis.ObstacleInfoRouteLongAttribute) -> Swift.Bool
  final public func hash(into hasher: inout Swift.Hasher)
  final public func entry(point: DGis.RoutePoint) -> DGis.ObstacleInfoRouteLongEntry?
  final public func entries(begin: DGis.RoutePoint, end: DGis.RoutePoint) -> [DGis.ObstacleInfoRouteLongEntry]
  final public var hashValue: Swift.Int {
    get
  }
}
public struct ObstacleInfoRouteLongEntry : Swift.Hashable {
  public var point: DGis.RoutePoint
  public var length: DGis.RouteDistance
  public var value: DGis.ObstacleInfo
  public init(point: DGis.RoutePoint, length: DGis.RouteDistance, value: DGis.ObstacleInfo)
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (a: DGis.ObstacleInfoRouteLongEntry, b: DGis.ObstacleInfoRouteLongEntry) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
}
public struct BicycleBriefRouteInfo : Swift.Hashable {
  public var length: DGis.RouteDistance
  public var landmark: Swift.String
  public init(length: DGis.RouteDistance, landmark: Swift.String)
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (a: DGis.BicycleBriefRouteInfo, b: DGis.BicycleBriefRouteInfo) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
}
public enum CarBriefRouteInfoTrafficSpeed : Swift.UInt32 {
  case unknown
  case slow
  case normal
  case fast
  public init?(rawValue: Swift.UInt32)
  public typealias RawValue = Swift.UInt32
  public var rawValue: Swift.UInt32 {
    get
  }
}
public struct CarBriefRouteInfo : Swift.Hashable {
  public var length: DGis.RouteDistance
  public var landmark: Swift.String
  public var trafficSpeed: DGis.CarBriefRouteInfoTrafficSpeed
  public init(length: DGis.RouteDistance, landmark: Swift.String, trafficSpeed: DGis.CarBriefRouteInfoTrafficSpeed)
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (a: DGis.CarBriefRouteInfo, b: DGis.CarBriefRouteInfo) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
}
public struct PedestrianBriefRouteInfo : Swift.Hashable {
  public var length: DGis.RouteDistance
  public var landmark: Swift.String
  public init(length: DGis.RouteDistance, landmark: Swift.String)
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (a: DGis.PedestrianBriefRouteInfo, b: DGis.PedestrianBriefRouteInfo) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
}
public struct PublicBriefRouteTransportInfo : Swift.Hashable {
  public var type: DGis.PublicTransportType
  public var names: [Swift.String]
  public var color: Swift.UInt32?
  public var routeLogo: Swift.String
  public init(type: DGis.PublicTransportType = PublicTransportType.bus, names: [Swift.String], color: Swift.UInt32?, routeLogo: Swift.String)
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (a: DGis.PublicBriefRouteTransportInfo, b: DGis.PublicBriefRouteTransportInfo) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
}
public struct PublicBriefRouteInfo : Swift.Hashable {
  public var publicTransportInfos: [DGis.PublicBriefRouteTransportInfo]
  public init(publicTransportInfos: [DGis.PublicBriefRouteTransportInfo])
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (a: DGis.PublicBriefRouteInfo, b: DGis.PublicBriefRouteInfo) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
}
public struct ScooterBriefRouteInfo : Swift.Hashable {
  public var length: DGis.RouteDistance
  public var landmark: Swift.String
  public init(length: DGis.RouteDistance, landmark: Swift.String)
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (a: DGis.ScooterBriefRouteInfo, b: DGis.ScooterBriefRouteInfo) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
}
public enum BriefExtraRouteInfo : Swift.Hashable {
  case bicycle(DGis.BicycleBriefRouteInfo)
  case car(DGis.CarBriefRouteInfo)
  case pedestrian(DGis.PedestrianBriefRouteInfo)
  case publicTransport(DGis.PublicBriefRouteInfo)
  case scooter(DGis.ScooterBriefRouteInfo)
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (a: DGis.BriefExtraRouteInfo, b: DGis.BriefExtraRouteInfo) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
}
public struct BriefRouteInfo : Swift.Hashable {
  public var duration: Foundation.TimeInterval
  public var extraInfo: DGis.BriefExtraRouteInfo
  public init(duration: Foundation.TimeInterval, extraInfo: DGis.BriefExtraRouteInfo)
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (a: DGis.BriefRouteInfo, b: DGis.BriefRouteInfo) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
}
public struct BriefRouteInfoSearchPoints : Swift.Hashable {
  public var startPoint: DGis.RouteSearchPoint
  public var finishPoint: DGis.RouteSearchPoint
  public init(startPoint: DGis.RouteSearchPoint, finishPoint: DGis.RouteSearchPoint)
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (a: DGis.BriefRouteInfoSearchPoints, b: DGis.BriefRouteInfoSearchPoints) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
}
public struct TruckPassZonePass : Swift.Hashable {
  public var id: DGis.TruckPassZonePassId
  public var name: Swift.String
  public var passZoneIds: Swift.Set<DGis.TruckPassZoneId>
  public init(id: DGis.TruckPassZonePassId, name: Swift.String, passZoneIds: Swift.Set<DGis.TruckPassZoneId>)
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (a: DGis.TruckPassZonePass, b: DGis.TruckPassZonePass) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
}
@_hasMissingDesignatedInitializers final public class TrafficRouter : Swift.Hashable {
  final public var truckPassZonePasses: DGis.Future<[DGis.TruckPassZonePass]> {
    get
  }
  @objc deinit
  public static func == (lhs: DGis.TrafficRouter, rhs: DGis.TrafficRouter) -> Swift.Bool
  final public func hash(into hasher: inout Swift.Hasher)
  convenience public init(context: DGis.Context)
  final public func findRoute(startPoint: DGis.RouteSearchPoint, finishPoint: DGis.RouteSearchPoint, routeSearchOptions: DGis.RouteSearchOptions, intermediatePoints: [DGis.RouteSearchPoint] = []) -> DGis.Future<[DGis.TrafficRoute]>
  final public func findBriefRouteInfos(searchPoints: [DGis.BriefRouteInfoSearchPoints], routeSearchOptions: DGis.RouteSearchOptions) -> DGis.Future<[DGis.BriefRouteInfo?]>
  final public var hashValue: Swift.Int {
    get
  }
}
@_hasMissingDesignatedInitializers final public class TerritoriesAlongRouteProvider : Swift.Hashable {
  @objc deinit
  public static func == (lhs: DGis.TerritoriesAlongRouteProvider, rhs: DGis.TerritoriesAlongRouteProvider) -> Swift.Bool
  final public func hash(into hasher: inout Swift.Hasher)
  final public func getTerritories(route: DGis.Route) -> DGis.Future<[DGis.Territory]>
  final public var hashValue: Swift.Int {
    get
  }
}
@_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers final public class Territory : DGis.Package {
  @objc deinit
}
public func calculateClosestPoint(routeGeometry: DGis.GeoPointRouteAttribute, point: DGis.GeoPoint) -> DGis.RoutePoint?
public func remainingRouteGeometry(fullRouteGeometry: DGis.GeoPointRouteAttribute, currentRoutePoint: DGis.RoutePoint) -> DGis.GeoPointRouteAttribute
public func routeMatchesTruckPassZonePasses(truckPassZoneIds: DGis.TruckPassZoneIdRouteLongAttribute, passZonePasses: [DGis.TruckPassZonePass]) -> Swift.Bool
public func getRoadMacroGraph(context: DGis.Context) -> DGis.RoadMacroGraph
@_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers final public class RoadMacroGraph : DGis.Package {
  @objc deinit
}
public func getTerritoriesAlongRouteProvider(context: DGis.Context) -> DGis.TerritoriesAlongRouteProvider
@_hasMissingDesignatedInitializers final public class TrafficCollector : Swift.Hashable {
  final public var trafficCollectingAllowed: Swift.Bool {
    get
    set(allowed)
  }
  @objc deinit
  public static func == (lhs: DGis.TrafficCollector, rhs: DGis.TrafficCollector) -> Swift.Bool
  final public func hash(into hasher: inout Swift.Hasher)
  convenience public init(context: DGis.Context)
  final public var hashValue: Swift.Int {
    get
  }
}
public enum TrafficScoreState : Swift.UInt32 {
  case pending
  case valid
  case expired
  public init?(rawValue: Swift.UInt32)
  public typealias RawValue = Swift.UInt32
  public var rawValue: Swift.UInt32 {
    get
  }
}
public struct TrafficScore : Swift.Hashable {
  public var state: DGis.TrafficScoreState
  public var value: Swift.UInt32?
  public init(state: DGis.TrafficScoreState = TrafficScoreState.pending, value: Swift.UInt32?)
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (a: DGis.TrafficScore, b: DGis.TrafficScore) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
}
@_hasMissingDesignatedInitializers final public class TrafficScoreProvider : Swift.Hashable {
  final public var scoreChannel: DGis.StatefulChannel<DGis.TrafficScore> {
    get
  }
  final public var score: DGis.TrafficScore {
    get
  }
  @objc deinit
  public static func == (lhs: DGis.TrafficScoreProvider, rhs: DGis.TrafficScoreProvider) -> Swift.Bool
  final public func hash(into hasher: inout Swift.Hasher)
  convenience public init(map: DGis.Map)
  convenience public init(context: DGis.Context, point: DGis.GeoPoint)
  final public var hashValue: Swift.Int {
    get
  }
}
public enum TrafficControlStatus : Swift.UInt32 {
  case hidden
  case enabled
  case disabled
  case loading
  public init?(rawValue: Swift.UInt32)
  public typealias RawValue = Swift.UInt32
  public var rawValue: Swift.UInt32 {
    get
  }
}
public struct TrafficControlState : Swift.Hashable {
  public var status: DGis.TrafficControlStatus
  public var score: Swift.UInt32?
  public init(status: DGis.TrafficControlStatus = TrafficControlStatus.hidden, score: Swift.UInt32?)
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (a: DGis.TrafficControlState, b: DGis.TrafficControlState) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
}
@_hasMissingDesignatedInitializers final public class TrafficControlModel : Swift.Hashable {
  final public var stateChannel: DGis.StatefulChannel<DGis.TrafficControlState> {
    get
  }
  final public var state: DGis.TrafficControlState {
    get
  }
  @objc deinit
  public static func == (lhs: DGis.TrafficControlModel, rhs: DGis.TrafficControlModel) -> Swift.Bool
  final public func hash(into hasher: inout Swift.Hasher)
  convenience public init(map: DGis.Map)
  final public func onClicked()
  final public var hashValue: Swift.Int {
    get
  }
}
public enum PackageInfoError : Swift.UInt32 {
  case noNetwork
  case noFreeSpace
  case downloadError
  public init?(rawValue: Swift.UInt32)
  public typealias RawValue = Swift.UInt32
  public var rawValue: Swift.UInt32 {
    get
  }
}
public enum PackageUpdateStatus : Swift.UInt32 {
  case notAvailable
  case inProgress
  case paused
  public init?(rawValue: Swift.UInt32)
  public typealias RawValue = Swift.UInt32
  public var rawValue: Swift.UInt32 {
    get
  }
}
public struct PackageInfo : Swift.Hashable {
  public var name: Swift.String
  public var installed: Swift.Bool
  public var incomplete: Swift.Bool
  public var preinstalled: Swift.Bool
  public var compatible: Swift.Bool
  public var hasUpdate: Swift.Bool
  public var error: DGis.PackageInfoError?
  public var updateStatus: DGis.PackageUpdateStatus
  public init(name: Swift.String, installed: Swift.Bool = false, incomplete: Swift.Bool = true, preinstalled: Swift.Bool = false, compatible: Swift.Bool = false, hasUpdate: Swift.Bool = false, error: DGis.PackageInfoError?, updateStatus: DGis.PackageUpdateStatus = PackageUpdateStatus.notAvailable)
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (a: DGis.PackageInfo, b: DGis.PackageInfo) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
}
@_hasMissingDesignatedInitializers public class Package : Swift.Hashable {
  public var id: Swift.String {
    get
  }
  public var infoChannel: DGis.StatefulChannel<DGis.PackageInfo> {
    get
  }
  public var info: DGis.PackageInfo {
    get
  }
  public var progressChannel: DGis.StatefulChannel<Swift.UInt8> {
    get
  }
  public var progress: Swift.UInt8 {
    get
  }
  @objc deinit
  public static func == (lhs: DGis.Package, rhs: DGis.Package) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public func install()
  public func uninstall()
  public var hashValue: Swift.Int {
    get
  }
}
@_hasMissingDesignatedInitializers final public class PackageManager : Swift.Hashable {
  final public var autoupdateEnabled: Swift.Bool {
    get
    set(enabled)
  }
  final public var packagesChannel: DGis.StatefulChannel<[DGis.Package]> {
    get
  }
  final public var packages: [DGis.Package] {
    get
  }
  @objc deinit
  public static func == (lhs: DGis.PackageManager, rhs: DGis.PackageManager) -> Swift.Bool
  final public func hash(into hasher: inout Swift.Hasher)
  final public func checkForUpdates()
  final public var hashValue: Swift.Int {
    get
  }
}
public func getPackageManager(context: DGis.Context) -> DGis.PackageManager
public func getTerritoryManager(context: DGis.Context) -> DGis.TerritoryManager
@_hasMissingDesignatedInitializers final public class TerritoryManager : Swift.Hashable {
  final public var territoriesChannel: DGis.StatefulChannel<[DGis.Territory]> {
    get
  }
  final public var territories: [DGis.Territory] {
    get
  }
  @objc deinit
  public static func == (lhs: DGis.TerritoryManager, rhs: DGis.TerritoryManager) -> Swift.Bool
  final public func hash(into hasher: inout Swift.Hasher)
  final public func pause()
  final public func resume()
  final public var hashValue: Swift.Int {
    get
  }
}
final public class BufferedChannel<Value> : DGis.Channel<Value> {
  @usableFromInline
  internal typealias CurrentValueGetter = () -> Value?
  @usableFromInline
  final internal let _getter: DGis.BufferedChannel<Value>.CurrentValueGetter
  final public var value: Value? {
    @inlinable get {
			self._getter()
		}
  }
  @usableFromInline
  internal init(subscriber: @escaping DGis.BufferedChannel<Value>.Subscriber, getter: @escaping DGis.BufferedChannel<Value>.CurrentValueGetter, releaser: @escaping DGis.BufferedChannel<Value>.Releaser = {})
  @objc deinit
}
final public class Cancellable {
  @usableFromInline
  final internal let _cancel: () -> Swift.Void
  @usableFromInline
  final internal let _release: () -> Swift.Void
  public init(cancel: @escaping () -> Swift.Void, release: @escaping () -> Swift.Void = {})
  @objc deinit
  @inlinable final public func cancel() {
		self._cancel()
	}
}
extension DGis.Cancellable {
  @inlinable convenience public init() {
		self.init(cancel: {})
	}
}
extension DGis.Cancellable : Swift.Hashable {
  public static func == (lhs: DGis.Cancellable, rhs: DGis.Cancellable) -> Swift.Bool
  final public func hash(into hasher: inout Swift.Hasher)
  final public var hashValue: Swift.Int {
    get
  }
}
public class Channel<Value> {
  @usableFromInline
  internal typealias Receiver = (Value) -> Swift.Void
  @usableFromInline
  internal typealias Subscriber = (@escaping DGis.Channel<Value>.Receiver) -> DGis.Cancellable
  @usableFromInline
  internal typealias Releaser = () -> Swift.Void
  @usableFromInline
  final internal let _subscriber: DGis.Channel<Value>.Subscriber
  @usableFromInline
  final internal let _releaser: DGis.Channel<Value>.Releaser
  @usableFromInline
  internal init(subscriber: @escaping DGis.Channel<Value>.Subscriber, releaser: @escaping DGis.Channel<Value>.Releaser = {})
  @objc deinit
  @inlinable public func sink(receiveValue: @escaping (Value) -> Swift.Void) -> DGis.Cancellable {
		self._subscriber(receiveValue)
	}
}
extension DGis.Channel : Swift.Hashable {
  public static func == (lhs: DGis.Channel<Value>, rhs: DGis.Channel<Value>) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
public struct SimpleError : Swift.Error, Swift.CustomStringConvertible, Swift.Equatable {
  public let description: Swift.String
  public init(description: Swift.String)
  public static func == (lhs: DGis.SimpleError, rhs: DGis.SimpleError) -> Swift.Bool
}
extension DGis.SimpleError : Swift.CustomDebugStringConvertible {
  @inlinable public var debugDescription: Swift.String {
    get {
		return self.description
	}
  }
}
final public class Future<Value> {
  public typealias Error = DGis.SimpleError
  public typealias Receiver = (Value) -> Swift.Void
  public typealias FailureHandler = (DGis.Future<Value>.Error) -> Swift.Void
  public typealias Subscriber = (@escaping DGis.Future<Value>.Receiver, @escaping DGis.Future<Value>.FailureHandler) -> DGis.Cancellable
  public typealias Canceller = () -> Swift.Void
  @usableFromInline
  final internal let _subscriber: DGis.Future<Value>.Subscriber
  @usableFromInline
  final internal let _canceller: DGis.Future<Value>.Canceller
  public init(subscriber: @escaping DGis.Future<Value>.Subscriber, canceller: @escaping DGis.Future<Value>.Canceller = {})
  @objc deinit
  @inlinable final public func sink(receiveValue: @escaping (Value) -> Swift.Void, failure: @escaping (DGis.Future<Value>.Error) -> Swift.Void) -> DGis.Cancellable {
		self._subscriber(receiveValue, failure)
	}
}
extension DGis.Future {
  public static func makeReadyValue(_ value: Value) -> DGis.Future<Value>
  public static func makeReadyError(message: Swift.String) -> DGis.Future<Value>
}
extension DGis.Future : Swift.Hashable {
  public static func == (lhs: DGis.Future<Value>, rhs: DGis.Future<Value>) -> Swift.Bool
  final public func hash(into hasher: inout Swift.Hasher)
  final public var hashValue: Swift.Int {
    get
  }
}
public enum JSONValue : Swift.Equatable, Swift.Hashable {
  case null
  case bool(Swift.Bool)
  case number(Swift.Double)
  case string(Swift.String)
  case array([DGis.JSONValue])
  case object([Swift.String : DGis.JSONValue])
  public static func == (a: DGis.JSONValue, b: DGis.JSONValue) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
extension DGis.JSONValue : Swift.ExpressibleByNilLiteral {
  public init(nilLiteral: ())
}
extension DGis.JSONValue : Swift.ExpressibleByBooleanLiteral {
  public typealias BooleanLiteralType = Swift.Bool
  public init(booleanLiteral value: Swift.Bool)
}
extension DGis.JSONValue : Swift.ExpressibleByIntegerLiteral {
  public typealias IntegerLiteralType = Swift.Int64
  public init(integerLiteral value: Swift.Int64)
}
extension DGis.JSONValue : Swift.ExpressibleByFloatLiteral {
  public typealias FloatLiteralType = Swift.Double
  public init(floatLiteral value: Swift.Double)
}
extension DGis.JSONValue : Swift.ExpressibleByStringLiteral {
  public typealias StringLiteralType = Swift.String
  public init(stringLiteral value: Swift.String)
  public typealias ExtendedGraphemeClusterLiteralType = DGis.JSONValue.StringLiteralType
  public typealias UnicodeScalarLiteralType = DGis.JSONValue.StringLiteralType
}
extension DGis.JSONValue : Swift.ExpressibleByArrayLiteral {
  public typealias ArrayLiteralElement = DGis.JSONValue
  public init(arrayLiteral elements: DGis.JSONValue...)
}
extension DGis.JSONValue : Swift.ExpressibleByDictionaryLiteral {
  public typealias Key = Swift.String
  public typealias Value = DGis.JSONValue
  public init(dictionaryLiteral elements: (Swift.String, DGis.JSONValue)...)
}
extension DGis.JSONValue : Swift.Decodable {
  public init(from decoder: Swift.Decoder) throws
}
extension DGis.JSONValue : Swift.Encodable {
  public func encode(to encoder: Swift.Encoder) throws
}
final public class StatefulChannel<Value> : DGis.Channel<Value> {
  @usableFromInline
  internal typealias CurrentValueGetter = () -> Value
  @usableFromInline
  final internal let _getter: DGis.StatefulChannel<Value>.CurrentValueGetter
  final public var value: Value {
    @inlinable get {
			self._getter()
		}
  }
  @usableFromInline
  internal init(subscriber: @escaping DGis.StatefulChannel<Value>.Subscriber, getter: @escaping DGis.StatefulChannel<Value>.CurrentValueGetter, releaser: @escaping DGis.StatefulChannel<Value>.Releaser = {})
  @objc deinit
}
public struct ApiKeyOptions {
  public let apiKeyFile: DGis.File
  public init(apiKeyFile: DGis.File)
}
extension DGis.ApiKeyOptions {
  public static let `default`: DGis.ApiKeyOptions
}
public enum AudioVolume : Swift.Float {
  case standard
  case low
  case minimal
  public init?(rawValue: Swift.Float)
  public typealias RawValue = Swift.Float
  public var rawValue: Swift.Float {
    get
  }
}
public struct AudioOptions {
  public init(muteOtherSounds: Swift.Bool, audioVolume: DGis.AudioVolume)
}
extension DGis.AudioOptions {
  public static let `default`: DGis.AudioOptions
}
public protocol IAudioSettings : AnyObject {
  var muteOtherSounds: Swift.Bool { get set }
  var audioVolume: DGis.AudioVolume { get set }
}
public struct BatteryOptions {
  public var lowBatteryThreshold: Swift.Int
  weak public var delegate: DGis.IBatteryManagerDelegate?
  public init(lowBatteryThreshold: Swift.Int, delegate: DGis.IBatteryManagerDelegate?)
}
extension DGis.BatteryOptions {
  public static let `default`: DGis.BatteryOptions
}
public protocol IBatteryManagerDelegate : AnyObject {
  func startBatteryMonitoring()
  func stopBatteryMonitoring()
}
public protocol ICancellable {
  func cancel()
}
public struct NoopCancellable : DGis.ICancellable {
  public init()
  public func cancel()
}
extension DGis.Cancellable : DGis.ICancellable {
}
@_hasMissingDesignatedInitializers final public class Container {
  #if compiler(>=5.3) && $EffectfulProp
  final public var context: DGis.Context {
    get throws
  }
  #endif
  final public var markerViewFactory: DGis.IMarkerViewFactory {
    get
  }
  final public var locationService: DGis.ILocationService {
    get
  }
  final public let audioSettings: DGis.IAudioSettings
  final public let httpOptions: DGis.HTTPOptions
  final public let batteryOptions: DGis.BatteryOptions
  final public let localizationOptions: DGis.LocalizationOptions
  @objc deinit
  final public func makeMapFactory(options: DGis.MapOptions) throws -> DGis.IMapFactory
  final public func makeStyleFactory() throws -> DGis.IStyleFactory
  final public func makeSearchManagerFactory() throws -> DGis.ISearchManagerFactory
  final public func makeSourceFactory() throws -> DGis.ISourceFactory
  final public func makeImageFactory() throws -> DGis.IImageFactory
  final public func makeLocaleManager() throws -> DGis.LocaleManager
  final public func makeRouteEditorFactory() throws -> DGis.IRouteEditorFactory
  final public func makeNavigationViewFactory(options: DGis.NavigationViewOptions = .default) throws -> DGis.INavigationViewFactory
  final public func makeRoadEventCardViewFactory(options: DGis.RoadEventCardViewOptions = .default) throws -> DGis.IRoadEventCardViewFactory
}
extension DGis.Container {
  convenience public init(apiKeyOptions: DGis.ApiKeyOptions = .default, logOptions: DGis.LogOptions = .default, httpClientForRequest: DGis.IHTTPClient? = nil, httpOptions: DGis.HTTPOptions = .default, positioningServices: DGis.IPositioningServicesFactory = PlatformPositioningServicesFactory(), batteryOptions: DGis.BatteryOptions = .default, personalDataCollectionOptions: DGis.PersonalDataCollectionOptions = .default, localizationOptions: DGis.LocalizationOptions = .default, audioOptions: DGis.AudioOptions = .default, vendorConfigFile: DGis.File? = nil)
}
public typealias CreateRoadEventResult = Swift.Result<DGis.AddEventResult, Swift.Error>
public protocol ICreateRoadEventView : UIKit.UIView {
  var visibleAreaEdgeInsets: UIKit.UIEdgeInsets { get }
  var visibleAreaEdgeInsetsChangedCallback: ((UIKit.UIEdgeInsets) -> Swift.Void)? { get set }
  var cancelButtonCallback: (() -> Swift.Void)? { get set }
  var createRoadEventRequestCallback: ((DGis.CreateRoadEventResult) -> Swift.Void)? { get set }
}
extension DGis.DevicePpi {
  public static let autodetected: DGis.DevicePpi?
  public static let defaultForFailedAutodetection: DGis.DevicePpi
}
extension DGis.DevicePpi : Swift.ExpressibleByFloatLiteral {
  public typealias FloatLiteralType = Swift.Float
  public init(floatLiteral value: Swift.Float)
}
public protocol ISearchManager {
  func suggest(query: DGis.SuggestQuery) -> DGis.Future<DGis.SuggestResult>
  func search(query: DGis.SearchQuery) -> DGis.Future<DGis.SearchResult>
  func searchById(id: Swift.String) -> DGis.Future<DGis.DirectoryObject?>
  func searchByDirectoryObjectId(objectId: DGis.DgisObjectId) -> DGis.Future<DGis.DirectoryObject?>
}
extension DGis.SearchManager : DGis.ISearchManager {
}
public protocol ISearchManagerFactory {
  func makeOnlineManager() throws -> DGis.ISearchManager?
  func makeOfflineManager() throws -> DGis.ISearchManager?
  func makeSmartManager() throws -> DGis.ISearchManager?
}
extension DGis.ScreenPoint {
  public init(_ cgPoint: CoreFoundation.CGPoint)
}
extension DGis.ScreenShift {
  public init(_ cgVector: CoreFoundation.CGVector)
}
extension DGis.ScreenSize {
  public init(_ cgSize: CoreFoundation.CGSize)
}
public protocol IDoubleTapAndPanGestureRecognizer : AnyObject {
  var scaleDoublingTranslation: CoreFoundation.CGFloat { get set }
}
public protocol IMapGestureView {
  var doubleTapGestureRecognizer: UIKit.UITapGestureRecognizer? { get }
  var panGestureRecognizer: UIKit.UIPanGestureRecognizer? { get }
  var twoFingerPanGestureRecognizer: UIKit.UIPanGestureRecognizer? { get }
  var rotationGestureRecognizer: UIKit.UIRotationGestureRecognizer? { get }
  var pinchGestureRecognizer: UIKit.UIPinchGestureRecognizer? { get }
  var twoFingerTapGestureRecognizer: UIKit.UITapGestureRecognizer? { get }
  var doubleTapAndPanGestureRecognizer: (UIKit.UIGestureRecognizer & DGis.IDoubleTapAndPanGestureRecognizer)? { get }
}
extension DGis.IMapGestureView {
  public var doubleTapGestureRecognizer: UIKit.UITapGestureRecognizer? {
    get
  }
  public var panGestureRecognizer: UIKit.UIPanGestureRecognizer? {
    get
  }
  public var twoFingerPanGestureRecognizer: UIKit.UIPanGestureRecognizer? {
    get
  }
  public var rotationGestureRecognizer: UIKit.UIRotationGestureRecognizer? {
    get
  }
  public var pinchGestureRecognizer: UIKit.UIPinchGestureRecognizer? {
    get
  }
  public var twoFingerTapGestureRecognizer: UIKit.UITapGestureRecognizer? {
    get
  }
  public var doubleTapAndPanGestureRecognizer: (UIKit.UIGestureRecognizer & DGis.IDoubleTapAndPanGestureRecognizer)? {
    get
  }
}
public protocol IMapGestureViewFactory {
  @available(*, deprecated, message: "Please use makeGestureView(map:eventProcessor:coordinateSpace:)")
  func makeGestureView(map: DGis.Map, coordinateSpace: DGis.IMapCoordinateSpace) -> UIKit.UIView & DGis.IMapGestureView
  func makeGestureView(map: DGis.Map, eventProcessor: DGis.IMapEventProcessor, coordinateSpace: DGis.IMapCoordinateSpace) -> UIKit.UIView & DGis.IMapGestureView
}
extension DGis.IMapGestureViewFactory {
  public func makeGestureView(map: DGis.Map, coordinateSpace: DGis.IMapCoordinateSpace) -> UIKit.UIView & DGis.IMapGestureView
  public func makeGestureView(map: DGis.Map, eventProcessor: DGis.IMapEventProcessor, coordinateSpace: DGis.IMapCoordinateSpace) -> UIKit.UIView & DGis.IMapGestureView
}
public protocol IMapEventProcessor {
  func process(event: DGis.Event)
}
public struct MapGestureViewOptions {
  public enum ScalingCenter : Swift.Int {
    case eventCenter
    case cameraPosition
    public init?(rawValue: Swift.Int)
    public typealias RawValue = Swift.Int
    public var rawValue: Swift.Int {
      get
    }
  }
  public var doubleTapScalingCenter: DGis.MapGestureViewOptions.ScalingCenter
  public var twoFingerTapScalingCenter: DGis.MapGestureViewOptions.ScalingCenter
  public var pinchScalingCenter: DGis.MapGestureViewOptions.ScalingCenter
  public init(doubleTapScalingCenter: DGis.MapGestureViewOptions.ScalingCenter, twoFingerTapScalingCenter: DGis.MapGestureViewOptions.ScalingCenter, pinchScalingCenter: DGis.MapGestureViewOptions.ScalingCenter)
}
extension DGis.MapGestureViewOptions {
  public static let `default`: DGis.MapGestureViewOptions
}
public struct MapGestureViewFactory : DGis.IMapGestureViewFactory {
  public init(options: DGis.MapGestureViewOptions = .default)
  public func makeGestureView(map: DGis.Map, eventProcessor: DGis.IMapEventProcessor, coordinateSpace: DGis.IMapCoordinateSpace) -> UIKit.UIView & DGis.IMapGestureView
}
extension DGis.Locale : Swift.CustomStringConvertible {
  public var description: Swift.String {
    get
  }
}
public struct LocalizationOptions {
  public let locales: [DGis.Locale]
  public let systemLocales: [DGis.Locale]
  public init(locales: [DGis.Locale], systemLocales: [DGis.Locale])
  public init(locales: [DGis.Locale])
}
extension DGis.LocalizationOptions {
  public static let `default`: DGis.LocalizationOptions
}
extension DGis.LogOptions {
  public static let `default`: DGis.LogOptions
}
@usableFromInline
internal func sdkLog(level: DGis.LogLevel = .info, file: Swift.StaticString = #file, line: Swift.UInt = #line, function: Swift.StaticString = #function, _ message: Swift.String)
public protocol IEnergyConsumption : AnyObject {
  typealias FpsCallback = (_ fps: Swift.Double) -> Swift.Void
  var maxFps: Swift.Int? { get set }
  var powerSavingMaxFps: Swift.Int? { get set }
  func setFpsCallback(_ fpsCallback: Self.FpsCallback?)
}
public protocol IMapCoordinateSpace : DGis.INativeScaleProvider, UIKit.UICoordinateSpace {
}
public protocol INativeScaleProvider {
  var nativeScale: CoreFoundation.CGFloat { get }
  var toPixels: CoreFoundation.CGAffineTransform { get }
}
public protocol IMapFactory {
  var initialMapOptions: DGis.MapOptions { get }
  var map: DGis.Map { get }
  var mapView: UIKit.UIView & DGis.IMapView { get }
  var gestureView: (UIKit.UIView & DGis.IMapGestureView)? { get }
  var mapEventProcessor: DGis.IMapEventProcessor { get }
  var mapCoordinateSpace: DGis.IMapCoordinateSpace { get }
  var mapControlFactory: DGis.IMapControlFactory { get }
  var snapshotter: DGis.IMapSnapshotter { get }
  var energyConsumption: DGis.IEnergyConsumption { get }
  var markerViewOverlay: DGis.IMarkerViewOverlay { get }
}
public protocol IMapSnapshotter {
  func makeImage(scale: CoreFoundation.CGFloat, orientation: UIKit.UIImage.Orientation) -> DGis.Future<UIKit.UIImage>
}
extension DGis.IMapSnapshotter {
  public func makeImage(scale: CoreFoundation.CGFloat = 1, orientation: UIKit.UIImage.Orientation = .up) -> DGis.Future<UIKit.UIImage>
}
public enum CopyrightAlignment {
  case topLeft, bottomLeft, bottomRight, topRight
  public static func == (a: DGis.CopyrightAlignment, b: DGis.CopyrightAlignment) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
public protocol IMapView : UIKit.UIView {
  var gestureView: (UIKit.UIView & DGis.IMapGestureView)? { get set }
  var appearance: DGis.MapAppearance { get set }
  var showsAPIVersion: Swift.Bool { get set }
  var copyrightAlignment: DGis.CopyrightAlignment { get set }
  var copyrightInsets: UIKit.UIEdgeInsets { get set }
  var urlOpener: ((Foundation.URL) -> Swift.Void)? { get set }
  func addObjectTappedCallback(callback: DGis.MapObjectTappedCallback)
  func addObjectLongPressCallback(callback: DGis.MapObjectTappedCallback)
  func removeObjectTappedCallback(callback: DGis.MapObjectTappedCallback)
  func removeLongPressCallback(callback: DGis.MapObjectTappedCallback)
}
extension DGis.Map {
  final public func setNavigation(_ isOn: Swift.Bool)
}
public enum MapAppearance : Swift.Hashable {
  case `default`
  case universal(DGis.Theme)
  case automatic(light: DGis.Theme, dark: DGis.Theme)
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (a: DGis.MapAppearance, b: DGis.MapAppearance) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
}
extension DGis.MapAppearance : Swift.CustomStringConvertible {
  public var description: Swift.String {
    get
  }
}
extension DGis.MapAppearance {
  public var defaultBackgroundColor: DGis.Color? {
    get
  }
}
public class MapObjectTappedCallback {
  public init(callback: @escaping (_ objectInfo: DGis.RenderedObjectInfo) -> Swift.Void)
  public func call(objectInfo: DGis.RenderedObjectInfo)
  @objc deinit
}
extension DGis.MapObjectTappedCallback : Swift.Equatable {
  public static func == (lhs: DGis.MapObjectTappedCallback, rhs: DGis.MapObjectTappedCallback) -> Swift.Bool
}
public struct MapOptions {
  public var devicePPI: DGis.DevicePpi?
  public var deviceDensity: DGis.DeviceDensity?
  public var position: DGis.CameraPosition?
  public var positionPoint: DGis.CameraPositionPoint?
  public var zoomRestrictions: DGis.CameraZoomRestrictions?
  public var sources: [DGis.Source]?
  public var sourceDescriptors: Swift.Set<DGis.MapOptions.SourceDescriptor>?
  public var styleFuture: DGis.Future<DGis.Style>?
  public var gestureViewFactory: DGis.IMapGestureViewFactory?
  public var appearance: DGis.MapAppearance?
  public var maxFps: Swift.Int?
  public var powerSavingMaxFps: Swift.Int?
  public var backgroundColor: DGis.Color?
}
extension DGis.MapOptions {
  public enum SourceDescriptor {
    case dgisOnlineSource
    case dgisHybridSource
    case dgisOfflineSource
    public static func == (a: DGis.MapOptions.SourceDescriptor, b: DGis.MapOptions.SourceDescriptor) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
}
extension DGis.MapOptions {
  public static var `default`: DGis.MapOptions
}
public struct Theme : Swift.Hashable {
  public init(name: Swift.String)
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (a: DGis.Theme, b: DGis.Theme) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
}
extension DGis.Theme : Swift.ExpressibleByStringLiteral {
  public typealias StringLiteralType = Swift.String
  public init(stringLiteral value: Swift.String)
  public typealias ExtendedGraphemeClusterLiteralType = DGis.Theme.StringLiteralType
  public typealias UnicodeScalarLiteralType = DGis.Theme.StringLiteralType
}
extension DGis.Theme : Swift.CustomStringConvertible {
  public var description: Swift.String {
    get
  }
}
@objc @_hasMissingDesignatedInitializers @_Concurrency.MainActor(unsafe) final public class CompassControl : UIKit.UIControl {
  @_Concurrency.MainActor(unsafe) @objc override final public var intrinsicContentSize: CoreFoundation.CGSize {
    @objc get
  }
  @_Concurrency.MainActor(unsafe) @objc override final public func layoutSubviews()
  @objc deinit
}
@objc @_hasMissingDesignatedInitializers @_Concurrency.MainActor(unsafe) final public class CreateRoadEventControl : UIKit.UIControl {
  @_Concurrency.MainActor(unsafe) @objc override final public var intrinsicContentSize: CoreFoundation.CGSize {
    @objc get
  }
  @_Concurrency.MainActor(unsafe) @objc override final public func layoutSubviews()
  @objc deinit
}
@objc @_hasMissingDesignatedInitializers @_Concurrency.MainActor(unsafe) final public class CurrentLocationControl : UIKit.UIControl {
  @_Concurrency.MainActor(unsafe) @objc override final public var intrinsicContentSize: CoreFoundation.CGSize {
    @objc get
  }
  @_Concurrency.MainActor(unsafe) @objc override final public func layoutSubviews()
  @objc deinit
}
public struct IndoorControlOptions {
  public enum VisibilityBehavior {
    case automatic
    case manual
    public static func == (a: DGis.IndoorControlOptions.VisibilityBehavior, b: DGis.IndoorControlOptions.VisibilityBehavior) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  public var visibilityBehavior: DGis.IndoorControlOptions.VisibilityBehavior
  public enum MarkingByRoute {
    case off
    case on
    public static func == (a: DGis.IndoorControlOptions.MarkingByRoute, b: DGis.IndoorControlOptions.MarkingByRoute) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  public init(visibilityBehavior: DGis.IndoorControlOptions.VisibilityBehavior)
  public static let `default`: DGis.IndoorControlOptions
}
extension DGis.IndoorControlOptions {
  public init(visibilityBehavior: DGis.IndoorControlOptions.VisibilityBehavior, markingByRoute: DGis.IndoorControlOptions.MarkingByRoute)
}
@objc @_hasMissingDesignatedInitializers @_Concurrency.MainActor(unsafe) final public class IndoorControl : UIKit.UIControl {
  @_Concurrency.MainActor(unsafe) final public var focusedBuildingChangeCallback: (() -> Swift.Void)?
  @_Concurrency.MainActor(unsafe) @objc override final public var intrinsicContentSize: CoreFoundation.CGSize {
    @objc get
  }
  @_Concurrency.MainActor(unsafe) @objc override final public func layoutSubviews()
  @objc deinit
}
public protocol IMapControlFactory {
  func makeZoomControl() -> DGis.ZoomControl
  func makeCurrentLocationControl() -> DGis.CurrentLocationControl
  func makeCompassControl() -> DGis.CompassControl
  func makeTrafficControl() -> DGis.TrafficControl
  func makeCreateRoadEventControl() -> DGis.CreateRoadEventControl
  func makeIndoorControl(_ options: DGis.IndoorControlOptions) -> DGis.IndoorControl
}
extension DGis.IMapControlFactory {
  public func makeIndoorControl(_ options: DGis.IndoorControlOptions = .default) -> DGis.IndoorControl
}
@objc @_hasMissingDesignatedInitializers @_Concurrency.MainActor(unsafe) final public class NavigationFollowingControl : UIKit.UIControl {
  @objc deinit
}
public protocol INavigationMapControlsFactory {
  var followManager: DGis.INavigatorFollowManager { get }
  func makeZoomControl() -> UIKit.UIControl
  func makeTrafficAndParkingMapControl() -> UIKit.UIControl
  func makeCompassControl() -> UIKit.UIControl
  func makeNavigationFollowingControl() -> DGis.NavigationFollowingControl
  func makeTUGCControl() -> UIKit.UIControl
  func makeIndoorControl() -> DGis.IndoorControl
}
@objc @_hasMissingDesignatedInitializers @_Concurrency.MainActor(unsafe) final public class TrafficControl : UIKit.UIControl {
  @_Concurrency.MainActor(unsafe) @objc override final public func traitCollectionDidChange(_ previousTraitCollection: UIKit.UITraitCollection?)
  @_Concurrency.MainActor(unsafe) @objc override final public var intrinsicContentSize: CoreFoundation.CGSize {
    @objc get
  }
  @_Concurrency.MainActor(unsafe) @objc override final public func layoutSubviews()
  @_Concurrency.MainActor(unsafe) final public func switchTrafficVisibility()
  @objc deinit
}
@objc @_hasMissingDesignatedInitializers @_Concurrency.MainActor(unsafe) final public class ZoomControl : UIKit.UIControl {
  @_Concurrency.MainActor(unsafe) final public var buttonSpacing: CoreFoundation.CGFloat {
    get
    set
  }
  @_Concurrency.MainActor(unsafe) @objc override final public var intrinsicContentSize: CoreFoundation.CGSize {
    @objc get
  }
  @_Concurrency.MainActor(unsafe) @objc override final public func layoutSubviews()
  @objc deinit
}
public protocol IMarkerView : UIKit.UIView {
  var id: Foundation.UUID { get }
  var position: DGis.GeoPointWithElevation { get }
  var tapHandler: (() -> Swift.Void)? { get set }
}
public protocol IMarkerViewFactory {
  func make(view: UIKit.UIView, position: DGis.GeoPointWithElevation, anchor: DGis.Anchor, offsetX: CoreFoundation.CGFloat, offsetY: CoreFoundation.CGFloat) -> DGis.IMarkerView
}
public protocol IMarkerViewOverlay : UIKit.UIView {
  func add(markerView: DGis.IMarkerView)
  func add(markerViews: [DGis.IMarkerView])
  func remove(markerView: DGis.IMarkerView)
  func remove(markerViews: [DGis.IMarkerView])
  func removeAll()
}
public protocol IImageFactory {
  func make(pngData: Foundation.Data, size: CoreFoundation.CGSize) -> DGis.Image
  func make(svgData: Foundation.Data, size: CoreFoundation.CGSize) -> DGis.Image
  func make(lottieData: Foundation.Data, size: CoreFoundation.CGSize) -> DGis.Image
  func make(image: UIKit.UIImage) -> DGis.Image
  func make(imageFactory: @escaping () -> UIKit.UIImage) -> DGis.Image
}
public protocol INavigationView : AnyObject {
  var visibleAreaEdgeInsets: UIKit.UIEdgeInsets { get }
  var visibleAreaEdgeInsetsChangedCallback: ((UIKit.UIEdgeInsets) -> Swift.Void)? { get set }
  var finishButtonCallback: (() -> Swift.Void)? { get set }
  func showRoadEvent(_ roadEvent: DGis.RoadEvent)
}
public protocol INavigationViewFactory {
  func makeNavigationViewControlsFactory() -> DGis.INavigationViewControlsFactory
  func makeNavigationMapControlsFactory(map: DGis.Map, followManager: DGis.INavigatorFollowManager) -> DGis.INavigationMapControlsFactory
  func makeNavigationView(map: DGis.Map, navigationManager: DGis.NavigationManager) -> (UIKit.UIView & DGis.INavigationView)
  func makeNavigationView(map: DGis.Map, navigationManager: DGis.NavigationManager, navigationViewControlsFactory: DGis.INavigationViewControlsFactory?, navigationMapControlsFactory: DGis.INavigationMapControlsFactory?) -> (UIKit.UIView & DGis.INavigationView)
  func makeRouteListView(_ routes: [DGis.TrafficRoute]) -> DGis.IRouteListView
  func makeRouteView(_ route: DGis.TrafficRoute) -> DGis.IRouteView
  func makeRouteDetailsView(_ route: DGis.TrafficRoute, startName: Swift.String?, finishName: Swift.String?) -> DGis.IRouteDetailsView
}
public enum NavigationViewMapControlsBehaviour {
  case alwaysVisible
  case visibleWhenNavigationActive
  case invisible
  public static func == (a: DGis.NavigationViewMapControlsBehaviour, b: DGis.NavigationViewMapControlsBehaviour) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
public struct NavigationViewOptions {
  public var mapControlsBehaviour: DGis.NavigationViewMapControlsBehaviour
  public var distanceFormattingStrategy: DGis.DistanceFormattingStrategy
  public var durationFormattingStrategy: DGis.DurationFormattingStrategy
  public var durationValueFormattingStrategy: DGis.DurationValueFormattingStrategy
  public var timeFormattingStrategy: DGis.TimeFormattingStrategy
  public var speedFormattingStrategy: DGis.SpeedFormattingStrategy
  public var theme: DGis.NavigationViewTheme
  public var roadEventCardViewOptions: DGis.RoadEventCardViewOptions
  public var roadEventCreationEnabled: Swift.Bool
  public init(mapControlsBehaviour: DGis.NavigationViewMapControlsBehaviour = .visibleWhenNavigationActive, distanceFormattingStrategy: DGis.DistanceFormattingStrategy = .default, durationFormattingStrategy: DGis.DurationFormattingStrategy = .default, durationValueFormattingStrategy: DGis.DurationValueFormattingStrategy = .default, timeFormattingStrategy: DGis.TimeFormattingStrategy = .default, speedFormattingStrategy: DGis.SpeedFormattingStrategy = .default, theme: DGis.NavigationViewTheme = .default, roadEventCardViewOptions: DGis.RoadEventCardViewOptions = .default, roadEventCreationEnabled: Swift.Bool = true)
}
extension DGis.NavigationViewOptions {
  public static var `default`: DGis.NavigationViewOptions
}
extension DGis.NavigationViewTheme {
  public struct BetterRouteControlTheme {
    public var acceptButtonTextColor: UIKit.UIColor
    public var acceptButtonBackgroundColor: UIKit.UIColor
    public var declineButtonTextColor: UIKit.UIColor
    public var declineButtonBackgroundColor: UIKit.UIColor
    public var progressBarColor: UIKit.UIColor
    public var iconColor: UIKit.UIColor
    public var iconBackgroundColor: UIKit.UIColor
    public init(acceptButtonTextColor: UIKit.UIColor, acceptButtonBackgroundColor: UIKit.UIColor, declineButtonTextColor: UIKit.UIColor, declineButtonBackgroundColor: UIKit.UIColor, progressBarColor: UIKit.UIColor, iconColor: UIKit.UIColor, iconBackgroundColor: UIKit.UIColor)
  }
}
extension DGis.NavigationViewTheme {
  public struct CameraControlTheme {
    public var trackColor: UIKit.UIColor
    public var progressColor: UIKit.UIColor
    public var warningProgressColor: UIKit.UIColor
    public init(trackColor: UIKit.UIColor, progressColor: UIKit.UIColor, warningProgressColor: UIKit.UIColor)
  }
}
extension DGis.NavigationViewTheme {
  public struct DashboardTheme {
    public var backgroundColor: UIKit.UIColor
    public var strapColor: UIKit.UIColor
    public var pinColor: UIKit.UIColor
    public var pinBackgroundColor: UIKit.UIColor
    public var headerButtonTheme: DGis.NavigationViewTheme.DashboardTheme.HeaderButtonTheme
    public var parkingButtonTheme: DGis.NavigationViewTheme.DashboardTheme.ParkingButtonTheme
    public var contentControlTheme: DGis.NavigationViewTheme.DashboardTheme.ContentControlTheme
    public var finishButtonTheme: DGis.NavigationViewTheme.DashboardTheme.FinishButtonTheme
    public init(backgroundColor: UIKit.UIColor, strapColor: UIKit.UIColor, pinColor: UIKit.UIColor, pinBackgroundColor: UIKit.UIColor, headerButtonTheme: DGis.NavigationViewTheme.DashboardTheme.HeaderButtonTheme, parkingButtonTheme: DGis.NavigationViewTheme.DashboardTheme.ParkingButtonTheme, contentControlTheme: DGis.NavigationViewTheme.DashboardTheme.ContentControlTheme, finishButtonTheme: DGis.NavigationViewTheme.DashboardTheme.FinishButtonTheme)
  }
}
extension DGis.NavigationViewTheme.DashboardTheme {
  public struct ContentControlTheme {
    public var leftIconColor: UIKit.UIColor
    public var titleColor: UIKit.UIColor
    public var subtitleColor: UIKit.UIColor
    public var backgroundColor: UIKit.UIColor
    public var rightIconColor: UIKit.UIColor
    public var rightIconBackgroundColor: UIKit.UIColor
    public var activeRightIconColor: UIKit.UIColor
    public var activeRightIconBackgroundColor: UIKit.UIColor
    public var disclosureIndicatorColor: UIKit.UIColor
    public var separatorColor: UIKit.UIColor
    public init(leftIconColor: UIKit.UIColor, titleColor: UIKit.UIColor, subtitleColor: UIKit.UIColor, backgroundColor: UIKit.UIColor, rightIconColor: UIKit.UIColor, rightIconBackgroundColor: UIKit.UIColor, activeRightIconColor: UIKit.UIColor, activeRightIconBackgroundColor: UIKit.UIColor, disclosureIndicatorColor: UIKit.UIColor, separatorColor: UIKit.UIColor)
  }
}
extension DGis.NavigationViewTheme.DashboardTheme {
  public struct FinishButtonTheme {
    public var textColor: UIKit.UIColor
    public var backgroundColor: UIKit.UIColor
    public init(textColor: UIKit.UIColor, backgroundColor: UIKit.UIColor)
  }
}
extension DGis.NavigationViewTheme.DashboardTheme {
  public struct HeaderButtonTheme {
    public var iconColor: UIKit.UIColor
    public var backgroundColor: UIKit.UIColor
    public init(iconColor: UIKit.UIColor, backgroundColor: UIKit.UIColor)
  }
}
extension DGis.NavigationViewTheme.DashboardTheme {
  public struct ParkingButtonTheme {
    public var textColor: UIKit.UIColor
    public var activeTextColor: UIKit.UIColor
    public var iconColor: UIKit.UIColor
    public var activeIconColor: UIKit.UIColor
    public var backgroundColor: UIKit.UIColor
    public var activeBackgroundColor: UIKit.UIColor
    public init(textColor: UIKit.UIColor, activeTextColor: UIKit.UIColor, iconColor: UIKit.UIColor, activeIconColor: UIKit.UIColor, backgroundColor: UIKit.UIColor, activeBackgroundColor: UIKit.UIColor)
  }
}
extension DGis.NavigationViewTheme {
  public struct MapControlsTheme {
    public var iconColor: UIKit.UIColor
    public var backgroundColor: UIKit.UIColor
    public var separatorColor: UIKit.UIColor
    public var trafficControlTheme: DGis.NavigationViewTheme.MapControlsTheme.TrafficControlTheme
    public var parkingControlTheme: DGis.NavigationViewTheme.MapControlsTheme.ParkingControlTheme
    public var followingControlTheme: DGis.NavigationViewTheme.MapControlsTheme.FollowingControlTheme
    public init(iconColor: UIKit.UIColor, backgroundColor: UIKit.UIColor, separatorColor: UIKit.UIColor, trafficControlTheme: DGis.NavigationViewTheme.MapControlsTheme.TrafficControlTheme, parkingControlTheme: DGis.NavigationViewTheme.MapControlsTheme.ParkingControlTheme, followingControlTheme: DGis.NavigationViewTheme.MapControlsTheme.FollowingControlTheme)
  }
}
extension DGis.NavigationViewTheme.MapControlsTheme {
  public struct TrafficControlTheme {
    public var textColor: UIKit.UIColor
    public var activeTextColor: UIKit.UIColor
    public var iconColor: UIKit.UIColor
    public var activeIconColor: UIKit.UIColor
    public var lowJamsColor: UIKit.UIColor
    public var mediumJamsColor: UIKit.UIColor
    public var hightJamsColor: UIKit.UIColor
    public init(textColor: UIKit.UIColor, activeTextColor: UIKit.UIColor, iconColor: UIKit.UIColor, activeIconColor: UIKit.UIColor, lowJamsColor: UIKit.UIColor, mediumJamsColor: UIKit.UIColor, hightJamsColor: UIKit.UIColor)
  }
}
extension DGis.NavigationViewTheme.MapControlsTheme {
  public struct ParkingControlTheme {
    public var activeIconColor: UIKit.UIColor
    public init(activeIconColor: UIKit.UIColor)
  }
}
extension DGis.NavigationViewTheme.MapControlsTheme {
  public struct FollowingControlTheme {
    public var activeIconColor: UIKit.UIColor
    public init(activeIconColor: UIKit.UIColor)
  }
}
extension DGis.NavigationViewTheme {
  public struct MessageBarControlTheme {
    public var positiveTextColor: UIKit.UIColor
    public var positiveBackgroundColor: UIKit.UIColor
    public var negativeTextColor: UIKit.UIColor
    public var negativeBackgroundColor: UIKit.UIColor
    public var activityIndicatorColor: UIKit.UIColor
    public init(positiveTextColor: UIKit.UIColor, positiveBackgroundColor: UIKit.UIColor, negativeTextColor: UIKit.UIColor, negativeBackgroundColor: UIKit.UIColor, activityIndicatorColor: UIKit.UIColor)
  }
}
public struct NavigationViewTheme {
  public struct Colors {
    public var primaryContent: UIKit.UIColor
    public var secondaryContent: UIKit.UIColor
    public var slightlyDimmedContent: UIKit.UIColor
    public var background: UIKit.UIColor
    public var accent: UIKit.UIColor
    public var warning: UIKit.UIColor
    public var success: UIKit.UIColor
    public var dimmedSuccess: UIKit.UIColor
    public var dimmedWarning: UIKit.UIColor
    public var contentOnAccent: UIKit.UIColor
    public var contentOnSuccess: UIKit.UIColor
    public var contentOnWarning: UIKit.UIColor
    public var lightOverlayColor: UIKit.UIColor
    public var mediumOverlayColor: UIKit.UIColor
    public var strongOverlayColor: UIKit.UIColor
    public init(primaryContent: UIKit.UIColor, secondaryContent: UIKit.UIColor, slightlyDimmedContent: UIKit.UIColor, background: UIKit.UIColor, accent: UIKit.UIColor, success: UIKit.UIColor, warning: UIKit.UIColor, dimmedSuccess: UIKit.UIColor, dimmedWarning: UIKit.UIColor, contentOnAccent: UIKit.UIColor, contentOnSuccess: UIKit.UIColor, contentOnWarning: UIKit.UIColor, lightOverlayColor: UIKit.UIColor, mediumOverlayColor: UIKit.UIColor, strongOverlayColor: UIKit.UIColor)
  }
  public let colors: DGis.NavigationViewTheme.Colors
  public var dashboardTheme: DGis.NavigationViewTheme.DashboardTheme
  public var remainingRouteInfoControlTheme: DGis.NavigationViewTheme.RemainingRouteInfoControlTheme
  public var nextManeuverControlTheme: DGis.NavigationViewTheme.NextManeuverControlTheme
  public var speedControlTheme: DGis.NavigationViewTheme.SpeedControlTheme
  public var cameraControlTheme: DGis.NavigationViewTheme.CameraControlTheme
  public var messageBarControlTheme: DGis.NavigationViewTheme.MessageBarControlTheme
  public var mapControlsTheme: DGis.NavigationViewTheme.MapControlsTheme
  public var betterRouteControlTheme: DGis.NavigationViewTheme.BetterRouteControlTheme
  public var thermometerTheme: DGis.NavigationViewTheme.ThermometerTheme
  public init(colors: DGis.NavigationViewTheme.Colors)
  public init(colors: DGis.NavigationViewTheme.Colors, dashboardTheme: DGis.NavigationViewTheme.DashboardTheme, remainingRouteInfoControlTheme: DGis.NavigationViewTheme.RemainingRouteInfoControlTheme, nextManeuverControlTheme: DGis.NavigationViewTheme.NextManeuverControlTheme, speedControlTheme: DGis.NavigationViewTheme.SpeedControlTheme, cameraControlTheme: DGis.NavigationViewTheme.CameraControlTheme, messageBarControlTheme: DGis.NavigationViewTheme.MessageBarControlTheme, mapControlsTheme: DGis.NavigationViewTheme.MapControlsTheme, betterRouteControlTheme: DGis.NavigationViewTheme.BetterRouteControlTheme, thermometerTheme: DGis.NavigationViewTheme.ThermometerTheme)
}
extension DGis.NavigationViewTheme {
  public static let `default`: DGis.NavigationViewTheme
}
extension DGis.NavigationViewTheme.Colors {
  public static let `default`: DGis.NavigationViewTheme.Colors
}
extension DGis.NavigationViewTheme {
  public struct NextManeuverControlTheme {
    public var textColor: UIKit.UIColor
    public var backgroundColor: UIKit.UIColor
    public init(textColor: UIKit.UIColor, backgroundColor: UIKit.UIColor)
  }
}
extension DGis.NavigationViewTheme {
  public struct RemainingRouteInfoControlTheme {
    public var titleColor: UIKit.UIColor
    public var subtitleColor: UIKit.UIColor
    public var backgroundColor: UIKit.UIColor
    public init(titleColor: UIKit.UIColor, subtitleColor: UIKit.UIColor, backgroundColor: UIKit.UIColor)
  }
}
extension DGis.NavigationViewTheme {
  public struct SpeedControlTheme {
    public var textColor: UIKit.UIColor
    public var warningTextColor: UIKit.UIColor
    public var backgroundColor: UIKit.UIColor
    public var warningBackgroundColor: UIKit.UIColor
    public init(textColor: UIKit.UIColor, warningTextColor: UIKit.UIColor, backgroundColor: UIKit.UIColor, warningBackgroundColor: UIKit.UIColor)
  }
}
extension DGis.NavigationViewTheme {
  public struct ThermometerTheme {
    public var backgroundColor: UIKit.UIColor
    public var progressColor: UIKit.UIColor
    public var startPositionColor: UIKit.UIColor
    public var trafficLineDeepRedColor: UIKit.UIColor
    public var trafficLineRedColor: UIKit.UIColor
    public var trafficLineYellowColor: UIKit.UIColor
    public var trafficLineGreenColor: UIKit.UIColor
    public var trafficLineNoDataColor: UIKit.UIColor
    public var trafficLineUndefinedColor: UIKit.UIColor
    public var cursorTheme: DGis.NavigationViewTheme.ThermometerTheme.CursorTheme
    public var betterRouteCursorTheme: DGis.NavigationViewTheme.ThermometerTheme.CursorTheme
    public var crashPointTheme: DGis.NavigationViewTheme.ThermometerTheme.PointObjectTheme
    public var roadWorksPointTheme: DGis.NavigationViewTheme.ThermometerTheme.PointObjectTheme
    public var intermediatePointTheme: DGis.NavigationViewTheme.ThermometerTheme.PointObjectTheme
    public init(backgroundColor: UIKit.UIColor, progressColor: UIKit.UIColor, startPositionColor: UIKit.UIColor, trafficLineDeepRedColor: UIKit.UIColor, trafficLineRedColor: UIKit.UIColor, trafficLineYellowColor: UIKit.UIColor, trafficLineGreenColor: UIKit.UIColor, trafficLineNoDataColor: UIKit.UIColor, trafficLineUndefinedColor: UIKit.UIColor, cursorTheme: DGis.NavigationViewTheme.ThermometerTheme.CursorTheme, betterRouteCursorTheme: DGis.NavigationViewTheme.ThermometerTheme.CursorTheme, crashPointTheme: DGis.NavigationViewTheme.ThermometerTheme.PointObjectTheme, roadWorksPointTheme: DGis.NavigationViewTheme.ThermometerTheme.PointObjectTheme, intermediatePointTheme: DGis.NavigationViewTheme.ThermometerTheme.PointObjectTheme)
  }
}
extension DGis.NavigationViewTheme.ThermometerTheme {
  public struct CursorTheme {
    public var borderColor: UIKit.UIColor
    public var iconColor: UIKit.UIColor
    public var iconBorderColor: UIKit.UIColor
    public var iconBackgroundColor: UIKit.UIColor
    public init(borderColor: UIKit.UIColor, iconColor: UIKit.UIColor, iconBorderColor: UIKit.UIColor, iconBackgroundColor: UIKit.UIColor)
  }
}
extension DGis.NavigationViewTheme.ThermometerTheme {
  public struct PointObjectTheme {
    public var contentColor: UIKit.UIColor
    public var backgroundColor: UIKit.UIColor
    public var foregroundColor: UIKit.UIColor
    public init(contentColor: UIKit.UIColor, backgroundColor: UIKit.UIColor, foregroundColor: UIKit.UIColor)
  }
}
public protocol INavigationControlView : AnyObject {
  var isVisible: Swift.Bool { get }
  var onDidChangeVisibility: (() -> Swift.Void)? { get set }
}
extension DGis.INavigationControlView {
  public var isVisible: Swift.Bool {
    get
  }
}
public protocol INavigationViewControlsFactory {
  func makeNextManeuverControl(uiModel: DGis.Model) -> UIKit.UIView & DGis.INextManeuverControlView
  func makeSpeedControl(uiModel: DGis.Model) -> (UIKit.UIView & DGis.INavigationControlView)
  func makeRemainingRouteInfoControl(navigationManager: DGis.NavigationManager) -> UIKit.UIView & DGis.INavigationControlView
  func makeMessageBarControl(uiModel: DGis.Model) -> UIKit.UIView & DGis.INavigationControlView
  func makeBetterRouteControl(uiModel: DGis.Model) -> UIKit.UIView & DGis.INavigationControlView
  func makeThermometerControl(uiModel: DGis.Model) -> UIKit.UIView & DGis.IThermometerControlView
}
public protocol INextManeuverControlView : DGis.INavigationControlView {
  var onDidRequestLayout: (() -> Swift.Void)? { get set }
}
public enum ThermometerEventsPosition {
  case left
  case right
  public static func == (a: DGis.ThermometerEventsPosition, b: DGis.ThermometerEventsPosition) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
public protocol IThermometerControlView : DGis.INavigationControlView {
  var eventsPosition: DGis.ThermometerEventsPosition { get set }
}
public enum NavigatorFollowDriverType {
  case vehicle
  case pedestrian
  public static func == (a: DGis.NavigatorFollowDriverType, b: DGis.NavigatorFollowDriverType) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
public enum NavigatorFollowMode {
  case none
  case position
  case positionAndDirection
  case positionDirectionAndScale
  public static func == (a: DGis.NavigatorFollowMode, b: DGis.NavigatorFollowMode) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
public protocol INavigatorFollowManagerObservation {
  func invalidate()
}
public protocol INavigatorFollowManager {
  typealias FollowModeObserver = (DGis.NavigatorFollowMode) -> Swift.Void
  var followMode: DGis.NavigatorFollowMode { get }
  var driverType: DGis.NavigatorFollowDriverType { get set }
  func toggleFollowMode()
  func setFollowMode(_ mode: DGis.NavigatorFollowMode)
  func addFollowModeObserver(_ observer: @escaping Self.FollowModeObserver) -> DGis.INavigatorFollowManagerObservation
}
final public class NavigatorFollowManager : DGis.INavigatorFollowManager {
  final public var driverType: DGis.NavigatorFollowDriverType
  final public var followMode: DGis.NavigatorFollowMode {
    get
  }
  public init(map: DGis.Map, followMode: DGis.NavigatorFollowMode, driveType: DGis.NavigatorFollowDriverType = .vehicle)
  final public func toggleFollowMode()
  final public func setFollowMode(_ mode: DGis.NavigatorFollowMode)
  final public func addFollowModeObserver(_ observer: @escaping DGis.NavigatorFollowManager.FollowModeObserver) -> DGis.INavigatorFollowManagerObservation
  @objc deinit
}
public struct HTTPOptions {
  public enum CacheOptions {
    case disk(DGis.HTTPOptions.DiskCacheOptions)
  }
  public struct DiskCacheOptions {
    public let cachesDir: Foundation.URL
    public let maximumCacheSize: Swift.UInt64
  }
  public let timeout: Foundation.TimeInterval
  public let cacheOptions: DGis.HTTPOptions.CacheOptions?
  public init(timeout: Foundation.TimeInterval, cacheOptions: DGis.HTTPOptions.CacheOptions?)
}
extension DGis.HTTPOptions.DiskCacheOptions {
  public init(maximumCacheSize: Swift.UInt64)
}
extension DGis.HTTPOptions {
  public static let `default`: DGis.HTTPOptions
}
public protocol IHTTPClient {
  typealias RequestDataCompletionCallback = (Foundation.HTTPURLResponse?, Foundation.Data?, Swift.Error?) -> Swift.Void
  func send(request: Foundation.URLRequest, callback: @escaping Self.RequestDataCompletionCallback)
}
public struct PersonalDataCollectionOptions {
  public let personalDataCollectionConsent: DGis.PersonalDataCollectionConsent
  public init(personalDataCollectionConsent: DGis.PersonalDataCollectionConsent)
}
extension DGis.PersonalDataCollectionOptions {
  public static let `default`: DGis.PersonalDataCollectionOptions
}
public protocol ILocationProvider {
  typealias LocationCallback = (_ locations: [CoreLocation.CLLocation]) -> Swift.Void
  typealias AvailabilityCallback = (_ isAvailable: Swift.Bool) -> Swift.Void
  var lastLocation: CoreLocation.CLLocation? { get }
  func setCallbacks(locationCallback: Self.LocationCallback?, availabilityCallback: Self.AvailabilityCallback?)
  func setDesiredAccuracy(_ accuracy: DGis.DesiredAccuracy)
}
public protocol ILocationService {
  var lastLocation: CoreLocation.CLLocation? { get }
}
public protocol IMagneticHeadingProvider {
  typealias HeadingCallback = (_ heading: CoreLocation.CLHeading) -> Swift.Void
  typealias AvailabilityCallback = (_ isAvailable: Swift.Bool) -> Swift.Void
  func setCallbacks(headingCallback: Self.HeadingCallback?, availabilityCallback: Self.AvailabilityCallback?)
}
public protocol IPositioningServicesFactory {
  typealias PositioningQueue = Dispatch.DispatchQueue
  var locationProvider: DGis.ILocationProvider? { get }
  var magneticHeadingProvider: DGis.IMagneticHeadingProvider? { get }
}
public struct PlatformPositioningServicesFactory : DGis.IPositioningServicesFactory {
  public let locationProvider: DGis.ILocationProvider?
  public let magneticHeadingProvider: DGis.IMagneticHeadingProvider?
  public init(locationManager: CoreLocation.CLLocationManager = CLLocationManager())
}
public struct UnavailablePositioningServicesFactory : DGis.IPositioningServicesFactory {
  public let locationProvider: DGis.ILocationProvider?
  public let magneticHeadingProvider: DGis.IMagneticHeadingProvider?
  public init()
}
public protocol IRoadEventCardViewFactory {
  func makeRoadEventCardView(_ roadEvent: DGis.RoadEvent) -> DGis.IRoadEventCardView
  func makeCreateRoadEventView(map: DGis.Map) -> DGis.ICreateRoadEventView
}
public typealias RoadEventActionResult = Swift.Result<(type: DGis.RoadEventActionType, result: DGis.ActionResult), Swift.Error>
public typealias RoadEventRemoveResult = Swift.Result<DGis.ActionResult, Swift.Error>
public protocol IRoadEventCardView : UIKit.UIView {
  var closeButtonCallback: (() -> Swift.Void)? { get set }
  var roadEventActionResultCallback: ((DGis.RoadEventActionResult) -> Swift.Void)? { get set }
  var removeRoadEventActionResultCallback: ((DGis.RoadEventRemoveResult) -> Swift.Void)? { get set }
  func setRoadEvent(_ roadEvent: DGis.RoadEvent)
}
public struct RoadEventCardViewOptions {
  public var timeFormattingStrategy: DGis.TimeFormattingStrategy
  public init(timeFormattingStrategy: DGis.TimeFormattingStrategy = .default)
}
extension DGis.RoadEventCardViewOptions {
  public static var `default`: DGis.RoadEventCardViewOptions
}
public protocol IRouteDetailsView : UIKit.UIView {
  var isScrollEnabled: Swift.Bool { get set }
  var contentSize: CoreFoundation.CGSize { get }
}
public protocol IRouteListView : UIKit.UIView {
  var isScrollEnabled: Swift.Bool { get set }
  var contentSize: CoreFoundation.CGSize { get }
  var trafficRouteSelectedCallback: ((DGis.TrafficRoute) -> Swift.Void)? { get set }
}
public protocol IRouteView : UIKit.UIView {
  var route: DGis.TrafficRoute? { get set }
}
public protocol IRouteEditorFactory {
  func createRouteEditorSource() -> DGis.RouteEditor
}
extension DGis.Bearing : Swift.ExpressibleByFloatLiteral {
  public typealias FloatLiteralType = Swift.Double
  public init(floatLiteral value: Swift.Double)
}
extension DGis.Color {
  public init(red: CoreFoundation.CGFloat, green: CoreFoundation.CGFloat, blue: CoreFoundation.CGFloat, alpha: CoreFoundation.CGFloat)
  public init?(_ color: UIKit.UIColor)
}
extension UIKit.UIColor {
  convenience public init(_ color: DGis.Color)
}
extension DGis.Elevation {
  public init(_ distance: CoreLocation.CLLocationDistance)
}
extension DGis.Elevation : Swift.ExpressibleByFloatLiteral {
  public typealias FloatLiteralType = Swift.Float
  public init(floatLiteral value: Swift.Float)
}
extension DGis.GeoPoint {
  public init(latitude: CoreLocation.CLLocationDegrees, longitude: CoreLocation.CLLocationDegrees)
  public init(coordinate: CoreLocation.CLLocationCoordinate2D)
  public func bearing(point: DGis.GeoPoint) -> DGis.Bearing
  public func distance(point: DGis.GeoPoint) -> DGis.Meter
  public func move(bearing: DGis.Bearing, meter: DGis.Meter) -> DGis.GeoPoint
}
extension CoreLocation.CLLocationCoordinate2D {
  public init(point: DGis.GeoPoint)
}
extension DGis.GeoPointWithElevation {
  public var point: DGis.GeoPoint {
    get
  }
  public init(point: DGis.GeoPoint, elevation: DGis.Elevation = 0.0)
  public init(latitude: CoreLocation.CLLocationDegrees, longitude: CoreLocation.CLLocationDegrees, elevation: CoreLocation.CLLocationDistance)
  public init(coordinate: CoreLocation.CLLocationCoordinate2D, elevation: CoreLocation.CLLocationDistance)
  public func bearing(point: DGis.GeoPoint) -> DGis.Bearing
  public func distance(point: DGis.GeoPoint) -> DGis.Meter
  public func move(bearing: DGis.Bearing, meter: DGis.Meter) -> DGis.GeoPointWithElevation
}
extension DGis.Latitude : Swift.ExpressibleByFloatLiteral {
  public typealias FloatLiteralType = Swift.Double
  public init(floatLiteral value: Swift.Double)
}
extension DGis.LogicalPixel : Swift.ExpressibleByFloatLiteral {
  public typealias FloatLiteralType = Swift.Float
  public init(floatLiteral value: Swift.Float)
}
extension DGis.Longitude : Swift.ExpressibleByFloatLiteral {
  public typealias FloatLiteralType = Swift.Double
  public init(floatLiteral value: Swift.Double)
}
extension DGis.Meter : Swift.ExpressibleByFloatLiteral {
  public typealias FloatLiteralType = Swift.Float
  public init(floatLiteral value: Swift.Float)
}
extension DGis.Tilt : Swift.ExpressibleByFloatLiteral {
  public typealias FloatLiteralType = Swift.Float
  public init(floatLiteral value: Swift.Float)
}
extension DGis.Zoom : Swift.ExpressibleByFloatLiteral {
  public typealias FloatLiteralType = Swift.Float
  public init(floatLiteral value: Swift.Float)
}
extension DGis.StyleZoom : Swift.ExpressibleByFloatLiteral {
  public typealias FloatLiteralType = Swift.Float
  public init(floatLiteral value: Swift.Float)
}
public protocol ISourceFactory {
  func createOnlineDGISSource() -> DGis.Source
  func createGeometryMapObjectSourceBuilder() -> DGis.GeometryMapObjectSourceBuilder
  func createOfflineDGISSource() -> DGis.Source
  func createHybridDGISSource() -> DGis.Source
  func createRouteEditorSource(routeEditor: DGis.RouteEditor) -> DGis.RouteEditorSource
}
public protocol IStyleFactory {
  @discardableResult
  func setAttribute(name: Swift.String, value: DGis.AttributeValue) -> Self
  func loadDefault() -> DGis.Future<DGis.Style>
  func loadFile(path: Swift.String) -> DGis.Future<DGis.Style>
}
extension DGis.IStyleFactory {
  public func loadFile(url: Foundation.URL) -> DGis.Future<DGis.Style>
  public func loadResource(name: Swift.String, bundle: Foundation.Bundle) -> DGis.Future<DGis.Style>
}
extension DGis.Camera {
  final public func setPosition(point: DGis.GeoPoint, zoom: DGis.Zoom) throws
  final public func setPosition(point: DGis.GeoPoint) throws
}
public struct MTLDeviceError : DGis.ISDKError, Swift.CustomStringConvertible {
  public let description: Swift.String
  public init(description: Swift.String)
}
extension DGis.MTLDeviceError : Swift.CustomDebugStringConvertible {
  @inlinable public var debugDescription: Swift.String {
    get {
		return self.description
	}
  }
}
public protocol ISDKError : Swift.Error {
}
public struct SDKError : DGis.ISDKError, Swift.CustomStringConvertible {
  public let description: Swift.String
  public init(description: Swift.String)
}
extension DGis.SDKError : Swift.CustomDebugStringConvertible {
  @inlinable public var debugDescription: Swift.String {
    get {
		return self.description
	}
  }
}
public struct MeasurementFormatterOutput {
  public let formattedMeasurement: Swift.String
  public let unit: Swift.String
  public init(formattedMeasurement: Swift.String, unit: Swift.String)
}
public enum DistanceFormattingStrategy {
  case `default`
  case formatted(Foundation.MeasurementFormatter)
  case custom((Foundation.Measurement<Foundation.UnitLength>) -> DGis.MeasurementFormatterOutput)
}
public enum DurationFormattingStrategy {
  case `default`
  case formatted(Foundation.MeasurementFormatter)
  case custom((Foundation.Measurement<Foundation.UnitDuration>) -> Swift.String)
}
public enum DurationValueFormattingStrategy {
  case `default`
  case formatted(Foundation.MeasurementFormatter)
  case custom((Foundation.Measurement<Foundation.UnitDuration>) -> DGis.MeasurementFormatterOutput)
}
public enum SpeedFormattingStrategy {
  case `default`
  case formatted(Foundation.MeasurementFormatter)
  case custom((Foundation.Measurement<Foundation.UnitSpeed>) -> DGis.MeasurementFormatterOutput)
}
public enum TimeFormattingStrategy {
  case `default`
  case formatted(Foundation.DateFormatter)
  case custom((Foundation.Date) -> Swift.String)
}
extension DGis.Model {
  final public var distance: Foundation.Measurement<Foundation.UnitLength>? {
    get
  }
  final public var duration: Foundation.TimeInterval? {
    get
  }
  final public var isFreeRoam: Swift.Bool {
    get
  }
}
extension DGis.DayTime : Swift.Comparable {
  public static func < (lhs: DGis.DayTime, rhs: DGis.DayTime) -> Swift.Bool
}
extension DGis.WeekTime : Swift.Comparable {
  public static func < (lhs: DGis.WeekTime, rhs: DGis.WeekTime) -> Swift.Bool
}
extension DGis.WeekDay : Swift.Comparable {
  public static func < (lhs: DGis.WeekDay, rhs: DGis.WeekDay) -> Swift.Bool
}
public struct VendorConfigOptions {
  public let vendorConfigFile: DGis.File
  public init(vendorConfigFile: DGis.File)
}
extension DGis.PersonalDataCollectionConsent : Swift.Equatable {}
extension DGis.PersonalDataCollectionConsent : Swift.Hashable {}
extension DGis.PersonalDataCollectionConsent : Swift.RawRepresentable {}
extension DGis.WeekDay : Swift.Hashable {}
extension DGis.WeekDay : Swift.RawRepresentable {}
extension DGis.FilterType : Swift.Equatable {}
extension DGis.FilterType : Swift.Hashable {}
extension DGis.FilterType : Swift.RawRepresentable {}
extension DGis.FormattingType : Swift.Equatable {}
extension DGis.FormattingType : Swift.Hashable {}
extension DGis.FormattingType : Swift.RawRepresentable {}
extension DGis.ObjectType : Swift.Equatable {}
extension DGis.ObjectType : Swift.Hashable {}
extension DGis.ObjectType : Swift.RawRepresentable {}
extension DGis.ParkingAccess : Swift.Equatable {}
extension DGis.ParkingAccess : Swift.Hashable {}
extension DGis.ParkingAccess : Swift.RawRepresentable {}
extension DGis.SpecialSpaceType : Swift.Equatable {}
extension DGis.SpecialSpaceType : Swift.Hashable {}
extension DGis.SpecialSpaceType : Swift.RawRepresentable {}
extension DGis.ParkingType : Swift.Equatable {}
extension DGis.ParkingType : Swift.Hashable {}
extension DGis.ParkingType : Swift.RawRepresentable {}
extension DGis.ParkingPurpose : Swift.Equatable {}
extension DGis.ParkingPurpose : Swift.Hashable {}
extension DGis.ParkingPurpose : Swift.RawRepresentable {}
extension DGis.ParkingPavingType : Swift.Equatable {}
extension DGis.ParkingPavingType : Swift.Hashable {}
extension DGis.ParkingPavingType : Swift.RawRepresentable {}
extension DGis.SearchResultType : Swift.Equatable {}
extension DGis.SearchResultType : Swift.Hashable {}
extension DGis.SearchResultType : Swift.RawRepresentable {}
extension DGis.SortingType : Swift.Equatable {}
extension DGis.SortingType : Swift.Hashable {}
extension DGis.SortingType : Swift.RawRepresentable {}
extension DGis.WidgetType : Swift.Equatable {}
extension DGis.WidgetType : Swift.Hashable {}
extension DGis.WidgetType : Swift.RawRepresentable {}
extension DGis.CheckableItemType : Swift.Equatable {}
extension DGis.CheckableItemType : Swift.Hashable {}
extension DGis.CheckableItemType : Swift.RawRepresentable {}
extension DGis.GeometryKind : Swift.Equatable {}
extension DGis.GeometryKind : Swift.Hashable {}
extension DGis.GeometryKind : Swift.RawRepresentable {}
extension DGis.SuggestedType : Swift.Equatable {}
extension DGis.SuggestedType : Swift.Hashable {}
extension DGis.SuggestedType : Swift.RawRepresentable {}
extension DGis.SuggestorType : Swift.Equatable {}
extension DGis.SuggestorType : Swift.Hashable {}
extension DGis.SuggestorType : Swift.RawRepresentable {}
extension DGis.LogLevel : Swift.Equatable {}
extension DGis.LogLevel : Swift.Hashable {}
extension DGis.LogLevel : Swift.RawRepresentable {}
extension DGis.BearingSource : Swift.Equatable {}
extension DGis.BearingSource : Swift.Hashable {}
extension DGis.BearingSource : Swift.RawRepresentable {}
extension DGis.CameraAnimatedMoveReason : Swift.Equatable {}
extension DGis.CameraAnimatedMoveReason : Swift.Hashable {}
extension DGis.CameraAnimatedMoveReason : Swift.RawRepresentable {}
extension DGis.CameraAnimatedMoveResult : Swift.Equatable {}
extension DGis.CameraAnimatedMoveResult : Swift.Hashable {}
extension DGis.CameraAnimatedMoveResult : Swift.RawRepresentable {}
extension DGis.CameraAnimationType : Swift.Equatable {}
extension DGis.CameraAnimationType : Swift.Hashable {}
extension DGis.CameraAnimationType : Swift.RawRepresentable {}
extension DGis.CameraBehaviourChangeReason : Swift.Equatable {}
extension DGis.CameraBehaviourChangeReason : Swift.Hashable {}
extension DGis.CameraBehaviourChangeReason : Swift.RawRepresentable {}
extension DGis.CameraState : Swift.Equatable {}
extension DGis.CameraState : Swift.Hashable {}
extension DGis.CameraState : Swift.RawRepresentable {}
extension DGis.FollowValue : Swift.Equatable {}
extension DGis.FollowValue : Swift.Hashable {}
extension DGis.FollowValue : Swift.RawRepresentable {}
extension DGis.DgisSourceWorkingMode : Swift.Equatable {}
extension DGis.DgisSourceWorkingMode : Swift.Hashable {}
extension DGis.DgisSourceWorkingMode : Swift.RawRepresentable {}
extension DGis.MapRotationDirection : Swift.Equatable {}
extension DGis.MapRotationDirection : Swift.Hashable {}
extension DGis.MapRotationDirection : Swift.RawRepresentable {}
extension DGis.MapScalingDirection : Swift.Equatable {}
extension DGis.MapScalingDirection : Swift.Hashable {}
extension DGis.MapScalingDirection : Swift.RawRepresentable {}
extension DGis.MapShiftDirection : Swift.Equatable {}
extension DGis.MapShiftDirection : Swift.Hashable {}
extension DGis.MapShiftDirection : Swift.RawRepresentable {}
extension DGis.FollowBearing : Swift.Equatable {}
extension DGis.FollowBearing : Swift.Hashable {}
extension DGis.FollowBearing : Swift.RawRepresentable {}
extension DGis.FollowStyleZoom : Swift.Equatable {}
extension DGis.FollowStyleZoom : Swift.Hashable {}
extension DGis.FollowStyleZoom : Swift.RawRepresentable {}
extension DGis.FollowTilt : Swift.Equatable {}
extension DGis.FollowTilt : Swift.Hashable {}
extension DGis.FollowTilt : Swift.RawRepresentable {}
extension DGis.ImageFormat : Swift.Equatable {}
extension DGis.ImageFormat : Swift.Hashable {}
extension DGis.ImageFormat : Swift.RawRepresentable {}
extension DGis.MyLocationMapObjectMarkerType : Swift.Equatable {}
extension DGis.MyLocationMapObjectMarkerType : Swift.Hashable {}
extension DGis.MyLocationMapObjectMarkerType : Swift.RawRepresentable {}
extension DGis.RoadEventType : Swift.Equatable {}
extension DGis.RoadEventType : Swift.Hashable {}
extension DGis.RoadEventType : Swift.RawRepresentable {}
extension DGis.AuthorType : Swift.Equatable {}
extension DGis.AuthorType : Swift.Hashable {}
extension DGis.AuthorType : Swift.RawRepresentable {}
extension DGis.CameraPurpose : Swift.Equatable {}
extension DGis.CameraPurpose : Swift.Hashable {}
extension DGis.CameraPurpose : Swift.RawRepresentable {}
extension DGis.Lane : Swift.Equatable {}
extension DGis.Lane : Swift.Hashable {}
extension DGis.Lane : Swift.RawRepresentable {}
extension DGis.ActionResult : Swift.Equatable {}
extension DGis.ActionResult : Swift.Hashable {}
extension DGis.ActionResult : Swift.RawRepresentable {}
extension DGis.RoadEventActionType : Swift.Equatable {}
extension DGis.RoadEventActionType : Swift.Hashable {}
extension DGis.RoadEventActionType : Swift.RawRepresentable {}
extension DGis.RoadEventActionState : Swift.Equatable {}
extension DGis.RoadEventActionState : Swift.Hashable {}
extension DGis.RoadEventActionState : Swift.RawRepresentable {}
extension DGis.RoadEventDisplayCategory : Swift.Equatable {}
extension DGis.RoadEventDisplayCategory : Swift.Hashable {}
extension DGis.RoadEventDisplayCategory : Swift.RawRepresentable {}
extension DGis.Alignment : Swift.Equatable {}
extension DGis.Alignment : Swift.Hashable {}
extension DGis.Alignment : Swift.RawRepresentable {}
extension DGis.AnimationMode : Swift.Equatable {}
extension DGis.AnimationMode : Swift.Hashable {}
extension DGis.AnimationMode : Swift.RawRepresentable {}
extension DGis.MapDataLoadingState : Swift.Equatable {}
extension DGis.MapDataLoadingState : Swift.Hashable {}
extension DGis.MapDataLoadingState : Swift.RawRepresentable {}
extension DGis.MapVisibilityState : Swift.Equatable {}
extension DGis.MapVisibilityState : Swift.Hashable {}
extension DGis.MapVisibilityState : Swift.RawRepresentable {}
extension DGis.TextPlacement : Swift.Equatable {}
extension DGis.TextPlacement : Swift.Hashable {}
extension DGis.TextPlacement : Swift.RawRepresentable {}
extension DGis.IndoorManagerState : Swift.Equatable {}
extension DGis.IndoorManagerState : Swift.Hashable {}
extension DGis.IndoorManagerState : Swift.RawRepresentable {}
extension DGis.CameraFollowState : Swift.Equatable {}
extension DGis.CameraFollowState : Swift.Hashable {}
extension DGis.CameraFollowState : Swift.RawRepresentable {}
extension DGis.ZoomControlButton : Swift.Equatable {}
extension DGis.ZoomControlButton : Swift.Hashable {}
extension DGis.ZoomControlButton : Swift.RawRepresentable {}
extension DGis.CalloutVisualizationMode : Swift.Equatable {}
extension DGis.CalloutVisualizationMode : Swift.Hashable {}
extension DGis.CalloutVisualizationMode : Swift.RawRepresentable {}
extension DGis.RouteMapObjectPassedDistanceVisualization : Swift.Equatable {}
extension DGis.RouteMapObjectPassedDistanceVisualization : Swift.Hashable {}
extension DGis.RouteMapObjectPassedDistanceVisualization : Swift.RawRepresentable {}
extension DGis.RouteMapObjectDisplayFlag : Swift.Equatable {}
extension DGis.RouteMapObjectDisplayFlag : Swift.Hashable {}
extension DGis.RouteMapObjectDisplayFlag : Swift.RawRepresentable {}
extension DGis.RouteMapObjectPermanentDisplayFlag : Swift.Equatable {}
extension DGis.RouteMapObjectPermanentDisplayFlag : Swift.Hashable {}
extension DGis.RouteMapObjectPermanentDisplayFlag : Swift.RawRepresentable {}
extension DGis.RouteMapObjectCalloutLabelFlag : Swift.Equatable {}
extension DGis.RouteMapObjectCalloutLabelFlag : Swift.Hashable {}
extension DGis.RouteMapObjectCalloutLabelFlag : Swift.RawRepresentable {}
extension DGis.RouteMapObjectCalloutLabelDisplayMode : Swift.Equatable {}
extension DGis.RouteMapObjectCalloutLabelDisplayMode : Swift.Hashable {}
extension DGis.RouteMapObjectCalloutLabelDisplayMode : Swift.RawRepresentable {}
extension DGis.BicycleInstructionCrossroadLandmark : Swift.Equatable {}
extension DGis.BicycleInstructionCrossroadLandmark : Swift.Hashable {}
extension DGis.BicycleInstructionCrossroadLandmark : Swift.RawRepresentable {}
extension DGis.CarInstructionCrossroadDirection : Swift.Equatable {}
extension DGis.CarInstructionCrossroadDirection : Swift.Hashable {}
extension DGis.CarInstructionCrossroadDirection : Swift.RawRepresentable {}
extension DGis.CarInstructionCrossroadLandmark : Swift.Equatable {}
extension DGis.CarInstructionCrossroadLandmark : Swift.Hashable {}
extension DGis.CarInstructionCrossroadLandmark : Swift.RawRepresentable {}
extension DGis.CarInstructionRoundaboutType : Swift.Equatable {}
extension DGis.CarInstructionRoundaboutType : Swift.Hashable {}
extension DGis.CarInstructionRoundaboutType : Swift.RawRepresentable {}
extension DGis.PedestrianInstructionCrossroadLandmark : Swift.Equatable {}
extension DGis.PedestrianInstructionCrossroadLandmark : Swift.Hashable {}
extension DGis.PedestrianInstructionCrossroadLandmark : Swift.RawRepresentable {}
extension DGis.PedestrianInstructionIndoorFloorChangeType : Swift.Equatable {}
extension DGis.PedestrianInstructionIndoorFloorChangeType : Swift.Hashable {}
extension DGis.PedestrianInstructionIndoorFloorChangeType : Swift.RawRepresentable {}
extension DGis.ScooterInstructionCrossroadLandmark : Swift.Equatable {}
extension DGis.ScooterInstructionCrossroadLandmark : Swift.Hashable {}
extension DGis.ScooterInstructionCrossroadLandmark : Swift.RawRepresentable {}
extension DGis.BicycleInstructionCrossroadManeuverDirection : Swift.Equatable {}
extension DGis.BicycleInstructionCrossroadManeuverDirection : Swift.Hashable {}
extension DGis.BicycleInstructionCrossroadManeuverDirection : Swift.RawRepresentable {}
extension DGis.PedestrianInstructionCrossroadManeuverDirection : Swift.Equatable {}
extension DGis.PedestrianInstructionCrossroadManeuverDirection : Swift.Hashable {}
extension DGis.PedestrianInstructionCrossroadManeuverDirection : Swift.RawRepresentable {}
extension DGis.ScooterInstructionCrossroadManeuverDirection : Swift.Equatable {}
extension DGis.ScooterInstructionCrossroadManeuverDirection : Swift.Hashable {}
extension DGis.ScooterInstructionCrossroadManeuverDirection : Swift.RawRepresentable {}
extension DGis.Obstacle : Swift.Equatable {}
extension DGis.Obstacle : Swift.Hashable {}
extension DGis.Obstacle : Swift.RawRepresentable {}
extension DGis.ObstaclePassLimitation : Swift.Equatable {}
extension DGis.ObstaclePassLimitation : Swift.Hashable {}
extension DGis.ObstaclePassLimitation : Swift.RawRepresentable {}
extension DGis.Settlement : Swift.Equatable {}
extension DGis.Settlement : Swift.Hashable {}
extension DGis.Settlement : Swift.RawRepresentable {}
extension DGis.TransportType : Swift.Equatable {}
extension DGis.TransportType : Swift.Hashable {}
extension DGis.TransportType : Swift.RawRepresentable {}
extension DGis.RouteCameraPurpose : Swift.Equatable {}
extension DGis.RouteCameraPurpose : Swift.Hashable {}
extension DGis.RouteCameraPurpose : Swift.RawRepresentable {}
extension DGis.RouteCameraDirection : Swift.Equatable {}
extension DGis.RouteCameraDirection : Swift.Hashable {}
extension DGis.RouteCameraDirection : Swift.RawRepresentable {}
extension DGis.RouteExitSignType : Swift.Equatable {}
extension DGis.RouteExitSignType : Swift.Hashable {}
extension DGis.RouteExitSignType : Swift.RawRepresentable {}
extension DGis.RouteExitSignTableColor : Swift.Equatable {}
extension DGis.RouteExitSignTableColor : Swift.Hashable {}
extension DGis.RouteExitSignTableColor : Swift.RawRepresentable {}
extension DGis.RouteLaneManeuver : Swift.Equatable {}
extension DGis.RouteLaneManeuver : Swift.Hashable {}
extension DGis.RouteLaneManeuver : Swift.RawRepresentable {}
extension DGis.RoadRule : Swift.Equatable {}
extension DGis.RoadRule : Swift.Hashable {}
extension DGis.RoadRule : Swift.RawRepresentable {}
extension DGis.RoadSubtype : Swift.Equatable {}
extension DGis.RoadSubtype : Swift.Hashable {}
extension DGis.RoadSubtype : Swift.RawRepresentable {}
extension DGis.RoadSurface : Swift.Equatable {}
extension DGis.RoadSurface : Swift.Hashable {}
extension DGis.RoadSurface : Swift.RawRepresentable {}
extension DGis.RoadType : Swift.Equatable {}
extension DGis.RoadType : Swift.Hashable {}
extension DGis.RoadType : Swift.RawRepresentable {}
extension DGis.PublicTransportType : Swift.Equatable {}
extension DGis.PublicTransportType : Swift.Hashable {}
extension DGis.PublicTransportType : Swift.RawRepresentable {}
extension DGis.TrafficSpeedColor : Swift.Equatable {}
extension DGis.TrafficSpeedColor : Swift.Hashable {}
extension DGis.TrafficSpeedColor : Swift.RawRepresentable {}
extension DGis.State : Swift.Equatable {}
extension DGis.State : Swift.Hashable {}
extension DGis.State : Swift.RawRepresentable {}
extension DGis.RouteSearchType : Swift.Equatable {}
extension DGis.RouteSearchType : Swift.Hashable {}
extension DGis.RouteSearchType : Swift.RawRepresentable {}
extension DGis.ExcludedAreaType : Swift.Equatable {}
extension DGis.ExcludedAreaType : Swift.Hashable {}
extension DGis.ExcludedAreaType : Swift.RawRepresentable {}
extension DGis.ExcludedAreaSeverity : Swift.Equatable {}
extension DGis.ExcludedAreaSeverity : Swift.Hashable {}
extension DGis.ExcludedAreaSeverity : Swift.RawRepresentable {}
extension DGis.BetterRouteResponse : Swift.Equatable {}
extension DGis.BetterRouteResponse : Swift.Hashable {}
extension DGis.BetterRouteResponse : Swift.RawRepresentable {}
extension DGis.RouteVisualizationType : Swift.Equatable {}
extension DGis.RouteVisualizationType : Swift.Hashable {}
extension DGis.RouteVisualizationType : Swift.RawRepresentable {}
extension DGis.RoutePointKind : Swift.Equatable {}
extension DGis.RoutePointKind : Swift.Hashable {}
extension DGis.RoutePointKind : Swift.RawRepresentable {}
extension DGis.SoundCategory : Swift.Equatable {}
extension DGis.SoundCategory : Swift.Hashable {}
extension DGis.SoundCategory : Swift.RawRepresentable {}
extension DGis.InstructionManeuver : Swift.Equatable {}
extension DGis.InstructionManeuver : Swift.Hashable {}
extension DGis.InstructionManeuver : Swift.RawRepresentable {}
extension DGis.LanesControlImage : Swift.Equatable {}
extension DGis.LanesControlImage : Swift.Hashable {}
extension DGis.LanesControlImage : Swift.RawRepresentable {}
extension DGis.HttpMethod : Swift.Equatable {}
extension DGis.HttpMethod : Swift.Hashable {}
extension DGis.HttpMethod : Swift.RawRepresentable {}
extension DGis.DesiredAccuracy : Swift.Equatable {}
extension DGis.DesiredAccuracy : Swift.Hashable {}
extension DGis.DesiredAccuracy : Swift.RawRepresentable {}
extension DGis.AddEventError : Swift.Equatable {}
extension DGis.AddEventError : Swift.Hashable {}
extension DGis.AddEventError : Swift.RawRepresentable {}
extension DGis.CarBriefRouteInfoTrafficSpeed : Swift.Equatable {}
extension DGis.CarBriefRouteInfoTrafficSpeed : Swift.Hashable {}
extension DGis.CarBriefRouteInfoTrafficSpeed : Swift.RawRepresentable {}
extension DGis.TrafficScoreState : Swift.Equatable {}
extension DGis.TrafficScoreState : Swift.Hashable {}
extension DGis.TrafficScoreState : Swift.RawRepresentable {}
extension DGis.TrafficControlStatus : Swift.Equatable {}
extension DGis.TrafficControlStatus : Swift.Hashable {}
extension DGis.TrafficControlStatus : Swift.RawRepresentable {}
extension DGis.PackageInfoError : Swift.Equatable {}
extension DGis.PackageInfoError : Swift.Hashable {}
extension DGis.PackageInfoError : Swift.RawRepresentable {}
extension DGis.PackageUpdateStatus : Swift.Equatable {}
extension DGis.PackageUpdateStatus : Swift.Hashable {}
extension DGis.PackageUpdateStatus : Swift.RawRepresentable {}
extension DGis.AudioVolume : Swift.Equatable {}
extension DGis.AudioVolume : Swift.Hashable {}
extension DGis.AudioVolume : Swift.RawRepresentable {}
extension DGis.MapGestureViewOptions.ScalingCenter : Swift.Equatable {}
extension DGis.MapGestureViewOptions.ScalingCenter : Swift.Hashable {}
extension DGis.MapGestureViewOptions.ScalingCenter : Swift.RawRepresentable {}
extension DGis.CopyrightAlignment : Swift.Equatable {}
extension DGis.CopyrightAlignment : Swift.Hashable {}
extension DGis.MapOptions.SourceDescriptor : Swift.Equatable {}
extension DGis.MapOptions.SourceDescriptor : Swift.Hashable {}
extension DGis.IndoorControlOptions.VisibilityBehavior : Swift.Equatable {}
extension DGis.IndoorControlOptions.VisibilityBehavior : Swift.Hashable {}
extension DGis.IndoorControlOptions.MarkingByRoute : Swift.Equatable {}
extension DGis.IndoorControlOptions.MarkingByRoute : Swift.Hashable {}
extension DGis.NavigatorFollowMode : Swift.Equatable {}
extension DGis.NavigatorFollowMode : Swift.Hashable {}
extension DGis.NavigationViewMapControlsBehaviour : Swift.Equatable {}
extension DGis.NavigationViewMapControlsBehaviour : Swift.Hashable {}
extension DGis.ThermometerEventsPosition : Swift.Equatable {}
extension DGis.ThermometerEventsPosition : Swift.Hashable {}
extension DGis.NavigatorFollowDriverType : Swift.Equatable {}
extension DGis.NavigatorFollowDriverType : Swift.Hashable {}
