// swift-interface-format-version: 1.0
// swift-compiler-version: Apple Swift version 5.7 (swiftlang-5.7.0.127.4 clang-1400.0.29.50)
// swift-module-flags: -target arm64-apple-ios12.0 -enable-objc-interop -enable-library-evolution -swift-version 5 -enforce-exclusivity=checked -O -module-name DGis
// swift-module-flags-ignorable: -enable-bare-slash-regex
import CarPlay/*.CPTemplateApplicationDashboardScene*/
import CarPlay/*.CPTemplateApplicationScene*/
import CoreGraphics
import CoreGraphics/*.CGAffineTransform*/
import CoreGraphics/*.CGFloat*/
import CoreLocation
import CoreTelephony
import Dispatch
import Dispatch/*.DispatchQueue*/
import Foundation
import Foundation/*.Data*/
import Foundation/*.Date*/
import Foundation/*.ProcessInfo*/
import Foundation/*.TimeInterval*/
import GLKit
import Metal/*.MTLDevice*/
import MetalKit
import Foundation.NSProcessInfo/*.ProcessInfo*/
import Network
import QuartzCore/*.CADisplayLink*/
import Swift
import SystemConfiguration
import UIKit
import UIKit/*.CACurrentMediaTime*/
import UIKit/*.UIApplication*/
import UIKit/*.UIColor*/
import UIKit/*.UICoordinateSpace*/
import UIKit/*.UIDevice*/
import UIKit/*.UIImage*/
import UIKit/*.UIScreen*/
import UIKit/*.UITraitCollection*/
import UIKit/*.UIUserInterfaceStyle*/
import _Concurrency
import _StringProcessing
import os
public struct BuildingId : Swift.Hashable {
  public var value: Swift.UInt64
  public init(value: Swift.UInt64 = 0)
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (a: DGis.BuildingId, b: DGis.BuildingId) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
}
public struct DayTime : Swift.Hashable {
  public var hours: Swift.UInt8
  public var minutes: Swift.UInt8
  public init(hours: Swift.UInt8, minutes: Swift.UInt8)
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (a: DGis.DayTime, b: DGis.DayTime) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
}
public struct DgisObjectId : Swift.Hashable {
  public var objectId: Swift.UInt64
  public var entranceId: Swift.UInt64
  public init(objectId: Swift.UInt64 = 0, entranceId: Swift.UInt64 = 0)
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (a: DGis.DgisObjectId, b: DGis.DgisObjectId) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
}
@_hasMissingDesignatedInitializers final public class Context : Swift.Hashable {
  @objc deinit
  public static func == (lhs: DGis.Context, rhs: DGis.Context) -> Swift.Bool
  final public func hash(into hasher: inout Swift.Hasher)
  final public var hashValue: Swift.Int {
    get
  }
}
@_hasMissingDesignatedInitializers final public class SystemMemoryManager : Swift.Hashable {
  @objc deinit
  public static func == (lhs: DGis.SystemMemoryManager, rhs: DGis.SystemMemoryManager) -> Swift.Bool
  final public func hash(into hasher: inout Swift.Hasher)
  final public func reduceMemoryUsage()
  final public var hashValue: Swift.Int {
    get
  }
}
public struct LevelId : Swift.Hashable {
  public var value: Swift.UInt64
  public init(value: Swift.UInt64 = 0)
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (a: DGis.LevelId, b: DGis.LevelId) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
}
public struct LevelInfo : Swift.Hashable {
  public var id: DGis.LevelId
  public var name: Swift.String
  public init(id: DGis.LevelId, name: Swift.String)
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (a: DGis.LevelInfo, b: DGis.LevelInfo) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
}
public enum PersonalDataCollectionConsent : Swift.UInt32 {
  case granted
  case denied
  public init?(rawValue: Swift.UInt32)
  public typealias RawValue = Swift.UInt32
  public var rawValue: Swift.UInt32 {
    get
  }
}
public struct ScreenSize : Swift.Hashable {
  public var width: Swift.UInt32
  public var height: Swift.UInt32
  public init(width: Swift.UInt32 = 0, height: Swift.UInt32 = 0)
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (a: DGis.ScreenSize, b: DGis.ScreenSize) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
}
public enum WeekDay : Swift.UInt32 {
  case sunday
  case monday
  case tuesday
  case wednesday
  case thursday
  case friday
  case saturday
  public init?(rawValue: Swift.UInt32)
  public typealias RawValue = Swift.UInt32
  public var rawValue: Swift.UInt32 {
    get
  }
}
public struct WeekTime : Swift.Hashable {
  public var weekDay: DGis.WeekDay
  public var time: DGis.DayTime
  public init(weekDay: DGis.WeekDay, time: DGis.DayTime)
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (a: DGis.WeekTime, b: DGis.WeekTime) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
}
public struct WeekTimeInterval : Swift.Hashable {
  public var startTime: DGis.WeekTime
  public var finishTime: DGis.WeekTime
  public init(startTime: DGis.WeekTime, finishTime: DGis.WeekTime)
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (a: DGis.WeekTimeInterval, b: DGis.WeekTimeInterval) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
}
public func getSystemMemoryManager(context: DGis.Context) -> DGis.SystemMemoryManager
@_hasMissingDesignatedInitializers final public class File : Swift.Hashable {
  @objc deinit
  public static func == (lhs: DGis.File, rhs: DGis.File) -> Swift.Bool
  final public func hash(into hasher: inout Swift.Hasher)
  convenience public init(path: Swift.String)
  public static func fromString(contents: Swift.String) -> DGis.File
  final public var hashValue: Swift.Int {
    get
  }
}
public struct Latitude : Swift.Hashable {
  public var value: Swift.Double
  public init(value: Swift.Double = 0)
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (a: DGis.Latitude, b: DGis.Latitude) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
}
public struct Longitude : Swift.Hashable {
  public var value: Swift.Double
  public init(value: Swift.Double = 0)
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (a: DGis.Longitude, b: DGis.Longitude) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
}
public struct GeoPoint : Swift.Hashable {
  public var latitude: DGis.Latitude
  public var longitude: DGis.Longitude
  public init(latitude: DGis.Latitude, longitude: DGis.Longitude)
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (a: DGis.GeoPoint, b: DGis.GeoPoint) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
}
public struct GeoRect : Swift.Hashable {
  public var southWestPoint: DGis.GeoPoint
  public var northEastPoint: DGis.GeoPoint
  public init(southWestPoint: DGis.GeoPoint, northEastPoint: DGis.GeoPoint)
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (a: DGis.GeoRect, b: DGis.GeoRect) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
}
public struct Bearing : Swift.Hashable {
  public var value: Swift.Double
  public init(value: Swift.Double = 0)
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (a: DGis.Bearing, b: DGis.Bearing) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
}
extension DGis.GeoRect {
  public var isValid: Swift.Bool {
    get
  }
}
extension DGis.GeoPoint {
  public var isValid: Swift.Bool {
    get
  }
}
extension DGis.GeoRect {
  public func contains(rect2: DGis.GeoRect) -> Swift.Bool
}
extension DGis.GeoRect {
  public func contains(point: DGis.GeoPoint) -> Swift.Bool
}
extension DGis.GeoRect {
  public func expand(rect2: DGis.GeoRect) -> DGis.GeoRect
}
extension DGis.GeoRect {
  public func expand(point: DGis.GeoPoint) -> DGis.GeoRect
}
extension DGis.GeoRect {
  public var isDegenerate: Swift.Bool {
    get
  }
}
extension DGis.GeoRect {
  public func intersects(rect2: DGis.GeoRect) -> Swift.Bool
}
public struct ApartmentRange : Swift.Hashable {
  public var start: Swift.String
  public var end: Swift.String?
  public init(start: Swift.String, end: Swift.String? = nil)
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (a: DGis.ApartmentRange, b: DGis.ApartmentRange) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
}
public struct Attribute : Swift.Hashable {
  public var tag: Swift.String
  public var value: Swift.String
  public init(tag: Swift.String, value: Swift.String)
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (a: DGis.Attribute, b: DGis.Attribute) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
}
public struct PurposeCode : Swift.Hashable {
  public var value: Swift.UInt64
  public init(value: Swift.UInt64 = 0)
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (a: DGis.PurposeCode, b: DGis.PurposeCode) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
}
public struct BuildingLevels : Swift.Hashable {
  public var defaultLevelId: DGis.LevelId
  public var levels: [DGis.LevelInfo]
  public init(defaultLevelId: DGis.LevelId, levels: [DGis.LevelInfo])
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (a: DGis.BuildingLevels, b: DGis.BuildingLevels) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
}
public struct BuildingInfo : Swift.Hashable {
  public var buildingName: Swift.String?
  public var purposeName: Swift.String?
  public var purposeCode: DGis.PurposeCode?
  public var buildingLevels: DGis.BuildingLevels?
  public init(buildingName: Swift.String? = nil, purposeName: Swift.String? = nil, purposeCode: DGis.PurposeCode? = nil, buildingLevels: DGis.BuildingLevels? = nil)
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (a: DGis.BuildingInfo, b: DGis.BuildingInfo) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
}
public struct ContactInfo : Swift.Hashable {
  public var type: Swift.String
  public var displayText: Swift.String
  public var value: Swift.String
  public var comment: Swift.String?
  public init(type: Swift.String, displayText: Swift.String, value: Swift.String, comment: Swift.String?)
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (a: DGis.ContactInfo, b: DGis.ContactInfo) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
}
public struct IsOpenNow : Swift.Hashable {
  public init()
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (a: DGis.IsOpenNow, b: DGis.IsOpenNow) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
}
public enum WorkTimeFilter : Swift.Hashable {
  case workTime(DGis.WeekTime)
  case isOpenNow(DGis.IsOpenNow)
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (a: DGis.WorkTimeFilter, b: DGis.WorkTimeFilter) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
}
public struct FlagFilter : Swift.Hashable {
  public var tagName: Swift.String
  public var displayName: Swift.String
  public var flagValue: Swift.Bool?
  public init(tagName: Swift.String, displayName: Swift.String, flagValue: Swift.Bool?)
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (a: DGis.FlagFilter, b: DGis.FlagFilter) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
}
public struct RangeFilter : Swift.Hashable {
  public var tagName: Swift.String
  public var displayName: Swift.String
  public var minValue: Swift.Double
  public var maxValue: Swift.Double
  public init(tagName: Swift.String, displayName: Swift.String, minValue: Swift.Double, maxValue: Swift.Double)
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (a: DGis.RangeFilter, b: DGis.RangeFilter) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
}
public struct SortingFilter : Swift.Hashable {
  public var tagName: Swift.String
  public var displayName: Swift.String
  public init(tagName: Swift.String, displayName: Swift.String)
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (a: DGis.SortingFilter, b: DGis.SortingFilter) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
}
public enum DynamicFilter : Swift.Hashable {
  case flagFilter(DGis.FlagFilter)
  case rangeFilter(DGis.RangeFilter)
  case sortingFilter(DGis.SortingFilter)
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (a: DGis.DynamicFilter, b: DGis.DynamicFilter) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
}
public struct DirectoryFilter : Swift.Hashable {
  public var workTime: DGis.WorkTimeFilter?
  public var dynamic: [DGis.DynamicFilter]
  public init(workTime: DGis.WorkTimeFilter?, dynamic: [DGis.DynamicFilter])
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (a: DGis.DirectoryFilter, b: DGis.DirectoryFilter) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
}
public struct EntranceGeometry : Swift.Hashable {
  public var entrancePoints: [DGis.GeoPoint]
  public var entrancePolylines: [[DGis.GeoPoint]]
  public init(entrancePoints: [DGis.GeoPoint], entrancePolylines: [[DGis.GeoPoint]])
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (a: DGis.EntranceGeometry, b: DGis.EntranceGeometry) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
}
public struct EntranceInfo : Swift.Hashable {
  public var id: DGis.DgisObjectId
  public var buildingNumber: Swift.String?
  public var porchName: Swift.String?
  public var porchNumber: Swift.String?
  public var apartmentRanges: [DGis.ApartmentRange]
  public var geometry: DGis.EntranceGeometry?
  public init(id: DGis.DgisObjectId, buildingNumber: Swift.String?, porchName: Swift.String?, porchNumber: Swift.String?, apartmentRanges: [DGis.ApartmentRange], geometry: DGis.EntranceGeometry?)
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (a: DGis.EntranceInfo, b: DGis.EntranceInfo) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
}
public enum FilterType : Swift.UInt32 {
  case sORT
  case fILTER
  public init?(rawValue: Swift.UInt32)
  public typealias RawValue = Swift.UInt32
  public var rawValue: Swift.UInt32 {
    get
  }
}
public struct FloorInfo : Swift.Hashable {
  public var levelId: DGis.LevelId
  public var buildingId: DGis.BuildingId
  public init(levelId: DGis.LevelId, buildingId: DGis.BuildingId)
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (a: DGis.FloorInfo, b: DGis.FloorInfo) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
}
public struct FormattedAddress : Swift.Hashable {
  public var drilldownAddress: Swift.String?
  public var streetAddress: Swift.String?
  public var addressComment: Swift.String?
  public var postCode: Swift.String?
  public init(drilldownAddress: Swift.String?, streetAddress: Swift.String?, addressComment: Swift.String?, postCode: Swift.String?)
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (a: DGis.FormattedAddress, b: DGis.FormattedAddress) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
}
public enum FormattingType : Swift.UInt32 {
  case short
  case full
  public init?(rawValue: Swift.UInt32)
  public typealias RawValue = Swift.UInt32
  public var rawValue: Swift.UInt32 {
    get
  }
}
@_hasMissingDesignatedInitializers final public class ItemMarkerInfo : Swift.Hashable {
  final public var objectId: DGis.DgisObjectId? {
    get
  }
  final public var geoPoint: DGis.GeoPointWithElevation {
    get
  }
  final public var floorInfo: DGis.FloorInfo? {
    get
  }
  @objc deinit
  public static func == (lhs: DGis.ItemMarkerInfo, rhs: DGis.ItemMarkerInfo) -> Swift.Bool
  final public func hash(into hasher: inout Swift.Hasher)
  final public var hashValue: Swift.Int {
    get
  }
}
public struct Elevation : Swift.Hashable {
  public var value: Swift.Float
  public init(value: Swift.Float = 0)
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (a: DGis.Elevation, b: DGis.Elevation) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
}
public struct GeoPointWithElevation : Swift.Hashable {
  public var latitude: DGis.Latitude
  public var longitude: DGis.Longitude
  public var elevation: DGis.Elevation
  public init(latitude: DGis.Latitude, longitude: DGis.Longitude, elevation: DGis.Elevation = Elevation(value: 0))
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (a: DGis.GeoPointWithElevation, b: DGis.GeoPointWithElevation) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
}
public enum ObjectType : Swift.UInt32 {
  case admDiv
  case attraction
  case branch
  case building
  case coordinates
  case crossroad
  case parking
  case road
  case route
  case station
  case stationEntrance
  case street
  case unknown
  public init?(rawValue: Swift.UInt32)
  public typealias RawValue = Swift.UInt32
  public var rawValue: Swift.UInt32 {
    get
  }
}
public struct OpeningHours : Swift.Hashable {
  public var weekOpeningHours: [[DGis.WeekTimeInterval]]
  public var isOpen24x7: Swift.Bool
  public init(weekOpeningHours: [[DGis.WeekTimeInterval]], isOpen24x7: Swift.Bool)
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (a: DGis.OpeningHours, b: DGis.OpeningHours) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
}
public enum ParkingAccess : Swift.UInt32 {
  case `public`
  case handicappedOnly
  case customersOnly
  case residentsOnly
  case taxiOnly
  public init?(rawValue: Swift.UInt32)
  public typealias RawValue = Swift.UInt32
  public var rawValue: Swift.UInt32 {
    get
  }
}
public enum SpecialSpaceType : Swift.UInt32 {
  case bicycle
  case motorbike
  case family
  case handicapped
  case babyCarriage
  case truck
  case scooter
  public init?(rawValue: Swift.UInt32)
  public typealias RawValue = Swift.UInt32
  public var rawValue: Swift.UInt32 {
    get
  }
}
public struct SpecialSpace : Swift.Hashable {
  public var type: DGis.SpecialSpaceType
  public var name: Swift.String
  public var count: Swift.String?
  public init(type: DGis.SpecialSpaceType, name: Swift.String, count: Swift.String?)
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (a: DGis.SpecialSpace, b: DGis.SpecialSpace) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
}
public struct ParkingCapacity : Swift.Hashable {
  public var total: Swift.String?
  public var specialSpaces: [DGis.SpecialSpace]
  public init(total: Swift.String?, specialSpaces: [DGis.SpecialSpace])
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (a: DGis.ParkingCapacity, b: DGis.ParkingCapacity) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
}
public enum ParkingType : Swift.UInt32 {
  case ground
  case underground
  case multilevel
  public init?(rawValue: Swift.UInt32)
  public typealias RawValue = Swift.UInt32
  public var rawValue: Swift.UInt32 {
    get
  }
}
public enum ParkingPurpose : Swift.UInt32 {
  case car
  case bike
  case motorbike
  case babyCarriage
  case scooter
  public init?(rawValue: Swift.UInt32)
  public typealias RawValue = Swift.UInt32
  public var rawValue: Swift.UInt32 {
    get
  }
}
public enum ParkingPavingType : Swift.UInt32 {
  case asphalt
  case concrete
  case gravel
  case unpaved
  public init?(rawValue: Swift.UInt32)
  public typealias RawValue = Swift.UInt32
  public var rawValue: Swift.UInt32 {
    get
  }
}
public struct ParkingInfo : Swift.Hashable {
  public var type: DGis.ParkingType?
  public var purpose: DGis.ParkingPurpose
  public var access: DGis.ParkingAccess
  public var pavingType: DGis.ParkingPavingType?
  public var isPaid: Swift.Bool
  public var isIncentive: Swift.Bool
  public var forTrucks: Swift.Bool
  public var levelCount: Swift.UInt16?
  public var capacity: DGis.ParkingCapacity?
  public init(type: DGis.ParkingType?, purpose: DGis.ParkingPurpose, access: DGis.ParkingAccess, pavingType: DGis.ParkingPavingType?, isPaid: Swift.Bool, isIncentive: Swift.Bool, forTrucks: Swift.Bool, levelCount: Swift.UInt16?, capacity: DGis.ParkingCapacity?)
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (a: DGis.ParkingInfo, b: DGis.ParkingInfo) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
}
public struct Reviews : Swift.Hashable {
  public var rating: Swift.Float
  public var count: Swift.UInt32
  public init(rating: Swift.Float, count: Swift.UInt32)
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (a: DGis.Reviews, b: DGis.Reviews) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
}
public struct RubricId : Swift.Hashable {
  public var value: Swift.UInt64
  public init(value: Swift.UInt64 = 0)
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (a: DGis.RubricId, b: DGis.RubricId) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
}
public enum SearchResultType : Swift.UInt32 {
  case recovery
  case discovery
  public init?(rawValue: Swift.UInt32)
  public typealias RawValue = Swift.UInt32
  public var rawValue: Swift.UInt32 {
    get
  }
}
public enum SortingType : Swift.UInt32 {
  case byRelevance
  case byDistance
  case byRating
  public init?(rawValue: Swift.UInt32)
  public typealias RawValue = Swift.UInt32
  public var rawValue: Swift.UInt32 {
    get
  }
}
public struct TradeLicense : Swift.Hashable {
  public var type: Swift.String
  public var license: Swift.String
  public var legalForm: Swift.String
  public var endDate: Swift.String
  public init(type: Swift.String, license: Swift.String, legalForm: Swift.String, endDate: Swift.String)
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (a: DGis.TradeLicense, b: DGis.TradeLicense) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
}
public struct UIMarkerInfo : Swift.Hashable {
  public var objectId: DGis.DgisObjectId
  public var label: Swift.String?
  public init(objectId: DGis.DgisObjectId, label: Swift.String?)
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (a: DGis.UIMarkerInfo, b: DGis.UIMarkerInfo) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
}
public struct WorkStatus : Swift.Hashable {
  public var isOpen: Swift.Bool
  public var description: Swift.String
  public init(isOpen: Swift.Bool, description: Swift.String)
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (a: DGis.WorkStatus, b: DGis.WorkStatus) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
}
public struct AddressAdmDiv : Swift.Hashable {
  public var type: Swift.String
  public var name: Swift.String
  public init(type: Swift.String, name: Swift.String)
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (a: DGis.AddressAdmDiv, b: DGis.AddressAdmDiv) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
}
public struct AddressStreet : Swift.Hashable {
  public var street: Swift.String
  public var number: Swift.String
  public var fiasCode: Swift.String?
  public init(street: Swift.String, number: Swift.String, fiasCode: Swift.String?)
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (a: DGis.AddressStreet, b: DGis.AddressStreet) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
}
public struct AddressNumber : Swift.Hashable {
  public var number: Swift.String
  public var fiasCode: Swift.String?
  public init(number: Swift.String, fiasCode: Swift.String?)
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (a: DGis.AddressNumber, b: DGis.AddressNumber) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
}
public struct AddressLocation : Swift.Hashable {
  public var comment: Swift.String
  public init(comment: Swift.String)
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (a: DGis.AddressLocation, b: DGis.AddressLocation) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
}
public enum AddressComponent : Swift.Hashable {
  case streetAddress(DGis.AddressStreet)
  case number(DGis.AddressNumber)
  case location(DGis.AddressLocation)
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (a: DGis.AddressComponent, b: DGis.AddressComponent) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
}
public struct Address : Swift.Hashable {
  public var drillDown: [DGis.AddressAdmDiv]
  public var components: [DGis.AddressComponent]
  public var buildingName: Swift.String?
  public var postCode: Swift.String?
  public var buildingCode: Swift.String?
  public var fiasCode: Swift.String?
  public var addressComment: Swift.String?
  public init(drillDown: [DGis.AddressAdmDiv], components: [DGis.AddressComponent], buildingName: Swift.String?, postCode: Swift.String?, buildingCode: Swift.String?, fiasCode: Swift.String?, addressComment: Swift.String?)
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (a: DGis.Address, b: DGis.Address) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
}
@_hasMissingDesignatedInitializers final public class DirectoryObject : Swift.Hashable {
  final public var types: [DGis.ObjectType] {
    get
  }
  final public var title: Swift.String {
    get
  }
  final public var titleAddition: Swift.String {
    get
  }
  final public var subtitle: Swift.String {
    get
  }
  final public var description: Swift.String {
    get
  }
  final public var id: DGis.DgisObjectId? {
    get
  }
  final public var markerPosition: DGis.GeoPointWithElevation? {
    get
  }
  final public var address: DGis.Address? {
    get
  }
  final public var attributes: [DGis.Attribute] {
    get
  }
  final public var contextAttributes: [DGis.Attribute] {
    get
  }
  final public var timeZoneOffset: Foundation.TimeInterval? {
    get
  }
  final public var openingHours: DGis.OpeningHours? {
    get
  }
  final public var contactInfos: [DGis.ContactInfo] {
    get
  }
  final public var reviews: DGis.Reviews? {
    get
  }
  final public var parkingInfo: DGis.ParkingInfo? {
    get
  }
  final public var workStatus: DGis.WorkStatus? {
    get
  }
  final public var levelId: DGis.LevelId? {
    get
  }
  final public var buildingLevels: DGis.BuildingLevels? {
    get
  }
  final public var entrances: [DGis.EntranceInfo] {
    get
  }
  final public var tradeLicense: DGis.TradeLicense? {
    get
  }
  final public var buildingInfo: DGis.BuildingInfo {
    get
  }
  @objc deinit
  public static func == (lhs: DGis.DirectoryObject, rhs: DGis.DirectoryObject) -> Swift.Bool
  final public func hash(into hasher: inout Swift.Hasher)
  final public func formattedAddress(type: DGis.FormattingType) -> DGis.FormattedAddress?
  final public var hashValue: Swift.Int {
    get
  }
}
@_hasMissingDesignatedInitializers final public class Page : Swift.Hashable {
  final public var items: [DGis.DirectoryObject] {
    get
  }
  @objc deinit
  public static func == (lhs: DGis.Page, rhs: DGis.Page) -> Swift.Bool
  final public func hash(into hasher: inout Swift.Hasher)
  final public func fetchPrevPage() -> DGis.Future<DGis.Page?>
  final public func fetchNextPage() -> DGis.Future<DGis.Page?>
  final public var hashValue: Swift.Int {
    get
  }
}
public enum WidgetType : Swift.UInt32 {
  case cHECKBOX
  case cHECKABLE_ITEM_GROUP
  case rANGE
  public init?(rawValue: Swift.UInt32)
  public typealias RawValue = Swift.UInt32
  public var rawValue: Swift.UInt32 {
    get
  }
}
@_hasMissingDesignatedInitializers public class Widget : Swift.Hashable {
  public var type: DGis.WidgetType {
    get
  }
  public var caption: Swift.String? {
    get
  }
  public var filters: [DGis.DynamicFilter] {
    get
  }
  @objc deinit
  public static func == (lhs: DGis.Widget, rhs: DGis.Widget) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
@_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers final public class Checkbox : DGis.Widget {
  final public var filterType: DGis.FilterType {
    get
  }
  final public var checkedText: Swift.String? {
    get
  }
  final public var uncheckedText: Swift.String? {
    get
  }
  final public var values: [Swift.String] {
    get
  }
  final public var isChecked: Swift.Bool {
    get
    set(checked)
  }
  @objc deinit
}
public enum CheckableItemType : Swift.UInt32 {
  case sIMPLE
  case gROUP
  public init?(rawValue: Swift.UInt32)
  public typealias RawValue = Swift.UInt32
  public var rawValue: Swift.UInt32 {
    get
  }
}
@_hasMissingDesignatedInitializers public class CheckableItem : Swift.Hashable {
  public var type: DGis.CheckableItemType {
    get
  }
  public var filterType: DGis.FilterType {
    get
  }
  @objc deinit
  public static func == (lhs: DGis.CheckableItem, rhs: DGis.CheckableItem) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
@_hasMissingDesignatedInitializers final public class CheckableGroupedItem : Swift.Hashable {
  final public var text: Swift.String {
    get
  }
  final public var values: [Swift.String] {
    get
  }
  final public var isChecked: Swift.Bool {
    get
    set(checked)
  }
  @objc deinit
  public static func == (lhs: DGis.CheckableGroupedItem, rhs: DGis.CheckableGroupedItem) -> Swift.Bool
  final public func hash(into hasher: inout Swift.Hasher)
  final public var hashValue: Swift.Int {
    get
  }
}
@_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers final public class CheckableItemsGroup : DGis.Widget {
  final public var items: [DGis.CheckableItem] {
    get
  }
  @objc deinit
}
@_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers final public class SimpleCheckableItem : DGis.CheckableItem {
  final public var text: Swift.String {
    get
  }
  final public var values: [Swift.String] {
    get
  }
  final public var isChecked: Swift.Bool {
    get
    set(checked)
  }
  @objc deinit
}
@_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers final public class GroupCheckableItem : DGis.CheckableItem {
  final public var items: [DGis.CheckableGroupedItem] {
    get
  }
  @objc deinit
}
public struct Borders : Swift.Hashable {
  public var snapping: Swift.Double?
  public var isLg: Swift.Bool
  public var value: Swift.String
  public var min: Swift.Double
  public var max: Swift.Double
  public var currentMin: Swift.Double?
  public var currentMax: Swift.Double?
  public init(snapping: Swift.Double?, isLg: Swift.Bool, value: Swift.String, min: Swift.Double, max: Swift.Double, currentMin: Swift.Double? = nil, currentMax: Swift.Double? = nil)
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (a: DGis.Borders, b: DGis.Borders) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
}
public struct OrderedValue : Swift.Hashable {
  public var value: Swift.String
  public var text: Swift.String?
  public init(value: Swift.String, text: Swift.String?)
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (a: DGis.OrderedValue, b: DGis.OrderedValue) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
}
public struct OrderedValues : Swift.Hashable {
  public var values: [DGis.OrderedValue]
  public var currentMinIndex: Swift.UInt64?
  public var currentMaxIndex: Swift.UInt64?
  public init(values: [DGis.OrderedValue], currentMinIndex: Swift.UInt64? = nil, currentMaxIndex: Swift.UInt64? = nil)
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (a: DGis.OrderedValues, b: DGis.OrderedValues) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
}
public enum Range : Swift.Hashable {
  case borders(DGis.Borders)
  case orderedValues(DGis.OrderedValues)
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (a: DGis.Range, b: DGis.Range) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
}
@_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers final public class RangeWidget : DGis.Widget {
  final public var range: DGis.Range {
    get
  }
  final public func setValues(min: Swift.Double, max: Swift.Double)
  @objc deinit
}
@_hasMissingDesignatedInitializers final public class SearchResult : Swift.Hashable {
  final public var firstPage: DGis.Page? {
    get
  }
  final public var representativeArea: DGis.Geometry? {
    get
  }
  final public var itemMarkerInfos: DGis.Future<[DGis.ItemMarkerInfo]?> {
    get
  }
  final public var searchResultType: DGis.SearchResultType {
    get
  }
  final public var dynamicFilters: [DGis.DynamicFilter] {
    get
  }
  final public var actionWidgets: [DGis.Widget] {
    get
  }
  final public var mainWidgets: [DGis.Widget] {
    get
  }
  final public var autoUseFirstResult: Swift.Bool {
    get
  }
  @objc deinit
  public static func == (lhs: DGis.SearchResult, rhs: DGis.SearchResult) -> Swift.Bool
  final public func hash(into hasher: inout Swift.Hasher)
  final public func markerTitles(objectIds: [DGis.DgisObjectId]) -> [DGis.Future<[DGis.UIMarkerInfo]>]
  final public var hashValue: Swift.Int {
    get
  }
}
public enum GeometryKind : Swift.UInt32 {
  case point
  case polyline
  case polygon
  case complex
  public init?(rawValue: Swift.UInt32)
  public typealias RawValue = Swift.UInt32
  public var rawValue: Swift.UInt32 {
    get
  }
}
@_hasMissingDesignatedInitializers public class Geometry : Swift.Hashable {
  public var kind: DGis.GeometryKind {
    get
  }
  public var bounds: DGis.GeoRect {
    get
  }
  public var minPoint: DGis.GeoPoint {
    get
  }
  public var maxPoint: DGis.GeoPoint {
    get
  }
  @objc deinit
  public static func == (lhs: DGis.Geometry, rhs: DGis.Geometry) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public func intersects(geometry: DGis.Geometry) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
}
@_hasMissingDesignatedInitializers final public class SearchQuery : Swift.Hashable {
  @objc deinit
  public static func == (lhs: DGis.SearchQuery, rhs: DGis.SearchQuery) -> Swift.Bool
  final public func hash(into hasher: inout Swift.Hasher)
  final public var hashValue: Swift.Int {
    get
  }
}
@_hasMissingDesignatedInitializers final public class SuggestObjectHandler : Swift.Hashable {
  final public var item: DGis.DirectoryObject {
    get
  }
  @objc deinit
  public static func == (lhs: DGis.SuggestObjectHandler, rhs: DGis.SuggestObjectHandler) -> Swift.Bool
  final public func hash(into hasher: inout Swift.Hasher)
  final public var hashValue: Swift.Int {
    get
  }
}
@_hasMissingDesignatedInitializers final public class PerformSearchHandler : Swift.Hashable {
  final public var searchQuery: DGis.SearchQuery {
    get
  }
  @objc deinit
  public static func == (lhs: DGis.PerformSearchHandler, rhs: DGis.PerformSearchHandler) -> Swift.Bool
  final public func hash(into hasher: inout Swift.Hasher)
  final public var hashValue: Swift.Int {
    get
  }
}
@_hasMissingDesignatedInitializers final public class IncompleteTextHandler : Swift.Hashable {
  final public var queryText: Swift.String {
    get
  }
  @objc deinit
  public static func == (lhs: DGis.IncompleteTextHandler, rhs: DGis.IncompleteTextHandler) -> Swift.Bool
  final public func hash(into hasher: inout Swift.Hasher)
  final public var hashValue: Swift.Int {
    get
  }
}
public enum SuggestHandler : Swift.Hashable {
  case objectHandler(DGis.SuggestObjectHandler?)
  case performSearchHandler(DGis.PerformSearchHandler?)
  case incompleteTextHandler(DGis.IncompleteTextHandler?)
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (a: DGis.SuggestHandler, b: DGis.SuggestHandler) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
}
public struct MarkedUpTextSpan : Swift.Hashable {
  public var offset: Swift.UInt64
  public var length: Swift.UInt64
  public init(offset: Swift.UInt64, length: Swift.UInt64)
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (a: DGis.MarkedUpTextSpan, b: DGis.MarkedUpTextSpan) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
}
public struct MarkedUpText : Swift.Hashable {
  public var text: Swift.String
  public var matchedParts: [DGis.MarkedUpTextSpan]
  public init(text: Swift.String, matchedParts: [DGis.MarkedUpTextSpan])
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (a: DGis.MarkedUpText, b: DGis.MarkedUpText) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
}
public enum SuggestedType : Swift.UInt32 {
  case admDiv
  case attraction
  case attribute
  case branch
  case building
  case coordinates
  case crossroad
  case districtArea
  case org
  case orgCategory
  case parking
  case region
  case road
  case route
  case station
  case stationEntrance
  case street
  case text
  case unknown
  public init?(rawValue: Swift.UInt32)
  public typealias RawValue = Swift.UInt32
  public var rawValue: Swift.UInt32 {
    get
  }
}
public enum SuggestorType : Swift.UInt32 {
  case general
  case routeEndpoint
  public init?(rawValue: Swift.UInt32)
  public typealias RawValue = Swift.UInt32
  public var rawValue: Swift.UInt32 {
    get
  }
}
@_hasMissingDesignatedInitializers final public class Suggest : Swift.Hashable {
  final public var handler: DGis.SuggestHandler {
    get
  }
  final public var suggestedType: DGis.SuggestedType {
    get
  }
  final public var title: DGis.MarkedUpText {
    get
  }
  final public var subtitle: DGis.MarkedUpText {
    get
  }
  @objc deinit
  public static func == (lhs: DGis.Suggest, rhs: DGis.Suggest) -> Swift.Bool
  final public func hash(into hasher: inout Swift.Hasher)
  final public var hashValue: Swift.Int {
    get
  }
}
@_hasMissingDesignatedInitializers final public class SuggestResult : Swift.Hashable {
  final public var suggests: [DGis.Suggest] {
    get
  }
  @objc deinit
  public static func == (lhs: DGis.SuggestResult, rhs: DGis.SuggestResult) -> Swift.Bool
  final public func hash(into hasher: inout Swift.Hasher)
  final public var hashValue: Swift.Int {
    get
  }
}
@_hasMissingDesignatedInitializers final public class SuggestQuery : Swift.Hashable {
  @objc deinit
  public static func == (lhs: DGis.SuggestQuery, rhs: DGis.SuggestQuery) -> Swift.Bool
  final public func hash(into hasher: inout Swift.Hasher)
  final public var hashValue: Swift.Int {
    get
  }
}
@_hasMissingDesignatedInitializers final public class SearchManager : Swift.Hashable {
  @objc deinit
  public static func == (lhs: DGis.SearchManager, rhs: DGis.SearchManager) -> Swift.Bool
  final public func hash(into hasher: inout Swift.Hasher)
  public static func createOnlineManager(context: DGis.Context) throws -> DGis.SearchManager
  final public func suggest(query: DGis.SuggestQuery) -> DGis.Future<DGis.SuggestResult>
  final public func search(query: DGis.SearchQuery) -> DGis.Future<DGis.SearchResult>
  final public func searchById(id: Swift.String) -> DGis.Future<DGis.DirectoryObject?>
  final public func searchByDirectoryObjectId(objectId: DGis.DgisObjectId) -> DGis.Future<DGis.DirectoryObject?>
  final public var hashValue: Swift.Int {
    get
  }
}
@_hasMissingDesignatedInitializers final public class SearchQueryBuilder : Swift.Hashable {
  @objc deinit
  public static func == (lhs: DGis.SearchQueryBuilder, rhs: DGis.SearchQueryBuilder) -> Swift.Bool
  final public func hash(into hasher: inout Swift.Hasher)
  public static func fromQueryText(queryText: Swift.String) -> DGis.SearchQueryBuilder
  public static func fromRubricIds(rubricIds: [DGis.RubricId]) -> DGis.SearchQueryBuilder
  public static func fromQueryTextAndRubricIds(queryText: Swift.String, rubricIds: [DGis.RubricId]) -> DGis.SearchQueryBuilder
  public static func fromQuery(query: DGis.SearchQuery) -> DGis.SearchQueryBuilder
  final public func setSpatialRestriction(spatialRestriction: [DGis.GeoPoint]?) -> DGis.SearchQueryBuilder
  final public func setAreaOfInterest(rect: DGis.GeoRect?) -> DGis.SearchQueryBuilder
  final public func setAllowedResultTypes(allowedResultTypes: [DGis.ObjectType]) -> DGis.SearchQueryBuilder
  final public func setPageSize(pageSize: Swift.Int32) -> DGis.SearchQueryBuilder
  final public func setDirectoryFilter(filter: DGis.DirectoryFilter) -> DGis.SearchQueryBuilder
  final public func setSortingType(sortingType: DGis.SortingType) -> DGis.SearchQueryBuilder
  final public func build() -> DGis.SearchQuery
  final public var hashValue: Swift.Int {
    get
  }
}
@_hasMissingDesignatedInitializers final public class SuggestQueryBuilder : Swift.Hashable {
  @objc deinit
  public static func == (lhs: DGis.SuggestQueryBuilder, rhs: DGis.SuggestQueryBuilder) -> Swift.Bool
  final public func hash(into hasher: inout Swift.Hasher)
  public static func fromQueryText(queryText: Swift.String) -> DGis.SuggestQueryBuilder
  public static func fromQuery(query: DGis.SuggestQuery) -> DGis.SuggestQueryBuilder
  final public func setSpatialRestriction(spatialRestriction: [DGis.GeoPoint]?) -> DGis.SuggestQueryBuilder
  final public func setAreaOfInterest(rect: DGis.GeoRect?) -> DGis.SuggestQueryBuilder
  final public func setAllowedResultTypes(allowedResultTypes: [DGis.SuggestedType]) -> DGis.SuggestQueryBuilder
  final public func setSuggestorType(suggestorType: DGis.SuggestorType) -> DGis.SuggestQueryBuilder
  final public func setLimit(limit: Swift.Int32) -> DGis.SuggestQueryBuilder
  final public func build() -> DGis.SuggestQuery
  final public var hashValue: Swift.Int {
    get
  }
}
@_hasMissingDesignatedInitializers final public class PackedSearchQuery : Swift.Hashable {
  final public var queryText: Swift.String {
    get
  }
  final public var spatialRestriction: [DGis.GeoPoint]? {
    get
  }
  final public var areaOfInterest: DGis.GeoRect? {
    get
  }
  final public var allowedResultTypes: [DGis.ObjectType] {
    get
  }
  final public var pageSize: Swift.Int32 {
    get
  }
  final public var directoryFilter: DGis.DirectoryFilter {
    get
  }
  final public var sortingType: DGis.SortingType {
    get
  }
  @objc deinit
  public static func == (lhs: DGis.PackedSearchQuery, rhs: DGis.PackedSearchQuery) -> Swift.Bool
  final public func hash(into hasher: inout Swift.Hasher)
  public static func fromBytes(data: Foundation.Data) throws -> DGis.PackedSearchQuery
  public static func fromSearchQuery(searchQuery: DGis.SearchQuery) -> DGis.PackedSearchQuery
  final public func toBytes() -> Foundation.Data
  final public func toSearchQuery() -> DGis.SearchQuery
  final public var hashValue: Swift.Int {
    get
  }
}
public enum PointGeometryData : Swift.Hashable {
  case geoPoint(DGis.GeoPoint)
  case geoPointWithElevation(DGis.GeoPointWithElevation)
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (a: DGis.PointGeometryData, b: DGis.PointGeometryData) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
}
@_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers final public class PointGeometry : DGis.Geometry {
  final public var point: DGis.PointGeometryData {
    get
  }
  convenience public init(point: DGis.GeoPoint)
  convenience public init(point: DGis.GeoPointWithElevation)
  @objc deinit
}
@_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers final public class PolygonGeometry : DGis.Geometry {
  final public var contours: [[DGis.GeoPoint]] {
    get
  }
  convenience public init(contours: [[DGis.GeoPoint]])
  @objc deinit
}
@_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers final public class PolylineGeometry : DGis.Geometry {
  final public var points: [DGis.GeoPoint] {
    get
  }
  convenience public init(points: [DGis.GeoPoint])
  @objc deinit
}
@_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers final public class ComplexGeometry : DGis.Geometry {
  final public var elements: [DGis.Geometry] {
    get
  }
  convenience public init(geometries: [DGis.Geometry])
  @objc deinit
}
public enum LogLevel : Swift.UInt32 {
  case verbose
  case info
  case warning
  case error
  case fault
  case disabled
  public init?(rawValue: Swift.UInt32)
  public typealias RawValue = Swift.UInt32
  public var rawValue: Swift.UInt32 {
    get
  }
}
public struct LogMessage : Swift.Hashable {
  public var level: DGis.LogLevel
  public var text: Swift.String
  public var file: Swift.String
  public var line: Swift.UInt32
  public init(level: DGis.LogLevel, text: Swift.String, file: Swift.String, line: Swift.UInt32)
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (a: DGis.LogMessage, b: DGis.LogMessage) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
}
public protocol LogSink {
  func write(message: DGis.LogMessage)
}
public struct LogOptions {
  public var osLogLevel: DGis.LogLevel
  public var customLogLevel: DGis.LogLevel
  public var customSink: DGis.LogSink?
  public init(osLogLevel: DGis.LogLevel, customLogLevel: DGis.LogLevel, customSink: DGis.LogSink?)
}
public struct Anchor : Swift.Hashable {
  public var x: Swift.Float
  public var y: Swift.Float
  public init(x: Swift.Float = 0.5, y: Swift.Float = 0.5)
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (a: DGis.Anchor, b: DGis.Anchor) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
}
public enum AttributeValue : Swift.Hashable {
  case empty
  case boolean(Swift.Bool)
  case number(Swift.Double)
  case integer(Swift.Int64)
  case string(Swift.String)
  case data(Foundation.Data)
  case array([DGis.AttributeValue])
  case object([Swift.String : DGis.AttributeValue])
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (a: DGis.AttributeValue, b: DGis.AttributeValue) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
}
public enum BearingSource : Swift.UInt32 {
  case auto
  case satellite
  case magnetic
  public init?(rawValue: Swift.UInt32)
  public typealias RawValue = Swift.UInt32
  public var rawValue: Swift.UInt32 {
    get
  }
}
public enum CameraAnimatedMoveReason : Swift.UInt32 {
  case application
  case event
  case `internal`
  public init?(rawValue: Swift.UInt32)
  public typealias RawValue = Swift.UInt32
  public var rawValue: Swift.UInt32 {
    get
  }
}
public enum CameraAnimatedMoveResult : Swift.UInt32 {
  case finished
  case cancelledByEvent
  case cancelledByApplication
  public init?(rawValue: Swift.UInt32)
  public typealias RawValue = Swift.UInt32
  public var rawValue: Swift.UInt32 {
    get
  }
}
public enum CameraAnimationType : Swift.UInt32 {
  case `default`
  case linear
  case showBothPositions
  public init?(rawValue: Swift.UInt32)
  public typealias RawValue = Swift.UInt32
  public var rawValue: Swift.UInt32 {
    get
  }
}
public enum CameraBehaviourChangeReason : Swift.UInt32 {
  case application
  case event
  public init?(rawValue: Swift.UInt32)
  public typealias RawValue = Swift.UInt32
  public var rawValue: Swift.UInt32 {
    get
  }
}
public struct CameraPositionPoint : Swift.Hashable {
  public var x: Swift.Float
  public var y: Swift.Float
  public init(x: Swift.Float = 0.5, y: Swift.Float = 0.5)
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (a: DGis.CameraPositionPoint, b: DGis.CameraPositionPoint) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
}
public enum CameraState : Swift.UInt32 {
  case busy
  case fly
  case followPosition
  case free
  public init?(rawValue: Swift.UInt32)
  public typealias RawValue = Swift.UInt32
  public var rawValue: Swift.UInt32 {
    get
  }
}
public struct Color : Swift.Hashable {
  public var argb: Swift.UInt32
  public init(argb: Swift.UInt32 = 4278190080)
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (a: DGis.Color, b: DGis.Color) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
}
public struct DeviceDensity : Swift.Hashable {
  public var value: Swift.Float
  public init(value: Swift.Float = 0)
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (a: DGis.DeviceDensity, b: DGis.DeviceDensity) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
}
public struct DevicePpi : Swift.Hashable {
  public var value: Swift.Float
  public init(value: Swift.Float = 0)
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (a: DGis.DevicePpi, b: DGis.DevicePpi) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
}
public struct ZIndex : Swift.Hashable {
  public var value: Swift.UInt32
  public init(value: Swift.UInt32 = 0)
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (a: DGis.ZIndex, b: DGis.ZIndex) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
}
public struct Zoom : Swift.Hashable {
  public var value: Swift.Float
  public init(value: Swift.Float = 0)
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (a: DGis.Zoom, b: DGis.Zoom) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
}
public struct Tilt : Swift.Hashable {
  public var value: Swift.Float
  public init(value: Swift.Float = 0)
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (a: DGis.Tilt, b: DGis.Tilt) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
}
public struct CameraPosition : Swift.Hashable {
  public var point: DGis.GeoPoint
  public var zoom: DGis.Zoom
  public var tilt: DGis.Tilt
  public var bearing: DGis.Bearing
  public init(point: DGis.GeoPoint, zoom: DGis.Zoom, tilt: DGis.Tilt = Tilt(value: 0), bearing: DGis.Bearing = Bearing(value: 0))
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (a: DGis.CameraPosition, b: DGis.CameraPosition) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
}
public protocol CameraMoveController {
  func position(time: Foundation.TimeInterval) -> DGis.CameraPosition
  func animationTime() -> Foundation.TimeInterval
}
@_hasMissingDesignatedInitializers final public class NewValuesNotifier : Swift.Hashable {
  @objc deinit
  public static func == (lhs: DGis.NewValuesNotifier, rhs: DGis.NewValuesNotifier) -> Swift.Bool
  final public func hash(into hasher: inout Swift.Hasher)
  final public func sendNotification()
  final public var hashValue: Swift.Int {
    get
  }
}
public enum FollowValue : Swift.UInt32 {
  case coordinates
  case bearing
  case tilt
  case styleZoom
  public init?(rawValue: Swift.UInt32)
  public typealias RawValue = Swift.UInt32
  public var rawValue: Swift.UInt32 {
    get
  }
}
public struct StyleZoom : Swift.Hashable {
  public var value: Swift.Float
  public init(value: Swift.Float = 0)
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (a: DGis.StyleZoom, b: DGis.StyleZoom) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
}
public struct FollowValueOptionSet : Swift.OptionSet, Swift.Hashable {
  public var rawValue: Swift.UInt32
  public static let coordinates: DGis.FollowValueOptionSet
  public static let bearing: DGis.FollowValueOptionSet
  public static let tilt: DGis.FollowValueOptionSet
  public static let styleZoom: DGis.FollowValueOptionSet
  public init(rawValue: Swift.UInt32)
  public typealias ArrayLiteralElement = DGis.FollowValueOptionSet
  public typealias Element = DGis.FollowValueOptionSet
  public typealias RawValue = Swift.UInt32
}
public protocol CustomFollowController {
  func availableValues() -> DGis.FollowValueOptionSet
  func requestValues(values: DGis.FollowValueOptionSet)
  func setNewValuesNotifier(notifier: DGis.NewValuesNotifier?)
  func coordinates() -> DGis.GeoPoint?
  func bearing() -> DGis.Bearing?
  func tilt() -> DGis.Tilt?
  func styleZoom() -> DGis.StyleZoom?
}
@_hasMissingDesignatedInitializers public class Event : Swift.Hashable {
  @objc deinit
  public static func == (lhs: DGis.Event, rhs: DGis.Event) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
@_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers public class InputEvent : DGis.Event {
  public var timestamp: Foundation.TimeInterval {
    get
  }
  @objc deinit
}
@_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers final public class CancelEvent : DGis.Event {
  convenience public init()
  @objc deinit
}
public enum DgisSourceWorkingMode : Swift.UInt32 {
  case online
  public init?(rawValue: Swift.UInt32)
  public typealias RawValue = Swift.UInt32
  public var rawValue: Swift.UInt32 {
    get
  }
}
@_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers final public class DirectMapControlBeginEvent : DGis.Event {
  convenience public init()
  @objc deinit
}
@_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers final public class DirectMapControlEndEvent : DGis.InputEvent {
  convenience public init(timestamp: Foundation.TimeInterval)
  @objc deinit
}
public struct ScreenPoint : Swift.Hashable {
  public var x: Swift.Float
  public var y: Swift.Float
  public init(x: Swift.Float = 0, y: Swift.Float = 0)
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (a: DGis.ScreenPoint, b: DGis.ScreenPoint) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
}
@_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers final public class DirectMapRotationEvent : DGis.InputEvent {
  final public var bearingDelta: DGis.Bearing {
    get
  }
  final public var rotationCenter: DGis.ScreenPoint? {
    get
  }
  convenience public init(bearingDelta: DGis.Bearing, timestamp: Foundation.TimeInterval, rotationCenter: DGis.ScreenPoint? = nil)
  @objc deinit
}
@_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers final public class DirectMapScalingEvent : DGis.InputEvent {
  final public var zoomDelta: Swift.Float {
    get
  }
  final public var scalingCenter: DGis.ScreenPoint? {
    get
  }
  convenience public init(zoomDelta: Swift.Float, timestamp: Foundation.TimeInterval, scalingCenter: DGis.ScreenPoint? = nil)
  @objc deinit
}
public struct ScreenShift : Swift.Hashable {
  public var dx: Swift.Float
  public var dy: Swift.Float
  public init(dx: Swift.Float = 0, dy: Swift.Float = 0)
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (a: DGis.ScreenShift, b: DGis.ScreenShift) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
}
@_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers final public class DirectMapShiftEvent : DGis.InputEvent {
  final public var screenShift: DGis.ScreenShift {
    get
  }
  final public var shiftedPoint: DGis.ScreenPoint {
    get
  }
  convenience public init(screenShift: DGis.ScreenShift, shiftedPoint: DGis.ScreenPoint, timestamp: Foundation.TimeInterval)
  @objc deinit
}
@_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers final public class DirectMapTiltEvent : DGis.InputEvent {
  final public var delta: Swift.Float {
    get
  }
  convenience public init(delta: Swift.Float, timestamp: Foundation.TimeInterval)
  @objc deinit
}
public enum MapRotationDirection : Swift.UInt32 {
  case clockwise
  case counterclockwise
  public init?(rawValue: Swift.UInt32)
  public typealias RawValue = Swift.UInt32
  public var rawValue: Swift.UInt32 {
    get
  }
}
@_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers final public class MapRotationBeginEvent : DGis.Event {
  final public var direction: DGis.MapRotationDirection {
    get
  }
  convenience public init(inDirection: DGis.MapRotationDirection)
  @objc deinit
}
@_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers final public class MapRotationEndEvent : DGis.Event {
  convenience public init()
  @objc deinit
}
public enum MapScalingDirection : Swift.UInt32 {
  case zoomIn
  case zoomOut
  public init?(rawValue: Swift.UInt32)
  public typealias RawValue = Swift.UInt32
  public var rawValue: Swift.UInt32 {
    get
  }
}
@_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers final public class MapScalingBeginEvent : DGis.Event {
  final public var direction: DGis.MapScalingDirection {
    get
  }
  convenience public init(inDirection: DGis.MapScalingDirection)
  @objc deinit
}
@_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers final public class MapScalingEndEvent : DGis.Event {
  convenience public init()
  @objc deinit
}
public enum MapShiftDirection : Swift.UInt32 {
  case left
  case right
  case up
  case down
  case leftUp
  case leftDown
  case rightUp
  case rightDown
  public init?(rawValue: Swift.UInt32)
  public typealias RawValue = Swift.UInt32
  public var rawValue: Swift.UInt32 {
    get
  }
}
@_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers final public class MapShiftBeginEvent : DGis.Event {
  final public var direction: DGis.MapShiftDirection {
    get
  }
  convenience public init(inDirection: DGis.MapShiftDirection)
  @objc deinit
}
@_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers final public class MapShiftEndEvent : DGis.Event {
  convenience public init()
  @objc deinit
}
@_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers final public class RotateMapToNorthEvent : DGis.Event {
  convenience public init()
  @objc deinit
}
@_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers final public class ScaleMapEvent : DGis.Event {
  final public var zoomDelta: Swift.Float {
    get
  }
  final public var scalingCenter: DGis.ScreenPoint? {
    get
  }
  convenience public init(zoomDelta: Swift.Float, scalingCenter: DGis.ScreenPoint? = nil)
  @objc deinit
}
public struct ClusterOptions {
  public var attributes: [Swift.String : DGis.AttributeValue]
  public var userData: Any
  public init(attributes: [Swift.String : DGis.AttributeValue], userData: Any = ())
}
public enum FollowBearing : Swift.UInt32 {
  case off
  case on
  public init?(rawValue: Swift.UInt32)
  public typealias RawValue = Swift.UInt32
  public var rawValue: Swift.UInt32 {
    get
  }
}
public enum FollowStyleZoom : Swift.UInt32 {
  case off
  case on
  public init?(rawValue: Swift.UInt32)
  public typealias RawValue = Swift.UInt32
  public var rawValue: Swift.UInt32 {
    get
  }
}
public struct FollowPosition : Swift.Hashable {
  public var bearing: DGis.FollowBearing
  public var styleZoom: DGis.FollowStyleZoom
  public init(bearing: DGis.FollowBearing = FollowBearing.off, styleZoom: DGis.FollowStyleZoom = FollowStyleZoom.off)
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (a: DGis.FollowPosition, b: DGis.FollowPosition) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
}
public enum FollowTilt : Swift.UInt32 {
  case off
  case on
  public init?(rawValue: Swift.UInt32)
  public typealias RawValue = Swift.UInt32
  public var rawValue: Swift.UInt32 {
    get
  }
}
@_hasMissingDesignatedInitializers final public class Attributes : Swift.Hashable {
  final public var attributeNames: [Swift.String] {
    get
  }
  final public var changed: DGis.Channel<[Swift.String]> {
    get
  }
  @objc deinit
  public static func == (lhs: DGis.Attributes, rhs: DGis.Attributes) -> Swift.Bool
  final public func hash(into hasher: inout Swift.Hasher)
  final public func setAttributeValue(name: Swift.String, value: DGis.AttributeValue)
  final public func setAttributeValues(values: [Swift.String : DGis.AttributeValue], attributesToRemove: [Swift.String] = [])
  final public func removeAttribute(name: Swift.String)
  final public func getAttributeValue(name: Swift.String) -> DGis.AttributeValue
  final public var hashValue: Swift.Int {
    get
  }
}
@_hasMissingDesignatedInitializers public class MapObject : Swift.Hashable {
  public var userData: Any {
    get
    set(userData)
  }
  @objc deinit
  public static func == (lhs: DGis.MapObject, rhs: DGis.MapObject) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
@_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers final public class GeometryMapObject : DGis.MapObject {
  final public var geometryChannel: DGis.StatefulChannel<DGis.Geometry> {
    get
  }
  final public var geometry: DGis.Geometry {
    get
    set(geometry)
  }
  final public var objectAttributes: DGis.Attributes {
    get
  }
  final public var isVisibleChannel: DGis.StatefulChannel<Swift.Bool> {
    get
  }
  final public var isVisible: Swift.Bool {
    get
    set(visible)
  }
  final public var isDraggableChannel: DGis.StatefulChannel<Swift.Bool> {
    get
  }
  final public var isDraggable: Swift.Bool {
    get
    set(draggable)
  }
  final public var bounds: DGis.GeoRect {
    get
  }
  @objc deinit
}
@_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers final public class ClusterObject : DGis.MapObject {
  final public var position: DGis.GeoPointWithElevation {
    get
  }
  final public var objectCount: Swift.UInt32 {
    get
  }
  final public var objects: [DGis.GeometryMapObject] {
    get
  }
  final public var geometryObject: DGis.GeometryMapObject? {
    get
  }
  @objc deinit
}
@_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers final public class DgisMapObject : DGis.MapObject {
  final public var id: DGis.DgisObjectId {
    get
  }
  @objc deinit
}
@_hasMissingDesignatedInitializers public class Source : Swift.Hashable {
  @objc deinit
  public static func == (lhs: DGis.Source, rhs: DGis.Source) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
@_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers final public class DgisSource : DGis.Source {
  final public var highlightedObjectsChannel: DGis.StatefulChannel<[DGis.DgisObjectId]> {
    get
  }
  final public var highlightedObjects: [DGis.DgisObjectId] {
    get
  }
  public static func createDgisSource(context: DGis.Context) -> DGis.Source
  final public func setHighlighted(directoryObjectIds: [DGis.DgisObjectId], highlighted: Swift.Bool)
  @objc deinit
}
@_hasMissingDesignatedInitializers public class FollowController : Swift.Hashable {
  @objc deinit
  public static func == (lhs: DGis.FollowController, rhs: DGis.FollowController) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
@_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers final public class GeometryMapObjectSource : DGis.Source {
  final public var objects: [DGis.GeometryMapObject] {
    get
  }
  final public var sourceAttributes: DGis.Attributes {
    get
  }
  final public func clusteringObjects(position: DGis.CameraPosition) -> [DGis.MapObject]
  final public func addObject(item: DGis.GeometryMapObject)
  final public func addObjects(objects: [DGis.GeometryMapObject])
  final public func removeObject(item: DGis.GeometryMapObject)
  final public func removeObjects(objects: [DGis.GeometryMapObject])
  final public func removeAndAddObjects(objectsToRemove: [DGis.GeometryMapObject], objectsToAdd: [DGis.GeometryMapObject])
  final public func clear()
  @objc deinit
}
@_hasMissingDesignatedInitializers final public class Image : Swift.Hashable {
  @objc deinit
  public static func == (lhs: DGis.Image, rhs: DGis.Image) -> Swift.Bool
  final public func hash(into hasher: inout Swift.Hasher)
  final public var hashValue: Swift.Int {
    get
  }
}
public enum ImageFormat : Swift.UInt32 {
  case pNG
  case sVG
  case rGBA_8888
  case lOTTIE_JSON
  public init?(rawValue: Swift.UInt32)
  public typealias RawValue = Swift.UInt32
  public var rawValue: Swift.UInt32 {
    get
  }
}
public struct ImageData : Swift.Hashable {
  public var size: DGis.ScreenSize
  public var format: DGis.ImageFormat
  public var data: Foundation.Data
  public init(size: DGis.ScreenSize, format: DGis.ImageFormat, data: Foundation.Data)
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (a: DGis.ImageData, b: DGis.ImageData) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
}
@_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers final public class BearingFollowController : DGis.FollowController {
  convenience public init(bearingSource: DGis.BearingSource, animationDuration: Foundation.TimeInterval = 1, valueThreshold: DGis.Bearing = Bearing(value: 1))
  @objc deinit
}
@_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers final public class CoordinatesFollowController : DGis.FollowController {
  convenience public init(animationDuration: Foundation.TimeInterval = 1, valueThreshold: DGis.Meter = Meter(value: 0.10000000149011612))
  @objc deinit
}
public struct Meter : Swift.Hashable {
  public var value: Swift.Float
  public init(value: Swift.Float = 0)
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (a: DGis.Meter, b: DGis.Meter) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
}
@_hasMissingDesignatedInitializers final public class MyLocationController : Swift.Hashable {
  @objc deinit
  public static func == (lhs: DGis.MyLocationController, rhs: DGis.MyLocationController) -> Swift.Bool
  final public func hash(into hasher: inout Swift.Hasher)
  convenience public init(bearingSource: DGis.BearingSource?, animationDuration: Foundation.TimeInterval = 1, coordinatesThreshold: DGis.Meter = Meter(value: 0.10000000149011612), bearingThreshold: DGis.Bearing = Bearing(value: 1))
  final public var hashValue: Swift.Int {
    get
  }
}
@_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers final public class MyLocationMapObject : DGis.MapObject {
  @objc deinit
}
public enum MyLocationMapObjectMarkerType : Swift.UInt32 {
  case mODEL
  case sVG_ICON
  public init?(rawValue: Swift.UInt32)
  public typealias RawValue = Swift.UInt32
  public var rawValue: Swift.UInt32 {
    get
  }
}
@_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers final public class MyLocationMapObjectSource : DGis.Source {
  final public var item: DGis.MyLocationMapObject {
    get
  }
  convenience public init(context: DGis.Context, controller: DGis.MyLocationController, markerType: DGis.MyLocationMapObjectMarkerType = MyLocationMapObjectMarkerType.mODEL)
  final public func setController(controller: DGis.MyLocationController)
  @objc deinit
}
@_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers final public class RoadEventMapObject : DGis.MapObject {
  final public var id: DGis.DgisObjectId {
    get
  }
  final public var event: DGis.RoadEvent {
    get
  }
  @objc deinit
}
public enum RoadEventType : Swift.UInt32 {
  case accident
  case roadWorks
  case camera
  case comment
  case roadRestriction
  case other
  public init?(rawValue: Swift.UInt32)
  public typealias RawValue = Swift.UInt32
  public var rawValue: Swift.UInt32 {
    get
  }
}
@_hasMissingDesignatedInitializers final public class RoadEvent : Swift.Hashable {
  final public var type: DGis.RoadEventType {
    get
  }
  final public var name: Swift.String {
    get
  }
  final public var author: DGis.AuthorInfo {
    get
  }
  final public var timestamp: Foundation.Date? {
    get
  }
  final public var location: DGis.GeoPoint {
    get
  }
  final public var description: Swift.String {
    get
  }
  final public var cameraInfo: DGis.RoadCameraInfo? {
    get
  }
  final public var schedule: DGis.Schedule? {
    get
  }
  final public var lanes: DGis.LaneOptionSet {
    get
  }
  final public var availableActions: [DGis.RoadEventAction] {
    get
  }
  final public var remover: DGis.Remover? {
    get
  }
  @objc deinit
  public static func == (lhs: DGis.RoadEvent, rhs: DGis.RoadEvent) -> Swift.Bool
  final public func hash(into hasher: inout Swift.Hasher)
  final public func photos() -> DGis.Future<[DGis.RoadEventPhoto]>
  final public var hashValue: Swift.Int {
    get
  }
}
public enum AuthorType : Swift.UInt32 {
  case anonymous
  case doubleGis
  case user
  case me
  public init?(rawValue: Swift.UInt32)
  public typealias RawValue = Swift.UInt32
  public var rawValue: Swift.UInt32 {
    get
  }
}
public struct AuthorInfo : Swift.Hashable {
  public var type: DGis.AuthorType
  public var name: Swift.String
  public init(type: DGis.AuthorType, name: Swift.String)
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (a: DGis.AuthorInfo, b: DGis.AuthorInfo) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
}
public enum CameraPurpose : Swift.UInt32 {
  case speedControl
  case averageSpeedControl
  case publicTransportLaneMovementControl
  case roadMarkingsCrossingControl
  case trafficLightsViolationControl
  case stopLineCrossingControl
  case oncomingTrafficLaneMovementControl
  case pedestrianAdvantageViolationControl
  case laneDisciplineControl
  case noStoppingViolationControl
  case dummy
  case truck
  public init?(rawValue: Swift.UInt32)
  public typealias RawValue = Swift.UInt32
  public var rawValue: Swift.UInt32 {
    get
  }
}
public struct CameraPurposeOptionSet : Swift.OptionSet, Swift.Hashable {
  public var rawValue: Swift.UInt32
  public static let speedControl: DGis.CameraPurposeOptionSet
  public static let averageSpeedControl: DGis.CameraPurposeOptionSet
  public static let publicTransportLaneMovementControl: DGis.CameraPurposeOptionSet
  public static let roadMarkingsCrossingControl: DGis.CameraPurposeOptionSet
  public static let trafficLightsViolationControl: DGis.CameraPurposeOptionSet
  public static let stopLineCrossingControl: DGis.CameraPurposeOptionSet
  public static let oncomingTrafficLaneMovementControl: DGis.CameraPurposeOptionSet
  public static let pedestrianAdvantageViolationControl: DGis.CameraPurposeOptionSet
  public static let laneDisciplineControl: DGis.CameraPurposeOptionSet
  public static let noStoppingViolationControl: DGis.CameraPurposeOptionSet
  public static let dummy: DGis.CameraPurposeOptionSet
  public static let truck: DGis.CameraPurposeOptionSet
  public init(rawValue: Swift.UInt32)
  public typealias ArrayLiteralElement = DGis.CameraPurposeOptionSet
  public typealias Element = DGis.CameraPurposeOptionSet
  public typealias RawValue = Swift.UInt32
}
public struct RoadCameraInfo : Swift.Hashable {
  public var purposes: DGis.CameraPurposeOptionSet
  public var speedLimit: Swift.UInt16?
  public init(purposes: DGis.CameraPurposeOptionSet, speedLimit: Swift.UInt16?)
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (a: DGis.RoadCameraInfo, b: DGis.RoadCameraInfo) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
}
public struct Schedule : Swift.Hashable {
  public var startTime: Foundation.Date?
  public var finishTime: Foundation.Date?
  public var weekTimeIntervals: [DGis.WeekTimeInterval]
  public init(startTime: Foundation.Date?, finishTime: Foundation.Date?, weekTimeIntervals: [DGis.WeekTimeInterval])
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (a: DGis.Schedule, b: DGis.Schedule) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
}
public enum Lane : Swift.UInt32 {
  case left
  case center
  case right
  public init?(rawValue: Swift.UInt32)
  public typealias RawValue = Swift.UInt32
  public var rawValue: Swift.UInt32 {
    get
  }
}
public struct LaneOptionSet : Swift.OptionSet, Swift.Hashable {
  public var rawValue: Swift.UInt32
  public static let left: DGis.LaneOptionSet
  public static let center: DGis.LaneOptionSet
  public static let right: DGis.LaneOptionSet
  public init(rawValue: Swift.UInt32)
  public typealias ArrayLiteralElement = DGis.LaneOptionSet
  public typealias Element = DGis.LaneOptionSet
  public typealias RawValue = Swift.UInt32
}
@_hasMissingDesignatedInitializers final public class RoadEventPhoto : Swift.Hashable {
  final public var photoUrl: Swift.String {
    get
  }
  final public var author: DGis.AuthorInfo {
    get
  }
  final public var timestamp: Foundation.Date {
    get
  }
  final public var remover: DGis.Remover? {
    get
  }
  @objc deinit
  public static func == (lhs: DGis.RoadEventPhoto, rhs: DGis.RoadEventPhoto) -> Swift.Bool
  final public func hash(into hasher: inout Swift.Hasher)
  final public func previewUrl(desiredSize: DGis.ScreenSize) -> Swift.String
  final public func report() -> DGis.Future<DGis.ActionResult>
  final public var hashValue: Swift.Int {
    get
  }
}
public enum ActionResult : Swift.UInt32 {
  case ok
  case networkError
  public init?(rawValue: Swift.UInt32)
  public typealias RawValue = Swift.UInt32
  public var rawValue: Swift.UInt32 {
    get
  }
}
@_hasMissingDesignatedInitializers final public class Remover : Swift.Hashable {
  @objc deinit
  public static func == (lhs: DGis.Remover, rhs: DGis.Remover) -> Swift.Bool
  final public func hash(into hasher: inout Swift.Hasher)
  final public func remove() -> DGis.Future<DGis.ActionResult>
  final public var hashValue: Swift.Int {
    get
  }
}
public enum RoadEventActionType : Swift.UInt32 {
  case like
  case dislike
  case confirmation
  case disproof
  public init?(rawValue: Swift.UInt32)
  public typealias RawValue = Swift.UInt32
  public var rawValue: Swift.UInt32 {
    get
  }
}
@_hasMissingDesignatedInitializers final public class RoadEventAction : Swift.Hashable {
  final public var type: DGis.RoadEventActionType {
    get
  }
  final public var name: Swift.String {
    get
  }
  final public var infoChannel: DGis.StatefulChannel<DGis.RoadEventActionInfo> {
    get
  }
  final public var info: DGis.RoadEventActionInfo {
    get
  }
  @objc deinit
  public static func == (lhs: DGis.RoadEventAction, rhs: DGis.RoadEventAction) -> Swift.Bool
  final public func hash(into hasher: inout Swift.Hasher)
  final public func set() -> DGis.Future<DGis.ActionResult>
  final public func reset() -> DGis.Future<DGis.ActionResult>
  final public var hashValue: Swift.Int {
    get
  }
}
public enum RoadEventActionState : Swift.UInt32 {
  case set
  case notSet
  public init?(rawValue: Swift.UInt32)
  public typealias RawValue = Swift.UInt32
  public var rawValue: Swift.UInt32 {
    get
  }
}
public struct RoadEventActionInfo : Swift.Hashable {
  public var state: DGis.RoadEventActionState
  public var count: Swift.UInt32?
  public init(state: DGis.RoadEventActionState, count: Swift.UInt32?)
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (a: DGis.RoadEventActionInfo, b: DGis.RoadEventActionInfo) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
}
@_hasMissingDesignatedInitializers final public class Style : Swift.Hashable {
  final public var styleAttributes: DGis.Attributes {
    get
  }
  @objc deinit
  public static func == (lhs: DGis.Style, rhs: DGis.Style) -> Swift.Bool
  final public func hash(into hasher: inout Swift.Hasher)
  final public var hashValue: Swift.Int {
    get
  }
}
@_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers final public class StyleZoomFollowController : DGis.FollowController {
  convenience public init(animationDuration: Foundation.TimeInterval = 0.3)
  final public func setStyleZoom(styleZoom: DGis.StyleZoom)
  final public func setStyleZoomRange(minStyleZoom: DGis.StyleZoom, maxStyleZoom: DGis.StyleZoom)
  @objc deinit
}
public protocol StyleZoomToTiltRelation {
  func styleZoomToTilt(styleZoom: DGis.StyleZoom) -> DGis.Tilt
}
@_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers final public class TiltFollowController : DGis.FollowController {
  convenience public init(styleZoomToTilt: DGis.StyleZoomToTiltRelation)
  @objc deinit
}
@_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers final public class TrafficSource : DGis.Source {
  convenience public init(context: DGis.Context)
  @objc deinit
}
public enum RoadEventDisplayCategory : Swift.UInt32 {
  case camera
  case comment
  case accident
  case roadRestriction
  case roadWorks
  case other
  case user
  public init?(rawValue: Swift.UInt32)
  public typealias RawValue = Swift.UInt32
  public var rawValue: Swift.UInt32 {
    get
  }
}
@_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers final public class RoadEventSource : DGis.Source {
  final public var visibleEvents: DGis.RoadEventDisplayCategoryOptionSet {
    get
    set(types)
  }
  final public var highlightedObjectsChannel: DGis.StatefulChannel<[DGis.DgisObjectId]> {
    get
  }
  final public var highlightedObjects: [DGis.DgisObjectId] {
    get
  }
  convenience public init(context: DGis.Context)
  final public func setHighlighted(directoryObjectIds: [DGis.DgisObjectId], highlighted: Swift.Bool)
  @objc deinit
}
public struct RoadEventDisplayCategoryOptionSet : Swift.OptionSet, Swift.Hashable {
  public var rawValue: Swift.UInt32
  public static let camera: DGis.RoadEventDisplayCategoryOptionSet
  public static let comment: DGis.RoadEventDisplayCategoryOptionSet
  public static let accident: DGis.RoadEventDisplayCategoryOptionSet
  public static let roadRestriction: DGis.RoadEventDisplayCategoryOptionSet
  public static let roadWorks: DGis.RoadEventDisplayCategoryOptionSet
  public static let other: DGis.RoadEventDisplayCategoryOptionSet
  public static let user: DGis.RoadEventDisplayCategoryOptionSet
  public init(rawValue: Swift.UInt32)
  public typealias ArrayLiteralElement = DGis.RoadEventDisplayCategoryOptionSet
  public typealias Element = DGis.RoadEventDisplayCategoryOptionSet
  public typealias RawValue = Swift.UInt32
}
public enum Alignment : Swift.UInt32 {
  case topLeft
  case topRight
  case bottomLeft
  case bottomRight
  public init?(rawValue: Swift.UInt32)
  public typealias RawValue = Swift.UInt32
  public var rawValue: Swift.UInt32 {
    get
  }
}
public enum AnimationMode : Swift.UInt32 {
  case normal
  case loop
  public init?(rawValue: Swift.UInt32)
  public typealias RawValue = Swift.UInt32
  public var rawValue: Swift.UInt32 {
    get
  }
}
public struct LogicalPixel : Swift.Hashable {
  public var value: Swift.Float
  public init(value: Swift.Float = 0)
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (a: DGis.LogicalPixel, b: DGis.LogicalPixel) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
}
public enum MapDataLoadingState : Swift.UInt32 {
  case loading
  case loaded
  public init?(rawValue: Swift.UInt32)
  public typealias RawValue = Swift.UInt32
  public var rawValue: Swift.UInt32 {
    get
  }
}
public struct MapDirection : Swift.Hashable {
  public var value: Swift.Double
  public init(value: Swift.Double = 0)
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (a: DGis.MapDirection, b: DGis.MapDirection) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
}
public struct MapId : Swift.Hashable {
  public var value: Swift.Int32
  public init(value: Swift.Int32 = 0)
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (a: DGis.MapId, b: DGis.MapId) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
}
public enum MapVisibilityState : Swift.UInt32 {
  case visible
  case hidden
  public init?(rawValue: Swift.UInt32)
  public typealias RawValue = Swift.UInt32
  public var rawValue: Swift.UInt32 {
    get
  }
}
public struct Opacity : Swift.Hashable {
  public var value: Swift.Float
  public init(value: Swift.Float = 0)
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (a: DGis.Opacity, b: DGis.Opacity) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
}
public struct Padding : Swift.Hashable {
  public var left: Swift.UInt32
  public var top: Swift.UInt32
  public var right: Swift.UInt32
  public var bottom: Swift.UInt32
  public init(left: Swift.UInt32 = 0, top: Swift.UInt32 = 0, right: Swift.UInt32 = 0, bottom: Swift.UInt32 = 0)
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (a: DGis.Padding, b: DGis.Padding) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
}
public struct RenderedObject : Swift.Hashable {
  public var item: DGis.MapObject
  public var source: DGis.Source
  public var levelId: DGis.LevelId?
  public init(item: DGis.MapObject, source: DGis.Source, levelId: DGis.LevelId? = nil)
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (a: DGis.RenderedObject, b: DGis.RenderedObject) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
}
public struct ScreenDistance : Swift.Hashable {
  public var value: Swift.Float
  public init(value: Swift.Float = 0)
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (a: DGis.ScreenDistance, b: DGis.ScreenDistance) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
}
public struct StyleLayerId : Swift.Hashable {
  public var id: Swift.String
  public init(id: Swift.String)
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (a: DGis.StyleLayerId, b: DGis.StyleLayerId) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
}
public enum TextPlacement : Swift.UInt32 {
  case noLabel
  case bottomCenter
  case bottomRight
  case bottomLeft
  case circleBottomRight
  case rightBottom
  case rightCenter
  case rightTop
  case circleTopRight
  case topCenter
  case topRight
  case topLeft
  case circleTopLeft
  case leftTop
  case leftCenter
  case leftBottom
  case circleBottomLeft
  case centerCenter
  public init?(rawValue: Swift.UInt32)
  public typealias RawValue = Swift.UInt32
  public var rawValue: Swift.UInt32 {
    get
  }
}
public struct TextStyle : Swift.Hashable {
  public var fontSize: DGis.LogicalPixel
  public var color: DGis.Color
  public var strokeWidth: DGis.LogicalPixel
  public var strokeColor: DGis.Color
  public var textPlacement: DGis.TextPlacement
  public var textOffset: DGis.LogicalPixel
  public var fontName: Swift.String?
  public init(fontSize: DGis.LogicalPixel = LogicalPixel(value: 8), color: DGis.Color = Color(), strokeWidth: DGis.LogicalPixel = LogicalPixel(value: 0.3499999940395355), strokeColor: DGis.Color = Color(argb: 4294967295), textPlacement: DGis.TextPlacement = TextPlacement.bottomCenter, textOffset: DGis.LogicalPixel = LogicalPixel(value: 0), fontName: Swift.String? = nil)
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (a: DGis.TextStyle, b: DGis.TextStyle) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
}
public struct CameraBehaviour : Swift.Hashable {
  public var position: DGis.FollowPosition?
  public var tilt: DGis.FollowTilt
  public init(position: DGis.FollowPosition?, tilt: DGis.FollowTilt = FollowTilt.off)
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (a: DGis.CameraBehaviour, b: DGis.CameraBehaviour) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
}
public struct CameraBehaviourChange : Swift.Hashable {
  public var newBehaviour: DGis.CameraBehaviour
  public var changeReason: DGis.CameraBehaviourChangeReason
  public init(newBehaviour: DGis.CameraBehaviour, changeReason: DGis.CameraBehaviourChangeReason)
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (a: DGis.CameraBehaviourChange, b: DGis.CameraBehaviourChange) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
}
public struct CameraPositionChange : Swift.Hashable {
  public var point: DGis.GeoPoint?
  public var zoom: DGis.Zoom?
  public var tilt: DGis.Tilt?
  public var bearing: DGis.Bearing?
  public init(point: DGis.GeoPoint? = nil, zoom: DGis.Zoom? = nil, tilt: DGis.Tilt? = nil, bearing: DGis.Bearing? = nil)
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (a: DGis.CameraPositionChange, b: DGis.CameraPositionChange) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
}
public struct CameraZoomRestrictions : Swift.Hashable {
  public var minZoom: DGis.Zoom
  public var maxZoom: DGis.Zoom
  public init(minZoom: DGis.Zoom = Zoom(value: 0), maxZoom: DGis.Zoom = Zoom(value: 20))
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (a: DGis.CameraZoomRestrictions, b: DGis.CameraZoomRestrictions) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
}
@_hasMissingDesignatedInitializers final public class GeometryMapObjectBuilder : Swift.Hashable {
  @objc deinit
  public static func == (lhs: DGis.GeometryMapObjectBuilder, rhs: DGis.GeometryMapObjectBuilder) -> Swift.Bool
  final public func hash(into hasher: inout Swift.Hasher)
  convenience public init()
  final public func setObjectAttribute(name: Swift.String, value: DGis.AttributeValue) -> DGis.GeometryMapObjectBuilder
  final public func setObjectAttributes(values: [Swift.String : DGis.AttributeValue]) -> DGis.GeometryMapObjectBuilder
  final public func setGeometry(geometry: DGis.Geometry) -> DGis.GeometryMapObjectBuilder
  final public func setVisible(visible: Swift.Bool) -> DGis.GeometryMapObjectBuilder
  final public func setDraggable(draggable: Swift.Bool) -> DGis.GeometryMapObjectBuilder
  final public func setUserData(userData: Any) -> DGis.GeometryMapObjectBuilder
  final public func createObject() -> DGis.GeometryMapObject
  final public var hashValue: Swift.Int {
    get
  }
}
@_hasMissingDesignatedInitializers final public class GeometryMapObjectSourceBuilder : Swift.Hashable {
  @objc deinit
  public static func == (lhs: DGis.GeometryMapObjectSourceBuilder, rhs: DGis.GeometryMapObjectSourceBuilder) -> Swift.Bool
  final public func hash(into hasher: inout Swift.Hasher)
  convenience public init(context: DGis.Context)
  final public func setSourceAttribute(name: Swift.String, value: DGis.AttributeValue) -> DGis.GeometryMapObjectSourceBuilder
  final public func setSourceAttributes(values: [Swift.String : DGis.AttributeValue]) -> DGis.GeometryMapObjectSourceBuilder
  final public func addObject(item: DGis.GeometryMapObject) -> DGis.GeometryMapObjectSourceBuilder
  final public func addObjects(objects: [DGis.GeometryMapObject]) -> DGis.GeometryMapObjectSourceBuilder
  final public func createSource() -> DGis.GeometryMapObjectSource
  final public var hashValue: Swift.Int {
    get
  }
}
@_hasMissingDesignatedInitializers final public class IndoorBuilding : Swift.Hashable {
  final public var id: DGis.DgisObjectId {
    get
  }
  final public var defaultLevelIndex: Swift.UInt64 {
    get
  }
  final public var levels: [DGis.LevelInfo] {
    get
  }
  final public var activeLevelIndexChannel: DGis.StatefulChannel<Swift.UInt64> {
    get
  }
  final public var activeLevelIndex: Swift.UInt64 {
    get
    set(levelIndex)
  }
  @objc deinit
  public static func == (lhs: DGis.IndoorBuilding, rhs: DGis.IndoorBuilding) -> Swift.Bool
  final public func hash(into hasher: inout Swift.Hasher)
  final public var hashValue: Swift.Int {
    get
  }
}
public enum IndoorManagerState : Swift.UInt32 {
  case disabled
  case enabled
  public init?(rawValue: Swift.UInt32)
  public typealias RawValue = Swift.UInt32
  public var rawValue: Swift.UInt32 {
    get
  }
}
@_hasMissingDesignatedInitializers final public class IndoorManager : Swift.Hashable {
  final public var focusedBuildingChannel: DGis.StatefulChannel<DGis.IndoorBuilding?> {
    get
  }
  final public var focusedBuilding: DGis.IndoorBuilding? {
    get
  }
  @objc deinit
  public static func == (lhs: DGis.IndoorManager, rhs: DGis.IndoorManager) -> Swift.Bool
  final public func hash(into hasher: inout Swift.Hasher)
  final public func setIndoorState(newState: DGis.IndoorManagerState)
  final public var hashValue: Swift.Int {
    get
  }
}
@_hasMissingDesignatedInitializers final public class IndoorControlModel : Swift.Hashable {
  final public var activeLevelIndexChannel: DGis.StatefulChannel<Swift.UInt64?> {
    get
  }
  final public var activeLevelIndex: Swift.UInt64? {
    get
    set(activeIndex)
  }
  final public var markedLevels: Swift.Set<DGis.LevelId> {
    get
    set(markedLevels)
  }
  final public var levelNamesChannel: DGis.StatefulChannel<[Swift.String]> {
    get
  }
  final public var levelNames: [Swift.String] {
    get
  }
  @objc deinit
  public static func == (lhs: DGis.IndoorControlModel, rhs: DGis.IndoorControlModel) -> Swift.Bool
  final public func hash(into hasher: inout Swift.Hasher)
  convenience public init(map: DGis.Map)
  final public func isLevelMarked(index: Swift.UInt64) -> Swift.Bool
  final public var hashValue: Swift.Int {
    get
  }
}
@_hasMissingDesignatedInitializers final public class Map : Swift.Hashable {
  final public var id: DGis.MapId {
    get
  }
  final public var camera: DGis.Camera {
    get
  }
  final public var indoorManager: DGis.IndoorManager {
    get
  }
  final public var dataLoadingStateChannel: DGis.StatefulChannel<DGis.MapDataLoadingState> {
    get
  }
  final public var dataLoadingState: DGis.MapDataLoadingState {
    get
  }
  final public var styleChannel: DGis.StatefulChannel<DGis.Style> {
    get
  }
  final public var style: DGis.Style {
    get
    set(style)
  }
  final public var fontIconSizeMultiplierChannel: DGis.StatefulChannel<Swift.Float> {
    get
  }
  final public var fontIconSizeMultiplier: Swift.Float {
    get
  }
  final public var sources: [DGis.Source] {
    get
  }
  final public var mapVisibilityStateChannel: DGis.StatefulChannel<DGis.MapVisibilityState> {
    get
  }
  final public var mapVisibilityState: DGis.MapVisibilityState {
    get
    set(state)
  }
  final public var attributes: DGis.Attributes {
    get
  }
  final public var interactiveChannel: DGis.StatefulChannel<Swift.Bool> {
    get
  }
  final public var interactive: Swift.Bool {
    get
    set(interactive)
  }
  @objc deinit
  public static func == (lhs: DGis.Map, rhs: DGis.Map) -> Swift.Bool
  final public func hash(into hasher: inout Swift.Hasher)
  final public func setFontIconSizeMultiplier(multiplier: Swift.Float) throws
  final public func resetFontIconSizeMultiplier()
  final public func addSource(source: DGis.Source)
  final public func removeSource(source: DGis.Source)
  final public func getRenderedObjects(centerPoint: DGis.ScreenPoint, radius: DGis.ScreenDistance = ScreenDistance(value: 1)) -> DGis.Future<[DGis.RenderedObjectInfo]>
  final public var hashValue: Swift.Int {
    get
  }
}
@_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers final public class Camera : DGis.BaseCamera {
  final public var stateChannel: DGis.StatefulChannel<DGis.CameraState> {
    get
  }
  final public var state: DGis.CameraState {
    get
  }
  final public var behaviourChannel: DGis.StatefulChannel<DGis.CameraBehaviourChange> {
    get
  }
  final public var behaviour: DGis.CameraBehaviourChange {
    get
  }
  final public func move(moveController: DGis.CameraMoveController) -> DGis.Future<DGis.CameraAnimatedMoveResult>
  final public func move(position: DGis.CameraPosition, time: Foundation.TimeInterval = 0.3, animationType: DGis.CameraAnimationType = CameraAnimationType.`default`) -> DGis.Future<DGis.CameraAnimatedMoveResult>
  final public func move(point: DGis.GeoPoint, zoom: DGis.Zoom, tilt: DGis.Tilt?, bearing: DGis.Bearing, time: Foundation.TimeInterval = 0.3, animationType: DGis.CameraAnimationType = CameraAnimationType.`default`) -> DGis.Future<DGis.CameraAnimatedMoveResult>
  final public func processMovementAndStop()
  final public func setBehaviour(behaviour: DGis.CameraBehaviour)
  final public func addFollowController(followController: DGis.FollowController)
  final public func removeFollowController(followController: DGis.FollowController)
  final public func setCustomFollowController(followController: DGis.CustomFollowController)
  final public func removeCustomFollowController()
  @objc deinit
}
public struct RenderedObjectInfo : Swift.Hashable {
  public var closestViewportPoint: DGis.ScreenPoint
  public var closestMapPoint: DGis.GeoPointWithElevation
  public var item: DGis.RenderedObject
  public init(closestViewportPoint: DGis.ScreenPoint, closestMapPoint: DGis.GeoPointWithElevation, item: DGis.RenderedObject)
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (a: DGis.RenderedObjectInfo, b: DGis.RenderedObjectInfo) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
}
@_hasMissingDesignatedInitializers final public class Projection : Swift.Hashable {
  @objc deinit
  public static func == (lhs: DGis.Projection, rhs: DGis.Projection) -> Swift.Bool
  final public func hash(into hasher: inout Swift.Hasher)
  final public func screenToMap(point: DGis.ScreenPoint) -> DGis.GeoPoint?
  final public func mapToScreen(point: DGis.GeoPoint) -> DGis.ScreenPoint?
  final public func mapToScreen(point: DGis.GeoPointWithElevation) -> DGis.ScreenPoint?
  final public func screenToMapClipped(point: DGis.ScreenPoint) -> DGis.GeoPoint
  final public var hashValue: Swift.Int {
    get
  }
}
@_hasMissingDesignatedInitializers public class BaseCamera : Swift.Hashable {
  public var projection: DGis.Projection {
    get
  }
  public var positionChannel: DGis.StatefulChannel<DGis.CameraPosition> {
    get
  }
  public var position: DGis.CameraPosition {
    get
  }
  public var zoomRestrictionsChannel: DGis.StatefulChannel<DGis.CameraZoomRestrictions> {
    get
  }
  public var zoomRestrictions: DGis.CameraZoomRestrictions {
    get
  }
  public var deviceDensityChannel: DGis.StatefulChannel<DGis.DeviceDensity> {
    get
  }
  public var deviceDensity: DGis.DeviceDensity {
    get
  }
  public var sizeChannel: DGis.StatefulChannel<DGis.ScreenSize> {
    get
  }
  public var size: DGis.ScreenSize {
    get
    set(size)
  }
  public var paddingChannel: DGis.StatefulChannel<DGis.Padding> {
    get
  }
  public var padding: DGis.Padding {
    get
    set(padding)
  }
  public var positionPointChannel: DGis.StatefulChannel<DGis.CameraPositionPoint> {
    get
  }
  public var positionPoint: DGis.CameraPositionPoint {
    get
  }
  public var visibleArea: DGis.Geometry {
    get
  }
  public var visibleRectChannel: DGis.StatefulChannel<DGis.GeoRect> {
    get
  }
  public var visibleRect: DGis.GeoRect {
    get
  }
  public var maxTiltRestrictionChannel: DGis.StatefulChannel<DGis.StyleZoomToTiltRelation?> {
    get
  }
  public var maxTiltRestriction: DGis.StyleZoomToTiltRelation? {
    get
    set(maxTiltRestriction)
  }
  @objc deinit
  public static func == (lhs: DGis.BaseCamera, rhs: DGis.BaseCamera) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public func clone() -> DGis.BaseCamera
  public func setPosition(position: DGis.CameraPosition) throws
  public func changePosition(positionChange: DGis.CameraPositionChange) throws
  public func setZoomRestrictions(zoomRestrictions: DGis.CameraZoomRestrictions) throws
  public func setPositionPoint(positionPoint: DGis.CameraPositionPoint) throws
  public var hashValue: Swift.Int {
    get
  }
}
@_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers public class SimpleMapObject : DGis.MapObject {
  public var isVisible: Swift.Bool {
    get
    set(visible)
  }
  public var zIndex: DGis.ZIndex {
    get
    set(zIndex)
  }
  public var levelId: DGis.LevelId? {
    get
    set(levelId)
  }
  public var bounds: DGis.GeoRect {
    get
  }
  @objc deinit
}
@_hasMissingDesignatedInitializers final public class MapObjectManager : Swift.Hashable {
  final public var isVisible: Swift.Bool {
    get
    set(visible)
  }
  @objc deinit
  public static func == (lhs: DGis.MapObjectManager, rhs: DGis.MapObjectManager) -> Swift.Bool
  final public func hash(into hasher: inout Swift.Hasher)
  convenience public init(map: DGis.Map, layerId: Swift.String? = nil)
  public static func withClustering(map: DGis.Map, logicalPixel: DGis.LogicalPixel, maxZoom: DGis.Zoom, clusterRenderer: DGis.SimpleClusterRenderer, minZoom: DGis.Zoom = Zoom(value: 0), layerId: Swift.String? = nil) -> DGis.MapObjectManager
  public static func withGeneralization(map: DGis.Map, logicalPixel: DGis.LogicalPixel, maxZoom: DGis.Zoom, minZoom: DGis.Zoom = Zoom(value: 0), layerId: Swift.String? = nil) -> DGis.MapObjectManager
  final public func addObject(item: DGis.SimpleMapObject)
  final public func removeObject(item: DGis.SimpleMapObject)
  final public func addObjects(objects: [DGis.SimpleMapObject])
  final public func removeObjects(objects: [DGis.SimpleMapObject])
  final public func removeAndAddObjects(objectsToRemove: [DGis.SimpleMapObject], objectsToAdd: [DGis.SimpleMapObject])
  final public func removeAll()
  final public func clusteringObjects(position: DGis.CameraPosition) -> [DGis.MapObject]
  final public var hashValue: Swift.Int {
    get
  }
}
public struct SimpleClusterOptions {
  public var icon: DGis.Image?
  public var iconMapDirection: DGis.MapDirection?
  public var anchor: DGis.Anchor
  public var text: Swift.String?
  public var textStyle: DGis.TextStyle?
  public var iconOpacity: DGis.Opacity
  public var iconWidth: DGis.LogicalPixel
  public var userData: Any
  public var zIndex: DGis.ZIndex
  public var animatedAppearance: Swift.Bool
  public var iconAnimationMode: DGis.AnimationMode
  public init(icon: DGis.Image?, iconMapDirection: DGis.MapDirection? = nil, anchor: DGis.Anchor = Anchor(x: 0.5, y: 0.5), text: Swift.String? = nil, textStyle: DGis.TextStyle? = nil, iconOpacity: DGis.Opacity = Opacity(value: 1), iconWidth: DGis.LogicalPixel = LogicalPixel(value: 0), userData: Any = (), zIndex: DGis.ZIndex = ZIndex(value: 0), animatedAppearance: Swift.Bool = true, iconAnimationMode: DGis.AnimationMode = AnimationMode.normal)
}
@_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers final public class SimpleClusterObject : DGis.MapObject {
  final public var position: DGis.GeoPointWithElevation {
    get
  }
  final public var objectCount: Swift.UInt32 {
    get
  }
  final public var objects: [DGis.SimpleMapObject] {
    get
  }
  final public var anchor: DGis.Anchor {
    get
    set(anchor)
  }
  final public var iconOpacity: DGis.Opacity {
    get
    set(opacity)
  }
  final public var text: Swift.String {
    get
    set(text)
  }
  final public var textStyle: DGis.TextStyle {
    get
    set(style)
  }
  final public var iconWidth: DGis.LogicalPixel {
    get
    set(width)
  }
  final public var iconMapDirection: DGis.MapDirection? {
    get
    set(direction)
  }
  final public var animatedAppearance: Swift.Bool {
    get
    set(animatedAppearance)
  }
  final public var zIndex: DGis.ZIndex {
    get
    set(zIndex)
  }
  final public func setIcon(icon: DGis.Image?)
  @objc deinit
}
public protocol SimpleClusterRenderer {
  func renderCluster(cluster: DGis.SimpleClusterObject) -> DGis.SimpleClusterOptions
}
@_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers final public class Marker : DGis.SimpleMapObject {
  final public var position: DGis.GeoPointWithElevation {
    get
    set(position)
  }
  final public var icon: DGis.Image? {
    get
    set(icon)
  }
  final public var anchor: DGis.Anchor {
    get
    set(anchor)
  }
  final public var iconOpacity: DGis.Opacity {
    get
    set(opacity)
  }
  final public var text: Swift.String {
    get
    set(text)
  }
  final public var textStyle: DGis.TextStyle {
    get
    set(style)
  }
  final public var isDraggable: Swift.Bool {
    get
    set(draggable)
  }
  final public var iconWidth: DGis.LogicalPixel {
    get
    set(width)
  }
  final public var iconMapDirection: DGis.MapDirection? {
    get
    set(direction)
  }
  final public var animatedAppearance: Swift.Bool {
    get
    set(animatedAppearance)
  }
  final public var iconAnimationMode: DGis.AnimationMode {
    get
    set(iconAnimationMode)
  }
  convenience public init(options: DGis.MarkerOptions) throws
  @objc deinit
}
public struct MarkerOptions {
  public var position: DGis.GeoPointWithElevation
  public var icon: DGis.Image?
  public var iconMapDirection: DGis.MapDirection?
  public var anchor: DGis.Anchor
  public var text: Swift.String?
  public var textStyle: DGis.TextStyle?
  public var iconOpacity: DGis.Opacity
  public var visible: Swift.Bool
  public var draggable: Swift.Bool
  public var iconWidth: DGis.LogicalPixel
  public var userData: Any
  public var zIndex: DGis.ZIndex
  public var animatedAppearance: Swift.Bool
  public var levelId: DGis.LevelId?
  public var iconAnimationMode: DGis.AnimationMode
  public init(position: DGis.GeoPointWithElevation, icon: DGis.Image?, iconMapDirection: DGis.MapDirection? = nil, anchor: DGis.Anchor = Anchor(x: 0.5, y: 0.5), text: Swift.String? = nil, textStyle: DGis.TextStyle? = nil, iconOpacity: DGis.Opacity = Opacity(value: 1), visible: Swift.Bool = true, draggable: Swift.Bool = false, iconWidth: DGis.LogicalPixel = LogicalPixel(value: 0), userData: Any = (), zIndex: DGis.ZIndex = ZIndex(value: 0), animatedAppearance: Swift.Bool = true, levelId: DGis.LevelId? = nil, iconAnimationMode: DGis.AnimationMode = AnimationMode.normal)
}
public struct DashedStrokeCircleOptions : Swift.Hashable {
  public var dashLength: DGis.LogicalPixel
  public var dashSpaceLength: DGis.LogicalPixel
  public init(dashLength: DGis.LogicalPixel = LogicalPixel(value: 5), dashSpaceLength: DGis.LogicalPixel = LogicalPixel(value: 2))
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (a: DGis.DashedStrokeCircleOptions, b: DGis.DashedStrokeCircleOptions) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
}
@_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers final public class Circle : DGis.SimpleMapObject {
  final public var position: DGis.GeoPoint {
    get
  }
  final public var radius: DGis.Meter {
    get
  }
  final public var color: DGis.Color {
    get
    set(color)
  }
  final public var strokeWidth: DGis.LogicalPixel {
    get
    set(width)
  }
  final public var strokeColor: DGis.Color {
    get
    set(color)
  }
  final public var dashedStrokeOptions: DGis.DashedStrokeCircleOptions? {
    get
    set(options)
  }
  convenience public init(options: DGis.CircleOptions) throws
  final public func setPosition(position: DGis.GeoPoint) throws
  final public func setRadius(radius: DGis.Meter) throws
  @objc deinit
}
public struct CircleOptions {
  public var position: DGis.GeoPoint
  public var radius: DGis.Meter
  public var color: DGis.Color
  public var strokeWidth: DGis.LogicalPixel
  public var strokeColor: DGis.Color
  public var dashedStrokeOptions: DGis.DashedStrokeCircleOptions?
  public var visible: Swift.Bool
  public var userData: Any
  public var zIndex: DGis.ZIndex
  public var levelId: DGis.LevelId?
  public init(position: DGis.GeoPoint, radius: DGis.Meter, color: DGis.Color = Color(), strokeWidth: DGis.LogicalPixel = LogicalPixel(value: 0), strokeColor: DGis.Color = Color(), dashedStrokeOptions: DGis.DashedStrokeCircleOptions? = nil, visible: Swift.Bool = true, userData: Any = (), zIndex: DGis.ZIndex = ZIndex(value: 0), levelId: DGis.LevelId? = nil)
}
@_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers final public class Polygon : DGis.SimpleMapObject {
  final public var contours: [[DGis.GeoPoint]] {
    get
    set(contours)
  }
  final public var color: DGis.Color {
    get
    set(color)
  }
  final public var strokeWidth: DGis.LogicalPixel {
    get
    set(width)
  }
  final public var strokeColor: DGis.Color {
    get
    set(color)
  }
  convenience public init(options: DGis.PolygonOptions) throws
  @objc deinit
}
public struct PolygonOptions {
  public var contours: [[DGis.GeoPoint]]
  public var color: DGis.Color
  public var strokeWidth: DGis.LogicalPixel
  public var strokeColor: DGis.Color
  public var visible: Swift.Bool
  public var userData: Any
  public var zIndex: DGis.ZIndex
  public var levelId: DGis.LevelId?
  public init(contours: [[DGis.GeoPoint]], color: DGis.Color = Color(), strokeWidth: DGis.LogicalPixel = LogicalPixel(value: 0), strokeColor: DGis.Color = Color(), visible: Swift.Bool = true, userData: Any = (), zIndex: DGis.ZIndex = ZIndex(value: 0), levelId: DGis.LevelId? = nil)
}
public struct DashedPolylineOptions : Swift.Hashable {
  public var dashLength: DGis.LogicalPixel
  public var dashSpaceLength: DGis.LogicalPixel
  public init(dashLength: DGis.LogicalPixel = LogicalPixel(value: 5), dashSpaceLength: DGis.LogicalPixel = LogicalPixel(value: 2))
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (a: DGis.DashedPolylineOptions, b: DGis.DashedPolylineOptions) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
}
public struct GradientPolylineOptions : Swift.Hashable {
  public var borderWidth: DGis.LogicalPixel
  public var secondBorderWidth: DGis.LogicalPixel
  public var gradientLength: DGis.LogicalPixel
  public var borderColor: DGis.Color
  public var secondBorderColor: DGis.Color
  public var colors: [DGis.Color]
  public var colorIndices: Foundation.Data
  public init(borderWidth: DGis.LogicalPixel = LogicalPixel(value: 0), secondBorderWidth: DGis.LogicalPixel = LogicalPixel(value: 0), gradientLength: DGis.LogicalPixel = LogicalPixel(value: 1), borderColor: DGis.Color = Color(), secondBorderColor: DGis.Color = Color(), colors: [DGis.Color], colorIndices: Foundation.Data)
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (a: DGis.GradientPolylineOptions, b: DGis.GradientPolylineOptions) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
}
@_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers final public class Polyline : DGis.SimpleMapObject {
  final public var points: [DGis.GeoPoint] {
    get
    set(points)
  }
  final public var width: DGis.LogicalPixel {
    get
    set(width)
  }
  final public var color: DGis.Color {
    get
    set(color)
  }
  final public var erasedPart: Swift.Double {
    get
    set(part)
  }
  final public var dashedPolylineOptions: DGis.DashedPolylineOptions? {
    get
    set(options)
  }
  final public var gradientPolylineOptions: DGis.GradientPolylineOptions? {
    get
    set(options)
  }
  convenience public init(options: DGis.PolylineOptions) throws
  @objc deinit
}
public struct PolylineOptions {
  public var points: [DGis.GeoPoint]
  public var width: DGis.LogicalPixel
  public var color: DGis.Color
  public var erasedPart: Swift.Double
  public var dashedPolylineOptions: DGis.DashedPolylineOptions?
  public var gradientPolylineOptions: DGis.GradientPolylineOptions?
  public var visible: Swift.Bool
  public var userData: Any
  public var zIndex: DGis.ZIndex
  public var levelId: DGis.LevelId?
  public init(points: [DGis.GeoPoint], width: DGis.LogicalPixel = LogicalPixel(value: 1), color: DGis.Color = Color(), erasedPart: Swift.Double = 0, dashedPolylineOptions: DGis.DashedPolylineOptions? = nil, gradientPolylineOptions: DGis.GradientPolylineOptions? = nil, visible: Swift.Bool = true, userData: Any = (), zIndex: DGis.ZIndex = ZIndex(value: 0), levelId: DGis.LevelId? = nil)
}
public enum CameraFollowState : Swift.UInt32 {
  case off
  case followPosition
  case followDirection
  public init?(rawValue: Swift.UInt32)
  public typealias RawValue = Swift.UInt32
  public var rawValue: Swift.UInt32 {
    get
  }
}
@_hasMissingDesignatedInitializers final public class MyLocationControlModel : Swift.Hashable {
  final public var isEnabledChannel: DGis.StatefulChannel<Swift.Bool> {
    get
  }
  final public var isEnabled: Swift.Bool {
    get
  }
  final public var followStateChannel: DGis.StatefulChannel<DGis.CameraFollowState> {
    get
  }
  final public var followState: DGis.CameraFollowState {
    get
  }
  @objc deinit
  public static func == (lhs: DGis.MyLocationControlModel, rhs: DGis.MyLocationControlModel) -> Swift.Bool
  final public func hash(into hasher: inout Swift.Hasher)
  convenience public init(map: DGis.Map)
  final public func onClicked()
  final public var hashValue: Swift.Int {
    get
  }
}
@_hasMissingDesignatedInitializers final public class CompassControlModel : Swift.Hashable {
  final public var bearingChannel: DGis.StatefulChannel<DGis.Bearing> {
    get
  }
  final public var bearing: DGis.Bearing {
    get
  }
  @objc deinit
  public static func == (lhs: DGis.CompassControlModel, rhs: DGis.CompassControlModel) -> Swift.Bool
  final public func hash(into hasher: inout Swift.Hasher)
  convenience public init(map: DGis.Map)
  final public func onClicked()
  final public var hashValue: Swift.Int {
    get
  }
}
public enum ZoomControlButton : Swift.UInt32 {
  case zoomIn
  case zoomOut
  public init?(rawValue: Swift.UInt32)
  public typealias RawValue = Swift.UInt32
  public var rawValue: Swift.UInt32 {
    get
  }
}
@_hasMissingDesignatedInitializers final public class ZoomControlModel : Swift.Hashable {
  @objc deinit
  public static func == (lhs: DGis.ZoomControlModel, rhs: DGis.ZoomControlModel) -> Swift.Bool
  final public func hash(into hasher: inout Swift.Hasher)
  convenience public init(map: DGis.Map)
  final public func isEnabled(button: DGis.ZoomControlButton) -> DGis.StatefulChannel<Swift.Bool>
  final public func setPressed(button: DGis.ZoomControlButton, value: Swift.Bool)
  final public var hashValue: Swift.Int {
    get
  }
}
public func parseGeoJsonFile(fsPath: Swift.String) -> [DGis.GeometryMapObject]
public func parseGeoJson(geoJsonData: Swift.String) -> [DGis.GeometryMapObject]
public func calcPosition(camera: DGis.BaseCamera, objects: [DGis.SimpleMapObject], styleZoomToTiltRelation: DGis.StyleZoomToTiltRelation? = nil, screenArea: DGis.Padding? = nil, tilt: DGis.Tilt? = nil, bearing: DGis.Bearing? = nil, size: DGis.ScreenSize? = nil) -> DGis.CameraPosition
public func calcPosition(camera: DGis.BaseCamera, geometry: DGis.Geometry, styleZoomToTiltRelation: DGis.StyleZoomToTiltRelation? = nil, screenArea: DGis.Padding? = nil, tilt: DGis.Tilt? = nil, bearing: DGis.Bearing? = nil, size: DGis.ScreenSize? = nil) -> DGis.CameraPosition
public func zoomOutToFit(camera: DGis.BaseCamera, objects: [DGis.SimpleMapObject], styleZoomToTiltRelation: DGis.StyleZoomToTiltRelation? = nil, size: DGis.ScreenSize? = nil) -> DGis.CameraPosition
public func zoomOutToFit(camera: DGis.BaseCamera, geometry: DGis.Geometry, styleZoomToTiltRelation: DGis.StyleZoomToTiltRelation? = nil, size: DGis.ScreenSize? = nil) -> DGis.CameraPosition
public func createRasterTileDataSource(context: DGis.Context, sublayerName: Swift.String, urlTemplate: Swift.String) -> DGis.Source
public func createDefaultMaxTiltRestriction() -> DGis.StyleZoomToTiltRelation
public func createDefaultStyleZoomToTiltRelation() -> DGis.StyleZoomToTiltRelation
public func createStyleZoomToTiltRelation(points: [DGis.StyleZoom : DGis.Tilt]) -> DGis.StyleZoomToTiltRelation
public func projectionZToStyleZ(projectionZ: DGis.Zoom, latitude: DGis.Latitude) -> DGis.StyleZoom
public func styleZToProjectionZ(styleZ: DGis.StyleZoom, latitude: DGis.Latitude) -> DGis.Zoom
@_hasMissingDesignatedInitializers final public class PackedMapState : Swift.Hashable {
  final public var showTraffic: Swift.Bool {
    get
    set(showTraffic)
  }
  final public var cameraPosition: DGis.CameraPosition {
    get
    set(position)
  }
  final public var cameraBehaviour: DGis.CameraBehaviour {
    get
    set(behaviour)
  }
  @objc deinit
  public static func == (lhs: DGis.PackedMapState, rhs: DGis.PackedMapState) -> Swift.Bool
  final public func hash(into hasher: inout Swift.Hasher)
  public static func of(position: DGis.CameraPosition, showTraffic: Swift.Bool, behaviour: DGis.CameraBehaviour) -> DGis.PackedMapState
  public static func fromBytes(data: Foundation.Data) throws -> DGis.PackedMapState
  public static func fromMap(map: DGis.Map) -> DGis.PackedMapState
  final public func toBytes() -> Foundation.Data
  final public var hashValue: Swift.Int {
    get
  }
}
public struct Locale : Swift.Hashable {
  public var language: Swift.String
  public var region: Swift.String
  public init(language: Swift.String, region: Swift.String)
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (a: DGis.Locale, b: DGis.Locale) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
}
public struct HttpHeader : Swift.Hashable {
  public var name: Swift.String
  public var value: Swift.String
  public init(name: Swift.String, value: Swift.String)
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (a: DGis.HttpHeader, b: DGis.HttpHeader) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
}
public enum HttpMethod : Swift.UInt32 {
  case gET
  case pOST
  public init?(rawValue: Swift.UInt32)
  public typealias RawValue = Swift.UInt32
  public var rawValue: Swift.UInt32 {
    get
  }
}
public struct HttpRequest : Swift.Hashable {
  public var url: Swift.String
  public var method: DGis.HttpMethod
  public var headers: [DGis.HttpHeader]
  public var body: Foundation.Data?
  public init(url: Swift.String, method: DGis.HttpMethod = HttpMethod.gET, headers: [DGis.HttpHeader] = [], body: Foundation.Data? = nil)
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (a: DGis.HttpRequest, b: DGis.HttpRequest) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
}
public struct HttpStatusCode : Swift.Hashable {
  public var value: Swift.Int32
  public init(value: Swift.Int32 = 0)
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (a: DGis.HttpStatusCode, b: DGis.HttpStatusCode) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
}
public struct HttpResponse : Swift.Hashable {
  public var statusCode: DGis.HttpStatusCode
  public var headers: [DGis.HttpHeader]
  public init(statusCode: DGis.HttpStatusCode, headers: [DGis.HttpHeader])
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (a: DGis.HttpResponse, b: DGis.HttpResponse) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
}
@_hasMissingDesignatedInitializers final public class HttpCacheManager : Swift.Hashable {
  final public var currentSize: Swift.UInt64 {
    get
  }
  final public var maxSize: Swift.UInt64 {
    get
    set(size)
  }
  @objc deinit
  public static func == (lhs: DGis.HttpCacheManager, rhs: DGis.HttpCacheManager) -> Swift.Bool
  final public func hash(into hasher: inout Swift.Hasher)
  final public func clear()
  final public var hashValue: Swift.Int {
    get
  }
}
@_hasMissingDesignatedInitializers final public class HttpResponseCallback : Swift.Hashable {
  @objc deinit
  public static func == (lhs: DGis.HttpResponseCallback, rhs: DGis.HttpResponseCallback) -> Swift.Bool
  final public func hash(into hasher: inout Swift.Hasher)
  final public func onResponse(response: DGis.HttpResponse) -> Swift.Bool
  final public func onReceive(body: Foundation.Data, size: Swift.Int32) -> Swift.Bool
  final public func onFinished()
  final public var hashValue: Swift.Int {
    get
  }
}
public protocol HttpClient {
  func sendRequest(request: DGis.HttpRequest, callback: DGis.HttpResponseCallback)
}
@_hasMissingDesignatedInitializers final public class LocaleManager : Swift.Hashable {
  final public var localesChannel: DGis.StatefulChannel<[DGis.Locale]> {
    get
  }
  final public var locales: [DGis.Locale] {
    get
  }
  final public var systemLocalesChannel: DGis.StatefulChannel<[DGis.Locale]> {
    get
  }
  final public var systemLocales: [DGis.Locale] {
    get
  }
  @objc deinit
  public static func == (lhs: DGis.LocaleManager, rhs: DGis.LocaleManager) -> Swift.Bool
  final public func hash(into hasher: inout Swift.Hasher)
  final public func overrideLocales(locales: [DGis.Locale])
  final public var hashValue: Swift.Int {
    get
  }
}
public func getHttpCacheManager(context: DGis.Context) -> DGis.HttpCacheManager?
public func getLocaleManager(context: DGis.Context) -> DGis.LocaleManager
extension DGis.Locale {
  public static func makeLocale(localeStr: Swift.String) -> DGis.Locale?
}
extension DGis.Locale {
  public func toLocalePosix() -> Swift.String
}
public enum DesiredAccuracy : Swift.UInt32 {
  case low
  case medium
  case high
  public init?(rawValue: Swift.UInt32)
  public typealias RawValue = Swift.UInt32
  public var rawValue: Swift.UInt32 {
    get
  }
}
public struct LocationCoordinates : Swift.Hashable {
  public var value: DGis.GeoPoint
  public var accuracy: Swift.Double
  public init(value: DGis.GeoPoint, accuracy: Swift.Double)
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (a: DGis.LocationCoordinates, b: DGis.LocationCoordinates) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
}
public struct LocationFuzzyDouble : Swift.Hashable {
  public var value: Swift.Double
  public var accuracy: Swift.Double?
  public init(value: Swift.Double, accuracy: Swift.Double?)
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (a: DGis.LocationFuzzyDouble, b: DGis.LocationFuzzyDouble) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
}
public struct LocationCourse : Swift.Hashable {
  public var value: DGis.Bearing
  public var accuracy: DGis.Bearing?
  public init(value: DGis.Bearing, accuracy: DGis.Bearing?)
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (a: DGis.LocationCourse, b: DGis.LocationCourse) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
}
public struct Location : Swift.Hashable {
  public var coordinates: DGis.LocationCoordinates
  public var altitude: DGis.LocationFuzzyDouble?
  public var course: DGis.LocationCourse?
  public var groundSpeed: DGis.LocationFuzzyDouble?
  public var source: Swift.String
  public var timestamp: Foundation.TimeInterval
  public init(coordinates: DGis.LocationCoordinates, altitude: DGis.LocationFuzzyDouble?, course: DGis.LocationCourse?, groundSpeed: DGis.LocationFuzzyDouble?, source: Swift.String, timestamp: Foundation.TimeInterval)
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (a: DGis.Location, b: DGis.Location) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
}
public enum AddEventError : Swift.UInt32 {
  case networkError
  case territoryNotSupported
  case unknownUserLocation
  case userLocationTooFarFromEvent
  case notAuthorized
  case noPersonalDataCollectionConsent
  case userBlocked
  case tooManyRequests
  public init?(rawValue: Swift.UInt32)
  public typealias RawValue = Swift.UInt32
  public var rawValue: Swift.UInt32 {
    get
  }
}
public enum AddEventResult : Swift.Hashable {
  case event(DGis.RoadEvent)
  case error(DGis.AddEventError)
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (a: DGis.AddEventResult, b: DGis.AddEventResult) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
}
@_hasMissingDesignatedInitializers final public class RoadEventManager : Swift.Hashable {
  @objc deinit
  public static func == (lhs: DGis.RoadEventManager, rhs: DGis.RoadEventManager) -> Swift.Bool
  final public func hash(into hasher: inout Swift.Hasher)
  convenience public init(context: DGis.Context)
  final public func createAccident(location: DGis.GeoPoint, lanes: DGis.LaneOptionSet, description: Swift.String) -> DGis.Future<DGis.AddEventResult>
  final public func createCamera(location: DGis.GeoPoint, description: Swift.String) -> DGis.Future<DGis.AddEventResult>
  final public func createRoadRestriction(location: DGis.GeoPoint, description: Swift.String) -> DGis.Future<DGis.AddEventResult>
  final public func createComment(location: DGis.GeoPoint, description: Swift.String) -> DGis.Future<DGis.AddEventResult>
  final public func createOther(location: DGis.GeoPoint, lanes: DGis.LaneOptionSet, description: Swift.String) -> DGis.Future<DGis.AddEventResult>
  final public func createRoadWorks(location: DGis.GeoPoint, lanes: DGis.LaneOptionSet, description: Swift.String) -> DGis.Future<DGis.AddEventResult>
  final public var hashValue: Swift.Int {
    get
  }
}
public enum TrafficScoreState : Swift.UInt32 {
  case pending
  case valid
  case expired
  public init?(rawValue: Swift.UInt32)
  public typealias RawValue = Swift.UInt32
  public var rawValue: Swift.UInt32 {
    get
  }
}
public struct TrafficScore : Swift.Hashable {
  public var state: DGis.TrafficScoreState
  public var value: Swift.UInt32?
  public init(state: DGis.TrafficScoreState = TrafficScoreState.pending, value: Swift.UInt32?)
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (a: DGis.TrafficScore, b: DGis.TrafficScore) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
}
@_hasMissingDesignatedInitializers final public class TrafficScoreProvider : Swift.Hashable {
  final public var scoreChannel: DGis.StatefulChannel<DGis.TrafficScore> {
    get
  }
  final public var score: DGis.TrafficScore {
    get
  }
  @objc deinit
  public static func == (lhs: DGis.TrafficScoreProvider, rhs: DGis.TrafficScoreProvider) -> Swift.Bool
  final public func hash(into hasher: inout Swift.Hasher)
  convenience public init(map: DGis.Map)
  convenience public init(context: DGis.Context, point: DGis.GeoPoint)
  final public var hashValue: Swift.Int {
    get
  }
}
public enum TrafficControlStatus : Swift.UInt32 {
  case hidden
  case enabled
  case disabled
  case loading
  public init?(rawValue: Swift.UInt32)
  public typealias RawValue = Swift.UInt32
  public var rawValue: Swift.UInt32 {
    get
  }
}
public struct TrafficControlState : Swift.Hashable {
  public var status: DGis.TrafficControlStatus
  public var score: Swift.UInt32?
  public init(status: DGis.TrafficControlStatus = TrafficControlStatus.hidden, score: Swift.UInt32?)
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (a: DGis.TrafficControlState, b: DGis.TrafficControlState) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
}
@_hasMissingDesignatedInitializers final public class TrafficControlModel : Swift.Hashable {
  final public var stateChannel: DGis.StatefulChannel<DGis.TrafficControlState> {
    get
  }
  final public var state: DGis.TrafficControlState {
    get
  }
  @objc deinit
  public static func == (lhs: DGis.TrafficControlModel, rhs: DGis.TrafficControlModel) -> Swift.Bool
  final public func hash(into hasher: inout Swift.Hasher)
  convenience public init(map: DGis.Map)
  final public func onClicked()
  final public var hashValue: Swift.Int {
    get
  }
}
final public class BufferedChannel<Value> : DGis.Channel<Value> {
  @usableFromInline
  internal typealias CurrentValueGetter = () -> Value?
  @usableFromInline
  final internal let _getter: DGis.BufferedChannel<Value>.CurrentValueGetter
  final public var value: Value? {
    @inlinable get {
			self._getter()
		}
  }
  @usableFromInline
  internal init(subscriber: @escaping DGis.BufferedChannel<Value>.Subscriber, getter: @escaping DGis.BufferedChannel<Value>.CurrentValueGetter, releaser: @escaping DGis.BufferedChannel<Value>.Releaser = {})
  @objc deinit
}
final public class Cancellable {
  @usableFromInline
  final internal let _cancel: () -> Swift.Void
  @usableFromInline
  final internal let _release: () -> Swift.Void
  public init(cancel: @escaping () -> Swift.Void, release: @escaping () -> Swift.Void = {})
  @objc deinit
  @inlinable final public func cancel() {
		self._cancel()
	}
}
extension DGis.Cancellable {
  @inlinable convenience public init() {
		self.init(cancel: {})
	}
}
extension DGis.Cancellable : Swift.Hashable {
  public static func == (lhs: DGis.Cancellable, rhs: DGis.Cancellable) -> Swift.Bool
  final public func hash(into hasher: inout Swift.Hasher)
  final public var hashValue: Swift.Int {
    get
  }
}
public class Channel<Value> {
  @usableFromInline
  internal typealias Receiver = (Value) -> Swift.Void
  @usableFromInline
  internal typealias Subscriber = (@escaping DGis.Channel<Value>.Receiver) -> DGis.Cancellable
  @usableFromInline
  internal typealias Releaser = () -> Swift.Void
  @usableFromInline
  final internal let _subscriber: DGis.Channel<Value>.Subscriber
  @usableFromInline
  final internal let _releaser: DGis.Channel<Value>.Releaser
  @usableFromInline
  internal init(subscriber: @escaping DGis.Channel<Value>.Subscriber, releaser: @escaping DGis.Channel<Value>.Releaser = {})
  @objc deinit
  @inlinable public func sink(receiveValue: @escaping (Value) -> Swift.Void) -> DGis.Cancellable {
		self._subscriber(receiveValue)
	}
}
extension DGis.Channel : Swift.Hashable {
  public static func == (lhs: DGis.Channel<Value>, rhs: DGis.Channel<Value>) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
public struct SimpleError : Swift.Error, Swift.CustomStringConvertible, Swift.Equatable {
  public let description: Swift.String
  public init(description: Swift.String)
  public static func == (lhs: DGis.SimpleError, rhs: DGis.SimpleError) -> Swift.Bool
}
extension DGis.SimpleError : Swift.CustomDebugStringConvertible {
  @inlinable public var debugDescription: Swift.String {
    get {
		return self.description
	}
  }
}
final public class Future<Value> {
  public typealias Error = DGis.SimpleError
  public typealias Receiver = (Value) -> Swift.Void
  public typealias FailureHandler = (DGis.Future<Value>.Error) -> Swift.Void
  public typealias Subscriber = (@escaping DGis.Future<Value>.Receiver, @escaping DGis.Future<Value>.FailureHandler) -> DGis.Cancellable
  public typealias Canceller = () -> Swift.Void
  @usableFromInline
  final internal let _subscriber: DGis.Future<Value>.Subscriber
  @usableFromInline
  final internal let _canceller: DGis.Future<Value>.Canceller
  public init(subscriber: @escaping DGis.Future<Value>.Subscriber, canceller: @escaping DGis.Future<Value>.Canceller = {})
  @objc deinit
  @inlinable final public func sink(receiveValue: @escaping (Value) -> Swift.Void, failure: @escaping (DGis.Future<Value>.Error) -> Swift.Void) -> DGis.Cancellable {
		self._subscriber(receiveValue, failure)
	}
}
extension DGis.Future {
  public static func makeReadyValue(_ value: Value) -> DGis.Future<Value>
  public static func makeReadyError(message: Swift.String) -> DGis.Future<Value>
}
extension DGis.Future : Swift.Hashable {
  public static func == (lhs: DGis.Future<Value>, rhs: DGis.Future<Value>) -> Swift.Bool
  final public func hash(into hasher: inout Swift.Hasher)
  final public var hashValue: Swift.Int {
    get
  }
}
public enum JSONValue : Swift.Equatable, Swift.Hashable {
  case null
  case bool(Swift.Bool)
  case number(Swift.Double)
  case string(Swift.String)
  case array([DGis.JSONValue])
  case object([Swift.String : DGis.JSONValue])
  public static func == (a: DGis.JSONValue, b: DGis.JSONValue) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
extension DGis.JSONValue : Swift.ExpressibleByNilLiteral {
  public init(nilLiteral: ())
}
extension DGis.JSONValue : Swift.ExpressibleByBooleanLiteral {
  public typealias BooleanLiteralType = Swift.Bool
  public init(booleanLiteral value: Swift.Bool)
}
extension DGis.JSONValue : Swift.ExpressibleByIntegerLiteral {
  public typealias IntegerLiteralType = Swift.Int64
  public init(integerLiteral value: Swift.Int64)
}
extension DGis.JSONValue : Swift.ExpressibleByFloatLiteral {
  public typealias FloatLiteralType = Swift.Double
  public init(floatLiteral value: Swift.Double)
}
extension DGis.JSONValue : Swift.ExpressibleByStringLiteral {
  public typealias StringLiteralType = Swift.String
  public init(stringLiteral value: Swift.String)
  public typealias ExtendedGraphemeClusterLiteralType = DGis.JSONValue.StringLiteralType
  public typealias UnicodeScalarLiteralType = DGis.JSONValue.StringLiteralType
}
extension DGis.JSONValue : Swift.ExpressibleByArrayLiteral {
  public typealias ArrayLiteralElement = DGis.JSONValue
  public init(arrayLiteral elements: DGis.JSONValue...)
}
extension DGis.JSONValue : Swift.ExpressibleByDictionaryLiteral {
  public typealias Key = Swift.String
  public typealias Value = DGis.JSONValue
  public init(dictionaryLiteral elements: (Swift.String, DGis.JSONValue)...)
}
extension DGis.JSONValue : Swift.Decodable {
  public init(from decoder: Swift.Decoder) throws
}
extension DGis.JSONValue : Swift.Encodable {
  public func encode(to encoder: Swift.Encoder) throws
}
final public class StatefulChannel<Value> : DGis.Channel<Value> {
  @usableFromInline
  internal typealias CurrentValueGetter = () -> Value
  @usableFromInline
  final internal let _getter: DGis.StatefulChannel<Value>.CurrentValueGetter
  final public var value: Value {
    @inlinable get {
			self._getter()
		}
  }
  @usableFromInline
  internal init(subscriber: @escaping DGis.StatefulChannel<Value>.Subscriber, getter: @escaping DGis.StatefulChannel<Value>.CurrentValueGetter, releaser: @escaping DGis.StatefulChannel<Value>.Releaser = {})
  @objc deinit
}
public struct ApiKeyOptions {
  public let apiKeyFile: DGis.File
  public init(apiKeyFile: DGis.File)
}
extension DGis.ApiKeyOptions {
  public static let `default`: DGis.ApiKeyOptions
}
public struct BatteryOptions {
  public var lowBatteryThreshold: Swift.Int
  weak public var delegate: DGis.IBatteryManagerDelegate?
  public init(lowBatteryThreshold: Swift.Int, delegate: DGis.IBatteryManagerDelegate?)
}
extension DGis.BatteryOptions {
  public static let `default`: DGis.BatteryOptions
}
public protocol IBatteryManagerDelegate : AnyObject {
  func startBatteryMonitoring()
  func stopBatteryMonitoring()
}
public protocol ICancellable {
  func cancel()
}
public struct NoopCancellable : DGis.ICancellable {
  public init()
  public func cancel()
}
extension DGis.Cancellable : DGis.ICancellable {
}
@_hasMissingDesignatedInitializers final public class Container {
  #if compiler(>=5.3) && $EffectfulProp
  final public var context: DGis.Context {
    get throws
  }
  #endif
  final public var markerViewFactory: DGis.IMarkerViewFactory {
    get
  }
  final public var locationService: DGis.ILocationService {
    get
  }
  final public let httpOptions: DGis.HTTPOptions
  final public let batteryOptions: DGis.BatteryOptions
  final public let localizationOptions: DGis.LocalizationOptions
  @objc deinit
  final public func makeMapFactory(options: DGis.MapOptions) throws -> DGis.IMapFactory
  final public func makeStyleFactory() throws -> DGis.IStyleFactory
  final public func makeSearchManagerFactory() throws -> DGis.ISearchManagerFactory
  final public func makeSourceFactory() throws -> DGis.ISourceFactory
  final public func makeImageFactory() throws -> DGis.IImageFactory
  final public func makeLocaleManager() throws -> DGis.LocaleManager
  final public func makeRoadEventCardViewFactory(options: DGis.RoadEventCardViewOptions = .default) throws -> DGis.IRoadEventCardViewFactory
}
extension DGis.Container {
  convenience public init(apiKeyOptions: DGis.ApiKeyOptions = .default, logOptions: DGis.LogOptions = .default, httpClientForRequest: DGis.IHTTPClient? = nil, httpOptions: DGis.HTTPOptions = .default, positioningServices: DGis.IPositioningServicesFactory = PlatformPositioningServicesFactory(), batteryOptions: DGis.BatteryOptions = .default, personalDataCollectionOptions: DGis.PersonalDataCollectionOptions = .default, localizationOptions: DGis.LocalizationOptions = .default, vendorConfigFile: DGis.File? = nil)
}
public typealias CreateRoadEventResult = Swift.Result<DGis.AddEventResult, Swift.Error>
public protocol ICreateRoadEventView : UIKit.UIView {
  var visibleAreaEdgeInsets: UIKit.UIEdgeInsets { get }
  var visibleAreaEdgeInsetsChangedCallback: ((UIKit.UIEdgeInsets) -> Swift.Void)? { get set }
  var cancelButtonCallback: (() -> Swift.Void)? { get set }
  var createRoadEventRequestCallback: ((DGis.CreateRoadEventResult) -> Swift.Void)? { get set }
}
extension DGis.DevicePpi {
  public static let autodetected: DGis.DevicePpi?
  public static let defaultForFailedAutodetection: DGis.DevicePpi
}
extension DGis.DevicePpi : Swift.ExpressibleByFloatLiteral {
  public typealias FloatLiteralType = Swift.Float
  public init(floatLiteral value: Swift.Float)
}
public protocol ISearchManager {
  func suggest(query: DGis.SuggestQuery) -> DGis.Future<DGis.SuggestResult>
  func search(query: DGis.SearchQuery) -> DGis.Future<DGis.SearchResult>
  func searchById(id: Swift.String) -> DGis.Future<DGis.DirectoryObject?>
  func searchByDirectoryObjectId(objectId: DGis.DgisObjectId) -> DGis.Future<DGis.DirectoryObject?>
}
extension DGis.SearchManager : DGis.ISearchManager {
}
public protocol ISearchManagerFactory {
  func makeOnlineManager() throws -> DGis.ISearchManager?
}
extension DGis.ScreenPoint {
  public init(_ cgPoint: CoreFoundation.CGPoint)
}
extension DGis.ScreenShift {
  public init(_ cgVector: CoreFoundation.CGVector)
}
extension DGis.ScreenSize {
  public init(_ cgSize: CoreFoundation.CGSize)
}
public protocol IDoubleTapAndPanGestureRecognizer : AnyObject {
  var scaleDoublingTranslation: CoreFoundation.CGFloat { get set }
}
public protocol IMapGestureView {
  var doubleTapGestureRecognizer: UIKit.UITapGestureRecognizer? { get }
  var panGestureRecognizer: UIKit.UIPanGestureRecognizer? { get }
  var twoFingerPanGestureRecognizer: UIKit.UIPanGestureRecognizer? { get }
  var rotationGestureRecognizer: UIKit.UIRotationGestureRecognizer? { get }
  var pinchGestureRecognizer: UIKit.UIPinchGestureRecognizer? { get }
  var twoFingerTapGestureRecognizer: UIKit.UITapGestureRecognizer? { get }
  var doubleTapAndPanGestureRecognizer: (UIKit.UIGestureRecognizer & DGis.IDoubleTapAndPanGestureRecognizer)? { get }
}
extension DGis.IMapGestureView {
  public var doubleTapGestureRecognizer: UIKit.UITapGestureRecognizer? {
    get
  }
  public var panGestureRecognizer: UIKit.UIPanGestureRecognizer? {
    get
  }
  public var twoFingerPanGestureRecognizer: UIKit.UIPanGestureRecognizer? {
    get
  }
  public var rotationGestureRecognizer: UIKit.UIRotationGestureRecognizer? {
    get
  }
  public var pinchGestureRecognizer: UIKit.UIPinchGestureRecognizer? {
    get
  }
  public var twoFingerTapGestureRecognizer: UIKit.UITapGestureRecognizer? {
    get
  }
  public var doubleTapAndPanGestureRecognizer: (UIKit.UIGestureRecognizer & DGis.IDoubleTapAndPanGestureRecognizer)? {
    get
  }
}
public protocol IMapGestureViewFactory {
  @available(*, deprecated, message: "Please use makeGestureView(map:eventProcessor:coordinateSpace:)")
  func makeGestureView(map: DGis.Map, coordinateSpace: DGis.IMapCoordinateSpace) -> UIKit.UIView & DGis.IMapGestureView
  func makeGestureView(map: DGis.Map, eventProcessor: DGis.IMapEventProcessor, coordinateSpace: DGis.IMapCoordinateSpace) -> UIKit.UIView & DGis.IMapGestureView
}
extension DGis.IMapGestureViewFactory {
  public func makeGestureView(map: DGis.Map, coordinateSpace: DGis.IMapCoordinateSpace) -> UIKit.UIView & DGis.IMapGestureView
  public func makeGestureView(map: DGis.Map, eventProcessor: DGis.IMapEventProcessor, coordinateSpace: DGis.IMapCoordinateSpace) -> UIKit.UIView & DGis.IMapGestureView
}
public protocol IMapEventProcessor {
  func process(event: DGis.Event)
}
public struct MapGestureViewOptions {
  public enum ScalingCenter : Swift.Int {
    case eventCenter
    case cameraPosition
    public init?(rawValue: Swift.Int)
    public typealias RawValue = Swift.Int
    public var rawValue: Swift.Int {
      get
    }
  }
  public var doubleTapScalingCenter: DGis.MapGestureViewOptions.ScalingCenter
  public var twoFingerTapScalingCenter: DGis.MapGestureViewOptions.ScalingCenter
  public var pinchScalingCenter: DGis.MapGestureViewOptions.ScalingCenter
  public init(doubleTapScalingCenter: DGis.MapGestureViewOptions.ScalingCenter, twoFingerTapScalingCenter: DGis.MapGestureViewOptions.ScalingCenter, pinchScalingCenter: DGis.MapGestureViewOptions.ScalingCenter)
}
extension DGis.MapGestureViewOptions {
  public static let `default`: DGis.MapGestureViewOptions
}
public struct MapGestureViewFactory : DGis.IMapGestureViewFactory {
  public init(options: DGis.MapGestureViewOptions = .default)
  public func makeGestureView(map: DGis.Map, eventProcessor: DGis.IMapEventProcessor, coordinateSpace: DGis.IMapCoordinateSpace) -> UIKit.UIView & DGis.IMapGestureView
}
extension DGis.Locale : Swift.CustomStringConvertible {
  public var description: Swift.String {
    get
  }
}
public struct LocalizationOptions {
  public let locales: [DGis.Locale]
  public let systemLocales: [DGis.Locale]
  public init(locales: [DGis.Locale], systemLocales: [DGis.Locale])
  public init(locales: [DGis.Locale])
}
extension DGis.LocalizationOptions {
  public static let `default`: DGis.LocalizationOptions
}
extension DGis.LogOptions {
  public static let `default`: DGis.LogOptions
}
@usableFromInline
internal func sdkLog(level: DGis.LogLevel = .info, file: Swift.StaticString = #file, line: Swift.UInt = #line, function: Swift.StaticString = #function, _ message: Swift.String)
public protocol IEnergyConsumption : AnyObject {
  typealias FpsCallback = (_ fps: Swift.Double) -> Swift.Void
  var maxFps: Swift.Int? { get set }
  var powerSavingMaxFps: Swift.Int? { get set }
  func setFpsCallback(_ fpsCallback: Self.FpsCallback?)
}
public protocol IMapCoordinateSpace : DGis.INativeScaleProvider, UIKit.UICoordinateSpace {
}
public protocol INativeScaleProvider {
  var nativeScale: CoreFoundation.CGFloat { get }
  var toPixels: CoreFoundation.CGAffineTransform { get }
}
public protocol IMapFactory {
  var initialMapOptions: DGis.MapOptions { get }
  var map: DGis.Map { get }
  var mapView: UIKit.UIView & DGis.IMapView { get }
  var gestureView: (UIKit.UIView & DGis.IMapGestureView)? { get }
  var mapEventProcessor: DGis.IMapEventProcessor { get }
  var mapCoordinateSpace: DGis.IMapCoordinateSpace { get }
  var mapControlFactory: DGis.IMapControlFactory { get }
  var snapshotter: DGis.IMapSnapshotter { get }
  var energyConsumption: DGis.IEnergyConsumption { get }
  var markerViewOverlay: DGis.IMarkerViewOverlay { get }
}
public protocol IMapSnapshotter {
  func makeImage(scale: CoreFoundation.CGFloat, orientation: UIKit.UIImage.Orientation) -> DGis.Future<UIKit.UIImage>
}
extension DGis.IMapSnapshotter {
  public func makeImage(scale: CoreFoundation.CGFloat = 1, orientation: UIKit.UIImage.Orientation = .up) -> DGis.Future<UIKit.UIImage>
}
public enum CopyrightAlignment {
  case topLeft, bottomLeft, bottomRight, topRight
  public static func == (a: DGis.CopyrightAlignment, b: DGis.CopyrightAlignment) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
public protocol IMapView : UIKit.UIView {
  var gestureView: (UIKit.UIView & DGis.IMapGestureView)? { get set }
  var appearance: DGis.MapAppearance { get set }
  var showsAPIVersion: Swift.Bool { get set }
  var copyrightAlignment: DGis.CopyrightAlignment { get set }
  var copyrightInsets: UIKit.UIEdgeInsets { get set }
  var urlOpener: ((Foundation.URL) -> Swift.Void)? { get set }
  func addObjectTappedCallback(callback: DGis.MapObjectTappedCallback)
  func addObjectLongPressCallback(callback: DGis.MapObjectTappedCallback)
  func removeObjectTappedCallback(callback: DGis.MapObjectTappedCallback)
  func removeLongPressCallback(callback: DGis.MapObjectTappedCallback)
}
extension DGis.Map {
  final public func setNavigation(_ isOn: Swift.Bool)
}
public enum MapAppearance : Swift.Hashable {
  case `default`
  case universal(DGis.Theme)
  case automatic(light: DGis.Theme, dark: DGis.Theme)
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (a: DGis.MapAppearance, b: DGis.MapAppearance) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
}
extension DGis.MapAppearance : Swift.CustomStringConvertible {
  public var description: Swift.String {
    get
  }
}
extension DGis.MapAppearance {
  public var defaultBackgroundColor: DGis.Color? {
    get
  }
}
public class MapObjectTappedCallback {
  public init(callback: @escaping (_ objectInfo: DGis.RenderedObjectInfo) -> Swift.Void)
  public func call(objectInfo: DGis.RenderedObjectInfo)
  @objc deinit
}
extension DGis.MapObjectTappedCallback : Swift.Equatable {
  public static func == (lhs: DGis.MapObjectTappedCallback, rhs: DGis.MapObjectTappedCallback) -> Swift.Bool
}
public struct MapOptions {
  public var devicePPI: DGis.DevicePpi?
  public var deviceDensity: DGis.DeviceDensity?
  public var position: DGis.CameraPosition?
  public var positionPoint: DGis.CameraPositionPoint?
  public var zoomRestrictions: DGis.CameraZoomRestrictions?
  public var sources: [DGis.Source]?
  public var sourceDescriptors: Swift.Set<DGis.MapOptions.SourceDescriptor>?
  public var styleFuture: DGis.Future<DGis.Style>?
  public var gestureViewFactory: DGis.IMapGestureViewFactory?
  public var appearance: DGis.MapAppearance?
  public var maxFps: Swift.Int?
  public var powerSavingMaxFps: Swift.Int?
  public var backgroundColor: DGis.Color?
}
extension DGis.MapOptions {
  public enum SourceDescriptor {
    case dgisOnlineSource
    public static func == (a: DGis.MapOptions.SourceDescriptor, b: DGis.MapOptions.SourceDescriptor) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
}
extension DGis.MapOptions {
  public static var `default`: DGis.MapOptions
}
public struct Theme : Swift.Hashable {
  public init(name: Swift.String)
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (a: DGis.Theme, b: DGis.Theme) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
}
extension DGis.Theme : Swift.ExpressibleByStringLiteral {
  public typealias StringLiteralType = Swift.String
  public init(stringLiteral value: Swift.String)
  public typealias ExtendedGraphemeClusterLiteralType = DGis.Theme.StringLiteralType
  public typealias UnicodeScalarLiteralType = DGis.Theme.StringLiteralType
}
extension DGis.Theme : Swift.CustomStringConvertible {
  public var description: Swift.String {
    get
  }
}
@objc @_hasMissingDesignatedInitializers @_Concurrency.MainActor(unsafe) final public class CompassControl : UIKit.UIControl {
  @_Concurrency.MainActor(unsafe) @objc override final public var intrinsicContentSize: CoreFoundation.CGSize {
    @objc get
  }
  @_Concurrency.MainActor(unsafe) @objc override final public func layoutSubviews()
  @objc deinit
}
@objc @_hasMissingDesignatedInitializers @_Concurrency.MainActor(unsafe) final public class CreateRoadEventControl : UIKit.UIControl {
  @_Concurrency.MainActor(unsafe) @objc override final public var intrinsicContentSize: CoreFoundation.CGSize {
    @objc get
  }
  @_Concurrency.MainActor(unsafe) @objc override final public func layoutSubviews()
  @objc deinit
}
@objc @_hasMissingDesignatedInitializers @_Concurrency.MainActor(unsafe) final public class CurrentLocationControl : UIKit.UIControl {
  @_Concurrency.MainActor(unsafe) @objc override final public var intrinsicContentSize: CoreFoundation.CGSize {
    @objc get
  }
  @_Concurrency.MainActor(unsafe) @objc override final public func layoutSubviews()
  @objc deinit
}
public struct IndoorControlOptions {
  public enum VisibilityBehavior {
    case automatic
    case manual
    public static func == (a: DGis.IndoorControlOptions.VisibilityBehavior, b: DGis.IndoorControlOptions.VisibilityBehavior) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  public var visibilityBehavior: DGis.IndoorControlOptions.VisibilityBehavior
  public init(visibilityBehavior: DGis.IndoorControlOptions.VisibilityBehavior)
  public static let `default`: DGis.IndoorControlOptions
}
@objc @_hasMissingDesignatedInitializers @_Concurrency.MainActor(unsafe) final public class IndoorControl : UIKit.UIControl {
  @_Concurrency.MainActor(unsafe) final public var focusedBuildingChangeCallback: (() -> Swift.Void)?
  @_Concurrency.MainActor(unsafe) @objc override final public var intrinsicContentSize: CoreFoundation.CGSize {
    @objc get
  }
  @_Concurrency.MainActor(unsafe) @objc override final public func layoutSubviews()
  @objc deinit
}
public protocol IMapControlFactory {
  func makeZoomControl() -> DGis.ZoomControl
  func makeCurrentLocationControl() -> DGis.CurrentLocationControl
  func makeCompassControl() -> DGis.CompassControl
  func makeTrafficControl() -> DGis.TrafficControl
  func makeCreateRoadEventControl() -> DGis.CreateRoadEventControl
  func makeIndoorControl(_ options: DGis.IndoorControlOptions) -> DGis.IndoorControl
}
extension DGis.IMapControlFactory {
  public func makeIndoorControl(_ options: DGis.IndoorControlOptions = .default) -> DGis.IndoorControl
}
@objc @_hasMissingDesignatedInitializers @_Concurrency.MainActor(unsafe) final public class TrafficControl : UIKit.UIControl {
  @_Concurrency.MainActor(unsafe) @objc override final public func traitCollectionDidChange(_ previousTraitCollection: UIKit.UITraitCollection?)
  @_Concurrency.MainActor(unsafe) @objc override final public var intrinsicContentSize: CoreFoundation.CGSize {
    @objc get
  }
  @_Concurrency.MainActor(unsafe) @objc override final public func layoutSubviews()
  @_Concurrency.MainActor(unsafe) final public func switchTrafficVisibility()
  @objc deinit
}
@objc @_hasMissingDesignatedInitializers @_Concurrency.MainActor(unsafe) final public class ZoomControl : UIKit.UIControl {
  @_Concurrency.MainActor(unsafe) final public var buttonSpacing: CoreFoundation.CGFloat {
    get
    set
  }
  @_Concurrency.MainActor(unsafe) @objc override final public var intrinsicContentSize: CoreFoundation.CGSize {
    @objc get
  }
  @_Concurrency.MainActor(unsafe) @objc override final public func layoutSubviews()
  @objc deinit
}
public protocol IMarkerView : UIKit.UIView {
  var id: Foundation.UUID { get }
  var position: DGis.GeoPointWithElevation { get }
  var tapHandler: (() -> Swift.Void)? { get set }
}
public protocol IMarkerViewFactory {
  func make(view: UIKit.UIView, position: DGis.GeoPointWithElevation, anchor: DGis.Anchor, offsetX: CoreFoundation.CGFloat, offsetY: CoreFoundation.CGFloat) -> DGis.IMarkerView
}
public protocol IMarkerViewOverlay : UIKit.UIView {
  func add(markerView: DGis.IMarkerView)
  func add(markerViews: [DGis.IMarkerView])
  func remove(markerView: DGis.IMarkerView)
  func remove(markerViews: [DGis.IMarkerView])
  func removeAll()
}
public protocol IImageFactory {
  func make(pngData: Foundation.Data, size: CoreFoundation.CGSize) -> DGis.Image
  func make(svgData: Foundation.Data, size: CoreFoundation.CGSize) -> DGis.Image
  func make(lottieData: Foundation.Data, size: CoreFoundation.CGSize) -> DGis.Image
  func make(image: UIKit.UIImage) -> DGis.Image
  func make(imageFactory: @escaping () -> UIKit.UIImage) -> DGis.Image
}
public struct HTTPOptions {
  public enum CacheOptions {
    case disk(DGis.HTTPOptions.DiskCacheOptions)
  }
  public struct DiskCacheOptions {
    public let cachesDir: Foundation.URL
    public let maximumCacheSize: Swift.UInt64
  }
  public let timeout: Foundation.TimeInterval
  public let cacheOptions: DGis.HTTPOptions.CacheOptions?
  public init(timeout: Foundation.TimeInterval, cacheOptions: DGis.HTTPOptions.CacheOptions?)
}
extension DGis.HTTPOptions.DiskCacheOptions {
  public init(maximumCacheSize: Swift.UInt64)
}
extension DGis.HTTPOptions {
  public static let `default`: DGis.HTTPOptions
}
public protocol IHTTPClient {
  typealias RequestDataCompletionCallback = (Foundation.HTTPURLResponse?, Foundation.Data?, Swift.Error?) -> Swift.Void
  func send(request: Foundation.URLRequest, callback: @escaping Self.RequestDataCompletionCallback)
}
public struct PersonalDataCollectionOptions {
  public let personalDataCollectionConsent: DGis.PersonalDataCollectionConsent
  public init(personalDataCollectionConsent: DGis.PersonalDataCollectionConsent)
}
extension DGis.PersonalDataCollectionOptions {
  public static let `default`: DGis.PersonalDataCollectionOptions
}
public protocol ILocationProvider {
  typealias LocationCallback = (_ locations: [CoreLocation.CLLocation]) -> Swift.Void
  typealias AvailabilityCallback = (_ isAvailable: Swift.Bool) -> Swift.Void
  var lastLocation: CoreLocation.CLLocation? { get }
  func setCallbacks(locationCallback: Self.LocationCallback?, availabilityCallback: Self.AvailabilityCallback?)
  func setDesiredAccuracy(_ accuracy: DGis.DesiredAccuracy)
}
public protocol ILocationService {
  var lastLocation: CoreLocation.CLLocation? { get }
}
public protocol IMagneticHeadingProvider {
  typealias HeadingCallback = (_ heading: CoreLocation.CLHeading) -> Swift.Void
  typealias AvailabilityCallback = (_ isAvailable: Swift.Bool) -> Swift.Void
  func setCallbacks(headingCallback: Self.HeadingCallback?, availabilityCallback: Self.AvailabilityCallback?)
}
public protocol IPositioningServicesFactory {
  typealias PositioningQueue = Dispatch.DispatchQueue
  var locationProvider: DGis.ILocationProvider? { get }
  var magneticHeadingProvider: DGis.IMagneticHeadingProvider? { get }
}
public struct PlatformPositioningServicesFactory : DGis.IPositioningServicesFactory {
  public let locationProvider: DGis.ILocationProvider?
  public let magneticHeadingProvider: DGis.IMagneticHeadingProvider?
  public init(locationManager: CoreLocation.CLLocationManager = CLLocationManager())
}
public struct UnavailablePositioningServicesFactory : DGis.IPositioningServicesFactory {
  public let locationProvider: DGis.ILocationProvider?
  public let magneticHeadingProvider: DGis.IMagneticHeadingProvider?
  public init()
}
public protocol IRoadEventCardViewFactory {
  func makeRoadEventCardView(_ roadEvent: DGis.RoadEvent) -> DGis.IRoadEventCardView
  func makeCreateRoadEventView(map: DGis.Map) -> DGis.ICreateRoadEventView
}
public typealias RoadEventActionResult = Swift.Result<(type: DGis.RoadEventActionType, result: DGis.ActionResult), Swift.Error>
public typealias RoadEventRemoveResult = Swift.Result<DGis.ActionResult, Swift.Error>
public protocol IRoadEventCardView : UIKit.UIView {
  var closeButtonCallback: (() -> Swift.Void)? { get set }
  var roadEventActionResultCallback: ((DGis.RoadEventActionResult) -> Swift.Void)? { get set }
  var removeRoadEventActionResultCallback: ((DGis.RoadEventRemoveResult) -> Swift.Void)? { get set }
  func setRoadEvent(_ roadEvent: DGis.RoadEvent)
}
public struct RoadEventCardViewOptions {
  public var timeFormattingStrategy: DGis.TimeFormattingStrategy
  public init(timeFormattingStrategy: DGis.TimeFormattingStrategy = .default)
}
extension DGis.RoadEventCardViewOptions {
  public static var `default`: DGis.RoadEventCardViewOptions
}
extension DGis.Bearing : Swift.ExpressibleByFloatLiteral {
  public typealias FloatLiteralType = Swift.Double
  public init(floatLiteral value: Swift.Double)
}
extension DGis.Color {
  public init(red: CoreFoundation.CGFloat, green: CoreFoundation.CGFloat, blue: CoreFoundation.CGFloat, alpha: CoreFoundation.CGFloat)
  public init?(_ color: UIKit.UIColor)
}
extension UIKit.UIColor {
  convenience public init(_ color: DGis.Color)
}
extension DGis.Elevation {
  public init(_ distance: CoreLocation.CLLocationDistance)
}
extension DGis.Elevation : Swift.ExpressibleByFloatLiteral {
  public typealias FloatLiteralType = Swift.Float
  public init(floatLiteral value: Swift.Float)
}
extension DGis.GeoPoint {
  public init(latitude: CoreLocation.CLLocationDegrees, longitude: CoreLocation.CLLocationDegrees)
  public init(coordinate: CoreLocation.CLLocationCoordinate2D)
  public func bearing(point: DGis.GeoPoint) -> DGis.Bearing
  public func distance(point: DGis.GeoPoint) -> DGis.Meter
  public func move(bearing: DGis.Bearing, meter: DGis.Meter) -> DGis.GeoPoint
}
extension CoreLocation.CLLocationCoordinate2D {
  public init(point: DGis.GeoPoint)
}
extension DGis.GeoPointWithElevation {
  public var point: DGis.GeoPoint {
    get
  }
  public init(point: DGis.GeoPoint, elevation: DGis.Elevation = 0.0)
  public init(latitude: CoreLocation.CLLocationDegrees, longitude: CoreLocation.CLLocationDegrees, elevation: CoreLocation.CLLocationDistance)
  public init(coordinate: CoreLocation.CLLocationCoordinate2D, elevation: CoreLocation.CLLocationDistance)
  public func bearing(point: DGis.GeoPoint) -> DGis.Bearing
  public func distance(point: DGis.GeoPoint) -> DGis.Meter
  public func move(bearing: DGis.Bearing, meter: DGis.Meter) -> DGis.GeoPointWithElevation
}
extension DGis.Latitude : Swift.ExpressibleByFloatLiteral {
  public typealias FloatLiteralType = Swift.Double
  public init(floatLiteral value: Swift.Double)
}
extension DGis.LogicalPixel : Swift.ExpressibleByFloatLiteral {
  public typealias FloatLiteralType = Swift.Float
  public init(floatLiteral value: Swift.Float)
}
extension DGis.Longitude : Swift.ExpressibleByFloatLiteral {
  public typealias FloatLiteralType = Swift.Double
  public init(floatLiteral value: Swift.Double)
}
extension DGis.Meter : Swift.ExpressibleByFloatLiteral {
  public typealias FloatLiteralType = Swift.Float
  public init(floatLiteral value: Swift.Float)
}
extension DGis.Tilt : Swift.ExpressibleByFloatLiteral {
  public typealias FloatLiteralType = Swift.Float
  public init(floatLiteral value: Swift.Float)
}
extension DGis.Zoom : Swift.ExpressibleByFloatLiteral {
  public typealias FloatLiteralType = Swift.Float
  public init(floatLiteral value: Swift.Float)
}
extension DGis.StyleZoom : Swift.ExpressibleByFloatLiteral {
  public typealias FloatLiteralType = Swift.Float
  public init(floatLiteral value: Swift.Float)
}
public protocol ISourceFactory {
  func createOnlineDGISSource() -> DGis.Source
  func createGeometryMapObjectSourceBuilder() -> DGis.GeometryMapObjectSourceBuilder
}
public protocol IStyleFactory {
  @discardableResult
  func setAttribute(name: Swift.String, value: DGis.AttributeValue) -> Self
  func loadDefault() -> DGis.Future<DGis.Style>
  func loadFile(path: Swift.String) -> DGis.Future<DGis.Style>
}
extension DGis.IStyleFactory {
  public func loadFile(url: Foundation.URL) -> DGis.Future<DGis.Style>
  public func loadResource(name: Swift.String, bundle: Foundation.Bundle) -> DGis.Future<DGis.Style>
}
extension DGis.Camera {
  final public func setPosition(point: DGis.GeoPoint, zoom: DGis.Zoom) throws
  final public func setPosition(point: DGis.GeoPoint) throws
}
public struct MTLDeviceError : DGis.ISDKError, Swift.CustomStringConvertible {
  public let description: Swift.String
  public init(description: Swift.String)
}
extension DGis.MTLDeviceError : Swift.CustomDebugStringConvertible {
  @inlinable public var debugDescription: Swift.String {
    get {
		return self.description
	}
  }
}
public protocol ISDKError : Swift.Error {
}
public struct SDKError : DGis.ISDKError, Swift.CustomStringConvertible {
  public let description: Swift.String
  public init(description: Swift.String)
}
extension DGis.SDKError : Swift.CustomDebugStringConvertible {
  @inlinable public var debugDescription: Swift.String {
    get {
		return self.description
	}
  }
}
public enum TimeFormattingStrategy {
  case `default`
  case formatted(Foundation.DateFormatter)
  case custom((Foundation.Date) -> Swift.String)
}
extension DGis.DayTime : Swift.Comparable {
  public static func < (lhs: DGis.DayTime, rhs: DGis.DayTime) -> Swift.Bool
}
extension DGis.WeekTime : Swift.Comparable {
  public static func < (lhs: DGis.WeekTime, rhs: DGis.WeekTime) -> Swift.Bool
}
extension DGis.WeekDay : Swift.Comparable {
  public static func < (lhs: DGis.WeekDay, rhs: DGis.WeekDay) -> Swift.Bool
}
public struct VendorConfigOptions {
  public let vendorConfigFile: DGis.File
  public init(vendorConfigFile: DGis.File)
}
extension DGis.PersonalDataCollectionConsent : Swift.Equatable {}
extension DGis.PersonalDataCollectionConsent : Swift.Hashable {}
extension DGis.PersonalDataCollectionConsent : Swift.RawRepresentable {}
extension DGis.WeekDay : Swift.Hashable {}
extension DGis.WeekDay : Swift.RawRepresentable {}
extension DGis.FilterType : Swift.Equatable {}
extension DGis.FilterType : Swift.Hashable {}
extension DGis.FilterType : Swift.RawRepresentable {}
extension DGis.FormattingType : Swift.Equatable {}
extension DGis.FormattingType : Swift.Hashable {}
extension DGis.FormattingType : Swift.RawRepresentable {}
extension DGis.ObjectType : Swift.Equatable {}
extension DGis.ObjectType : Swift.Hashable {}
extension DGis.ObjectType : Swift.RawRepresentable {}
extension DGis.ParkingAccess : Swift.Equatable {}
extension DGis.ParkingAccess : Swift.Hashable {}
extension DGis.ParkingAccess : Swift.RawRepresentable {}
extension DGis.SpecialSpaceType : Swift.Equatable {}
extension DGis.SpecialSpaceType : Swift.Hashable {}
extension DGis.SpecialSpaceType : Swift.RawRepresentable {}
extension DGis.ParkingType : Swift.Equatable {}
extension DGis.ParkingType : Swift.Hashable {}
extension DGis.ParkingType : Swift.RawRepresentable {}
extension DGis.ParkingPurpose : Swift.Equatable {}
extension DGis.ParkingPurpose : Swift.Hashable {}
extension DGis.ParkingPurpose : Swift.RawRepresentable {}
extension DGis.ParkingPavingType : Swift.Equatable {}
extension DGis.ParkingPavingType : Swift.Hashable {}
extension DGis.ParkingPavingType : Swift.RawRepresentable {}
extension DGis.SearchResultType : Swift.Equatable {}
extension DGis.SearchResultType : Swift.Hashable {}
extension DGis.SearchResultType : Swift.RawRepresentable {}
extension DGis.SortingType : Swift.Equatable {}
extension DGis.SortingType : Swift.Hashable {}
extension DGis.SortingType : Swift.RawRepresentable {}
extension DGis.WidgetType : Swift.Equatable {}
extension DGis.WidgetType : Swift.Hashable {}
extension DGis.WidgetType : Swift.RawRepresentable {}
extension DGis.CheckableItemType : Swift.Equatable {}
extension DGis.CheckableItemType : Swift.Hashable {}
extension DGis.CheckableItemType : Swift.RawRepresentable {}
extension DGis.GeometryKind : Swift.Equatable {}
extension DGis.GeometryKind : Swift.Hashable {}
extension DGis.GeometryKind : Swift.RawRepresentable {}
extension DGis.SuggestedType : Swift.Equatable {}
extension DGis.SuggestedType : Swift.Hashable {}
extension DGis.SuggestedType : Swift.RawRepresentable {}
extension DGis.SuggestorType : Swift.Equatable {}
extension DGis.SuggestorType : Swift.Hashable {}
extension DGis.SuggestorType : Swift.RawRepresentable {}
extension DGis.LogLevel : Swift.Equatable {}
extension DGis.LogLevel : Swift.Hashable {}
extension DGis.LogLevel : Swift.RawRepresentable {}
extension DGis.BearingSource : Swift.Equatable {}
extension DGis.BearingSource : Swift.Hashable {}
extension DGis.BearingSource : Swift.RawRepresentable {}
extension DGis.CameraAnimatedMoveReason : Swift.Equatable {}
extension DGis.CameraAnimatedMoveReason : Swift.Hashable {}
extension DGis.CameraAnimatedMoveReason : Swift.RawRepresentable {}
extension DGis.CameraAnimatedMoveResult : Swift.Equatable {}
extension DGis.CameraAnimatedMoveResult : Swift.Hashable {}
extension DGis.CameraAnimatedMoveResult : Swift.RawRepresentable {}
extension DGis.CameraAnimationType : Swift.Equatable {}
extension DGis.CameraAnimationType : Swift.Hashable {}
extension DGis.CameraAnimationType : Swift.RawRepresentable {}
extension DGis.CameraBehaviourChangeReason : Swift.Equatable {}
extension DGis.CameraBehaviourChangeReason : Swift.Hashable {}
extension DGis.CameraBehaviourChangeReason : Swift.RawRepresentable {}
extension DGis.CameraState : Swift.Equatable {}
extension DGis.CameraState : Swift.Hashable {}
extension DGis.CameraState : Swift.RawRepresentable {}
extension DGis.FollowValue : Swift.Equatable {}
extension DGis.FollowValue : Swift.Hashable {}
extension DGis.FollowValue : Swift.RawRepresentable {}
extension DGis.DgisSourceWorkingMode : Swift.Equatable {}
extension DGis.DgisSourceWorkingMode : Swift.Hashable {}
extension DGis.DgisSourceWorkingMode : Swift.RawRepresentable {}
extension DGis.MapRotationDirection : Swift.Equatable {}
extension DGis.MapRotationDirection : Swift.Hashable {}
extension DGis.MapRotationDirection : Swift.RawRepresentable {}
extension DGis.MapScalingDirection : Swift.Equatable {}
extension DGis.MapScalingDirection : Swift.Hashable {}
extension DGis.MapScalingDirection : Swift.RawRepresentable {}
extension DGis.MapShiftDirection : Swift.Equatable {}
extension DGis.MapShiftDirection : Swift.Hashable {}
extension DGis.MapShiftDirection : Swift.RawRepresentable {}
extension DGis.FollowBearing : Swift.Equatable {}
extension DGis.FollowBearing : Swift.Hashable {}
extension DGis.FollowBearing : Swift.RawRepresentable {}
extension DGis.FollowStyleZoom : Swift.Equatable {}
extension DGis.FollowStyleZoom : Swift.Hashable {}
extension DGis.FollowStyleZoom : Swift.RawRepresentable {}
extension DGis.FollowTilt : Swift.Equatable {}
extension DGis.FollowTilt : Swift.Hashable {}
extension DGis.FollowTilt : Swift.RawRepresentable {}
extension DGis.ImageFormat : Swift.Equatable {}
extension DGis.ImageFormat : Swift.Hashable {}
extension DGis.ImageFormat : Swift.RawRepresentable {}
extension DGis.MyLocationMapObjectMarkerType : Swift.Equatable {}
extension DGis.MyLocationMapObjectMarkerType : Swift.Hashable {}
extension DGis.MyLocationMapObjectMarkerType : Swift.RawRepresentable {}
extension DGis.RoadEventType : Swift.Equatable {}
extension DGis.RoadEventType : Swift.Hashable {}
extension DGis.RoadEventType : Swift.RawRepresentable {}
extension DGis.AuthorType : Swift.Equatable {}
extension DGis.AuthorType : Swift.Hashable {}
extension DGis.AuthorType : Swift.RawRepresentable {}
extension DGis.CameraPurpose : Swift.Equatable {}
extension DGis.CameraPurpose : Swift.Hashable {}
extension DGis.CameraPurpose : Swift.RawRepresentable {}
extension DGis.Lane : Swift.Equatable {}
extension DGis.Lane : Swift.Hashable {}
extension DGis.Lane : Swift.RawRepresentable {}
extension DGis.ActionResult : Swift.Equatable {}
extension DGis.ActionResult : Swift.Hashable {}
extension DGis.ActionResult : Swift.RawRepresentable {}
extension DGis.RoadEventActionType : Swift.Equatable {}
extension DGis.RoadEventActionType : Swift.Hashable {}
extension DGis.RoadEventActionType : Swift.RawRepresentable {}
extension DGis.RoadEventActionState : Swift.Equatable {}
extension DGis.RoadEventActionState : Swift.Hashable {}
extension DGis.RoadEventActionState : Swift.RawRepresentable {}
extension DGis.RoadEventDisplayCategory : Swift.Equatable {}
extension DGis.RoadEventDisplayCategory : Swift.Hashable {}
extension DGis.RoadEventDisplayCategory : Swift.RawRepresentable {}
extension DGis.Alignment : Swift.Equatable {}
extension DGis.Alignment : Swift.Hashable {}
extension DGis.Alignment : Swift.RawRepresentable {}
extension DGis.AnimationMode : Swift.Equatable {}
extension DGis.AnimationMode : Swift.Hashable {}
extension DGis.AnimationMode : Swift.RawRepresentable {}
extension DGis.MapDataLoadingState : Swift.Equatable {}
extension DGis.MapDataLoadingState : Swift.Hashable {}
extension DGis.MapDataLoadingState : Swift.RawRepresentable {}
extension DGis.MapVisibilityState : Swift.Equatable {}
extension DGis.MapVisibilityState : Swift.Hashable {}
extension DGis.MapVisibilityState : Swift.RawRepresentable {}
extension DGis.TextPlacement : Swift.Equatable {}
extension DGis.TextPlacement : Swift.Hashable {}
extension DGis.TextPlacement : Swift.RawRepresentable {}
extension DGis.IndoorManagerState : Swift.Equatable {}
extension DGis.IndoorManagerState : Swift.Hashable {}
extension DGis.IndoorManagerState : Swift.RawRepresentable {}
extension DGis.CameraFollowState : Swift.Equatable {}
extension DGis.CameraFollowState : Swift.Hashable {}
extension DGis.CameraFollowState : Swift.RawRepresentable {}
extension DGis.ZoomControlButton : Swift.Equatable {}
extension DGis.ZoomControlButton : Swift.Hashable {}
extension DGis.ZoomControlButton : Swift.RawRepresentable {}
extension DGis.HttpMethod : Swift.Equatable {}
extension DGis.HttpMethod : Swift.Hashable {}
extension DGis.HttpMethod : Swift.RawRepresentable {}
extension DGis.DesiredAccuracy : Swift.Equatable {}
extension DGis.DesiredAccuracy : Swift.Hashable {}
extension DGis.DesiredAccuracy : Swift.RawRepresentable {}
extension DGis.AddEventError : Swift.Equatable {}
extension DGis.AddEventError : Swift.Hashable {}
extension DGis.AddEventError : Swift.RawRepresentable {}
extension DGis.TrafficScoreState : Swift.Equatable {}
extension DGis.TrafficScoreState : Swift.Hashable {}
extension DGis.TrafficScoreState : Swift.RawRepresentable {}
extension DGis.TrafficControlStatus : Swift.Equatable {}
extension DGis.TrafficControlStatus : Swift.Hashable {}
extension DGis.TrafficControlStatus : Swift.RawRepresentable {}
extension DGis.MapGestureViewOptions.ScalingCenter : Swift.Equatable {}
extension DGis.MapGestureViewOptions.ScalingCenter : Swift.Hashable {}
extension DGis.MapGestureViewOptions.ScalingCenter : Swift.RawRepresentable {}
extension DGis.CopyrightAlignment : Swift.Equatable {}
extension DGis.CopyrightAlignment : Swift.Hashable {}
extension DGis.MapOptions.SourceDescriptor : Swift.Equatable {}
extension DGis.MapOptions.SourceDescriptor : Swift.Hashable {}
extension DGis.IndoorControlOptions.VisibilityBehavior : Swift.Equatable {}
extension DGis.IndoorControlOptions.VisibilityBehavior : Swift.Hashable {}
